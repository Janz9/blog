<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>cURL 基础</title>
    <url>/2020/05/18/curl%20001/</url>
    <content><![CDATA[<h1 id="基础">基础</h1>
<p><a href="https://curl.haxx.se/">cURL</a> 项目的主要目的和侧重点围绕着两个产品展开:</p>
<ul>
<li>命令行工具 curl;</li>
<li>提供 C API 的 <a href="https://curl.haxx.se/libcurl/">libcurl</a> 库</li>
</ul>
<h2 id="命令行">命令行</h2>
<p><strong>命令行选项</strong> 可以将想要用 curl 执行的任务的信息传给 curl</p>
<ul>
<li>很多选项属于切换开关, 用于启用某些功能或切换两个已知状态, 指定对应的选项名称即可使用这些选项;</li>
<li>对于一些选项, 需要向它们传递一些数据</li>
</ul>
<p>cURL 提供了 WEB 版本的 <a href="https://curl.haxx.se/docs/manpage.html">文档</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出所有选项并提供简要的说明</span></span><br><span class="line">curl -h</span><br><span class="line">curl --help</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取手册页以及常见的用例教程</span></span><br><span class="line">curl -M</span><br><span class="line">curl --manual</span><br></pre></td></tr></table></figure>
<h3 id="短选项">短选项</h3>
<p><strong>短选项</strong> 使用起来非常方便, 因为它们的名字很简短</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通过短选项切换到详细(verbose)模式</span></span><br><span class="line">curl -v http://example.com/</span><br></pre></td></tr></table></figure>
<h3 id="长选项">长选项</h3>
<p>因为字母的数量有限, 需要用到的选项又比较多, 所以并非所有选项都可以使用单个字母来表示, 于是就有了 <strong>长选项</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通过长选项切换到详细模式</span></span><br><span class="line">curl --verbose http://example.com/</span><br></pre></td></tr></table></figure>
<h3 id="负选项">负选项</h3>
<p>对于开关选项, 既可以用它们打开某些功能, 也可以通过 <strong>负选项</strong> 关闭功能</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 关闭详细模式</span></span><br><span class="line">curl --no-verbose http://example.com/</span><br></pre></td></tr></table></figure>
<h3 id="选项参数">选项参数</h3>
<p>可以通过选项传递参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通过POST将字符串发送到服务器</span></span><br><span class="line">curl -d arbitrary http://example.com/</span><br><span class="line">curl --data arbitrary http://example.com/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果使用带参数的短选项, 可以不使用空格进行分隔</span></span><br><span class="line">curl -darbitrary http://example.com/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过文件将数据传给curl, 假设json文件包含了待发送数据</span></span><br><span class="line">curl -d @json http://example.com/</span><br></pre></td></tr></table></figure>
<h2 id="url">URL</h2>
<p>curl 假定会传给它一个有效的 URL(Uniform Resource Locator, 统一资源定位符), 它只对格式进行有限的检查, 以提取执行操作所需要的信息</p>
<h3 id="scheme">scheme</h3>
<p>scheme 用于指定 URL 使用的协议, scheme 必须受当前 curl 版本支持, 否则将显示错误消息并退出, 为方便起见, curl 允许用户省略 URL 的 scheme 部分, curl 会根据主机名的第一部分猜测要使用哪种协议</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用http://协议</span></span><br><span class="line">curl http://example.com/</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用file://协议时, 主机名部分只能是localhost, 127.0.0.1或空白</span></span><br><span class="line">curl file://localhost/file</span><br><span class="line">curl file://127.0.0.1/file</span><br><span class="line">curl file:///file</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Windows系统上的curl允许以下这种不正确的格式, X是Windows的磁盘分区符</span></span><br><span class="line">curl file://X:/file</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 没有提供scheme的URL默认使用HTTP</span></span><br><span class="line">curl example.com/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过传统的服务器命名方式, curl可以检测的协议包括 FTP DICT LDAP IMAP SMTP POP3</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以通过 --proto-default 选项将默认协议修改为 HTTP 以外的其他协议</span></span><br></pre></td></tr></table></figure>
<h3 id="用户名和密码">用户名和密码</h3>
<p>scheme 后面可以跟用户名和密码, 现在通常不建议这种语法, 因为这样很容易在脚本或其他地方泄露这些信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用给定的用户名和密码列出FTP服务器目录中的内容</span></span><br><span class="line">curl ftp://user:password@example.com</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> curl提供了-u或--user接受用户名和密码</span></span><br><span class="line">curl -u user:password ftp://example.com</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 不指定密码时, curl会在运行时提示用户输入密码</span></span><br><span class="line">curl -u user ftp://example.com</span><br></pre></td></tr></table></figure>
<h3 id="主机名或地址">主机名或地址</h3>
<p>URL 的主机名部分只是一个可以解析为数字 IP 地址的名字, 或者是数字 IP 地址本身</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 指定数字IP地址</span></span><br><span class="line">curl http://127.0.0.1/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果使用的是IPv6地址, 则需要将其放在方括号中</span></span><br><span class="line">curl http://[::1]/</span><br></pre></td></tr></table></figure>
<h3 id="端口号">端口号</h3>
<p>每个协议都有一个默认端口, 除非特别指定了端口号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 指定端口号</span></span><br><span class="line">curl http://127.0.0.1:8080/</span><br><span class="line">curl http://[::1]:8080/</span><br></pre></td></tr></table></figure>
<h3 id="路径">路径</h3>
<p>每个 URL 都包含一个路径, 如果没有指定, 则默认使用 <code>/</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 匿名从FTP服务器获取文件</span></span><br><span class="line">curl ftp://ftp.example.com/README</span><br><span class="line"><span class="meta">#</span><span class="bash"> 对于具有目录概念的协议, 可以在URL尾部以一个斜杠表示它是目录, 而不是文件</span></span><br><span class="line">curl ftp://ftp.example.com/tmp/</span><br></pre></td></tr></table></figure>
<h3 id="片段">片段</h3>
<p>片段通常由 <code>#</code> 和网页中特定名字组成, curl 可以支持带有片段的 URL, 但实际上片段并不会被发送出去, 因此, 无论是否存在, 它对 curl 的操作并没有任何影响</p>
<h2 id="url-通配">URL 通配</h2>
<p>有时会有一组大致相同的 URL, 它们只有一小部分不同, 不同的部分可能是一组数字或一组名字, curl 提供了通配的方式来指定这类 URL</p>
<h3 id="范围">范围</h3>
<p>可以使用 <code>[N-M]</code> 语法来指定一个范围, 其中 <code>N</code> 是起始索引, <code>M</code> 是结束索引</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 处理数字范围</span></span><br><span class="line">curl -O http://example.com/[1-100].png</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以使用零作为前缀</span></span><br><span class="line">curl -O http://example.com/[001-100].png</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 处理字母范围</span></span><br><span class="line">curl -O http://example.com/section[a-z].html</span><br></pre></td></tr></table></figure>
<h3 id="列表">列表</h3>
<p>有时 URL 不同部分不会遵循简单的模式, 那么可以指定完整的列表</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 指定列表</span></span><br><span class="line">curl -O http://example.com/&#123;one,two,three,alpha,beta&#125;.html</span><br></pre></td></tr></table></figure>
<h3 id="组合">组合</h3>
<p>可以在同一个 URL 中使用多个通配</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 组合使用</span></span><br><span class="line">curl -O http://example.com/&#123;web,mail&#125;-log[0-6].txt</span><br></pre></td></tr></table></figure>
<h3 id="输出变量">输出变量</h3>
<p>当要以不同的名称保存到文件中时, URL 中的每个通配都对应一个单独的变量, 可以通过 <code>#[num]</code> 来引用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将内容保存到子目录中</span></span><br><span class="line">curl http://example.com/&#123;web,mail&#125;-log[0-6].txt -o &quot;subdir/#1/log#2.txt&quot;</span><br></pre></td></tr></table></figure>
<h2 id="配置文件">配置文件</h2>
<p>curl 提供了 <strong>配置文件</strong> 功能, 允许将命令行选项写在文本文件中, 然后传递给 curl</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用-K或--config传递命令行选项文件</span></span><br><span class="line">curl -K cmdline.txt http://example.com</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 命令行选项文件</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置文件可以接受短选项和长选项, 就像在命令行上写的那样</span></span><br><span class="line">-v</span><br><span class="line">--location</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为了便于阅读, 它允许使用不带破折号的长选项</span></span><br><span class="line">location</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 命令行选项的参数必须与该选项处于同一行</span></span><br><span class="line">user-agent Everything-is-an-agent</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为了让配置文件看起来更像真正的配置文件, 它还允许在选项及其参数之间使用=或:</span></span><br><span class="line">user-agent = Everything-is-an-agent</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果想在配置文件中指定URL, 则必须使用--url或url, 不会像在命令行中那样不是选项的部分被视为URL</span></span><br><span class="line">url = http://example.com/</span><br></pre></td></tr></table></figure>
<h3 id="默认配置文件">默认配置文件</h3>
<p>当被调用时, curl 会检查是否存在默认配置文件, 如果存在, 则使用这个配置文件, 在类 Unit 系统上, 它会查找 <code>.curlrc</code> 文件, 在 Windows 系统上则查找 <code>_curlrc</code> 文件</p>
<p>curl 将按以下顺序查找默认配置文件:</p>
<ol type="1">
<li>先检查 <code>CURL_HOME</code> 和 <code>HOME</code> 环境变量的目录;</li>
<li>在类 Unit 系统上调用 <code>getpwuid()</code> 返回的目录, 在 Windows 系统上检查 <code>APPDATA</code> 和 <code>%USERPROFILE%\Application Data</code> 目录;</li>
<li>在 Windows 系统上查找 curl 可执行文件所在的目录</li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>cURL</tag>
      </tags>
  </entry>
  <entry>
    <title>AlertManager 入门</title>
    <url>/2021/07/19/alertmanager-001/</url>
    <content><![CDATA[<h1 id="入门">入门</h1>
<p><a href="https://prometheus.io/docs/alerting/latest/alertmanager/">AlertManager</a> 负责处理客户端应用程序 (如 Prometheus 服务等) 发送的告警事件, 根据配置定义的规则, 可以对告警事件做分组, 抑制, 静默等处理, 以及触发邮件, 第三方平台 (如 <a href="https://www.pagerduty.com/">PagerDuty</a>, <a href="https://www.atlassian.com/zh/software/opsgenie">Opsgenie</a> 等), 网络端口 (webhook), 微信等多种通知方式</p>
<p>AlertManager 的架构可分为以下 6 个模块:</p>
<ol type="1">
<li>API 模块用于接收客户端发送的告警请求, 如 Prometheus 服务发送的基于 http 协议的告警事件</li>
<li>Alert Provider 模块用于存储告警内容, 默认实现存储在本机内存中, 可以通过扩展其接口, 实现将告警信息持久化到数据库或云存储</li>
<li>Dispatcher 模块通过订阅方式从 Alert Provider 模块中获取新的告警, 并根据配置文件中的规则, 将告警信息按标签路由到不同的分组中, 以实现告警事件的分组处理</li>
<li>Notification Pipeline 模块是一个责任链模式的组件, 通过一系列逻辑 (如抑制, 静默, 去重等) 来优化告警的质量</li>
<li>Silence Provider 模块用于提供静默处理的实现, 静默规则可用来关闭部分告警的通知, 并通过 Cluster 以日志形式广播给集群中的节点, 避免告警事件在集群中重复出现</li>
<li>Notify Provider 模块用于提供通知的具体实现, 并会在本地记录日志</li>
</ol>
<figure>
<img data-src="https://cdn.jsdelivr.net/gh/prometheus/alertmanager@402564055b5bde93b0b742d25651402a6b5faf41/doc/arch.svg" alt="AlertManager 架构图" /><figcaption aria-hidden="true">AlertManager 架构图</figcaption>
</figure>
<h2 id="安装">安装</h2>
<p>AlertManager 提供了预编译的二进制文件 <a href="https://github.com/prometheus/alertmanager/releases">releases</a>, 也支持使用容器的方式部署 <a href="https://hub.docker.com/r/prom/alertmanager">prom/alertmanager</a>, 详见 <a href="https://github.com/prometheus/alertmanager#install">install</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: docker部署</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -d</span></span><br><span class="line">  -p 9093:9093</span><br><span class="line">  -v alertmanager.yml:/etc/alertmanager/alertmanager.yml</span><br><span class="line">  prom/alertmanager</span><br></pre></td></tr></table></figure>
<h3 id="配置">配置</h3>
<p>AlertManager 通过 YAML 文件来配置, 命令行可以配置不可变的系统参数, 而配置文件定义的限制规则用于通知路由和接收者, 详见 <a href="https://prometheus.io/docs/alerting/latest/configuration/">configuration</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件: alertmanager.yml</span></span><br><span class="line"><span class="attr">global:</span>  <span class="comment"># 全局配置</span></span><br><span class="line"><span class="comment"># The smarthost and SMTP sender used for mail notifications.</span></span><br><span class="line"></span><br><span class="line"><span class="attr">templates:</span>  <span class="comment"># 模板配置</span></span><br><span class="line"><span class="comment"># - &#x27;/etc/alertmanager/template/*.tmpl&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">route:</span>  <span class="comment"># 告警路由</span></span><br><span class="line">  <span class="attr">group_by:</span> [<span class="string">&#x27;job&#x27;</span>]</span><br><span class="line">  <span class="attr">group_wait:</span> <span class="string">30s</span></span><br><span class="line">  <span class="attr">group_interval:</span> <span class="string">5m</span></span><br><span class="line">  <span class="attr">repeat_interval:</span> <span class="string">1h</span></span><br><span class="line">  <span class="attr">receiver:</span> <span class="string">&#x27;webhook&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">receivers:</span>  <span class="comment"># 接收配置</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&#x27;webhook&#x27;</span></span><br><span class="line">  <span class="attr">webhook_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">url:</span> <span class="string">&#x27;http://127.0.0.1:5001/&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">inhibit_rules:</span>  <span class="comment"># 静默规则</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">source_match:</span></span><br><span class="line">      <span class="attr">severity:</span> <span class="string">&#x27;critical&#x27;</span></span><br><span class="line">    <span class="attr">target_match:</span></span><br><span class="line">      <span class="attr">severity:</span> <span class="string">&#x27;warning&#x27;</span></span><br><span class="line">    <span class="attr">equal:</span> [<span class="string">&#x27;instance&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h3 id="认证">认证</h3>
<p>AlertManager 支持 basic 认证和 TLS, 通过 <code>--web.config.file</code> 指定配置文件, 详见 <a href="https://prometheus.io/docs/alerting/latest/configuration/#configuration-file">authentication</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例: 认证配置</span></span><br><span class="line"><span class="attr">basic_auth_users:</span></span><br><span class="line">  <span class="attr">admin:</span> <span class="string">$2y$10$mDwo.lAisC94iLAyP81MCesa29IzH37oigHC/42V2pdJlUprsJPze</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>密码参考 <a href="https://github.com/prometheus/exporter-toolkit/blob/master/docs/web-configuration.md#about-bcrypt">bcrypt</a></p>
</blockquote>
<h3 id="启动">启动</h3>
<p>通过运行 <code>alertmanager</code> 执行文件启动服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 启动服务</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> alertmanager</span></span><br><span class="line">  --config.file=&quot;./alertmanager.yml&quot;    # 指定配置文件</span><br><span class="line">  --web.config.file=&quot;./web-config.yml&quot;  # 指定认证配置</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可通过-h选项查看帮助内容</span></span><br></pre></td></tr></table></figure>
<p>服务启动之后, 可以在控制台 <a href="http://127.0.0.1:9093/#/status">/status</a> 查看服务状态和配置信息</p>
<p>AlertManager 提供了一组管理 API, 以促进自动化和集成, 详见 <a href="https://prometheus.io/docs/alerting/latest/management_api/">management-api</a></p>
<ul>
<li><code>GET /-/healthy</code> 该端点用于显示服务的健康状态</li>
<li><code>GET /-/ready</code> 当服务准备好时, 该端点返回 <code>200</code> 状态码</li>
<li><code>POST /-/reload</code> 该端点用于触发重新加载服务的配置和规则文件</li>
</ul>
<h2 id="通知">通知</h2>
<p>根据 Prometheus 和 AlertManager 的告警配置, 会影响告警事件的通知逻辑和时间</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件: prometheus.yml</span></span><br><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="attr">scrape_interval:</span> <span class="string">1m</span></span><br><span class="line">  <span class="attr">scrape_timeout:</span> <span class="string">10s</span></span><br><span class="line">  <span class="attr">evaluation_interval:</span> <span class="string">1m</span></span><br><span class="line"><span class="attr">alerting:</span></span><br><span class="line">  <span class="attr">alertmanagers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">static_configs:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">targets:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9093</span></span><br><span class="line"><span class="attr">rule_files:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;rules/instance.alerts.yml&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件: alertmanager.yml</span></span><br><span class="line"><span class="attr">route:</span></span><br><span class="line">  <span class="attr">group_by:</span> [<span class="string">...</span>]</span><br><span class="line">  <span class="attr">group_wait:</span> <span class="string">30s</span></span><br><span class="line">  <span class="attr">group_interval:</span> <span class="string">5m</span></span><br><span class="line">  <span class="attr">repeat_interval:</span> <span class="string">4h</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件: rules/instance.alerts.yml</span></span><br><span class="line"><span class="attr">groups:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">instance_alerts</span></span><br><span class="line">    <span class="attr">rules:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">alert:</span> <span class="string">InstanceDown</span></span><br><span class="line">        <span class="attr">expr:</span> <span class="string">up</span> <span class="string">==</span> <span class="number">0</span></span><br><span class="line">        <span class="attr">for:</span> <span class="string">5m</span></span><br><span class="line">        <span class="attr">annotations:</span></span><br><span class="line">          <span class="attr">summary:</span> <span class="string">&quot;Instance <span class="template-variable">&#123;&#123; $labels.instance &#125;&#125;</span> down&quot;</span></span><br><span class="line">          <span class="attr">description:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; $labels.instance &#125;&#125;</span> of job <span class="template-variable">&#123;&#123; $labels.job &#125;&#125;</span> has been down for more than 5 minutes.&quot;</span></span><br></pre></td></tr></table></figure>
<ol type="1">
<li>Prometheus 以 <code>scrape_interval</code> 采样周期的间隔从客户端拉取时序, 根据时序的采样值, 以 <code>evaluation_interval</code> 评估周期的间隔对告警规则的表达式 <code>expr</code> 进行评估;</li>
<li>当采集对象出现问题时, Prometheus 会持续尝试拉取时序, 直到经过 <code>scrape_timeout</code> 超时时间后停止;</li>
<li>告警规则的表达式评估为真时, 告警状态切换到挂起 (Pending);</li>
<li>告警状态挂起的持续时间超过 <code>for</code> 指定的时间后, 告警状态切换为触发(Firing), 并将告警事件发送给 AlertManager;</li>
<li>下个评估周期若表达式评估仍为真, 且持续时间超过 <code>for</code> 指定的时间, 则持续发送告警事件给 AlertManager;</li>
<li>直到表达式评估为假, 告警状态切换为非活动(Inactive), 并发送通知 AlertManager 告警事件已解决;</li>
<li>AlertManager 接收到告警事件后, 先根据分组中的 <code>group_wait</code> 等待时间, 等待过后再发出告警通知;</li>
<li>同个分组的告警事件, 在等待时间内可能产生新的告警事件, 在前一个告警成功发出后, 经过 <code>group_interval</code> 周期时间后, 再发送新的告警通知;</li>
<li>如果分组里的告警一直没发生变化, 则在成功发出告警通知之后, 再经过 <code>repeat_interval</code> 重复周期的时间后, 重复发出相同的告警通知;</li>
<li>如果告警通知没有成功发出, 则等待 <code>group_interval</code> 周期时间后, 会再次尝试发出告警通知</li>
</ol>
<h3 id="分组">分组</h3>
<p>分组是指将性质类似的告警分成一个通知类, 不同分组之间互相独立, 互不影响, 分组可以聚合同类告警以减少告警数量, 通过精简的方式帮助分析问题, 详见 <a href="https://prometheus.io/docs/alerting/latest/alertmanager/#grouping">grouping</a></p>
<p>分组由配置文件中的路由树节点配置, 可按匹配规则细分成多个子节点, 子节点未配置的可选参数将从父节点继承配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例: 分组配置</span></span><br><span class="line"><span class="attr">route:</span></span><br><span class="line">  <span class="attr">group_by:</span> [<span class="string">...</span>]</span><br><span class="line">  <span class="attr">group_wait:</span> <span class="string">30s</span></span><br><span class="line">  <span class="attr">group_interval:</span> <span class="string">5m</span></span><br><span class="line">  <span class="attr">repeat_interval:</span> <span class="string">4h</span></span><br><span class="line">  <span class="attr">receiver:</span> <span class="string">&#x27;webhook&#x27;</span>   <span class="comment"># 该分组的接收配置, 对应receivers节点配置</span></span><br><span class="line">  <span class="attr">routes:</span>               <span class="comment"># 子分组</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">matchers:</span>           <span class="comment"># 匹配规则</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">application=&quot;myapp&quot;</span></span><br><span class="line">    <span class="attr">receiver:</span> <span class="string">&#x27;email&#x27;</span>   <span class="comment"># 覆盖父节点的接收配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此处配置myapp应用告警使用email方式, 其它使用webhook方式</span></span><br></pre></td></tr></table></figure>
<p><a href="https://www.prometheus.io/webtools/alerting/routing-tree-editor/">RoutingTreeEditor</a> 是一个在线支持可视化的路由树编辑器, 通过生成直观的图例, 确保开发人员编写正确的路由分组</p>
<h3 id="抑制">抑制</h3>
<p>抑制是指当源告警通知已经发出时, 停止再发送目标告警的通知, 抑制主要用于消除冗余的告警, 详见 <a href="https://prometheus.io/docs/alerting/latest/alertmanager/#inhibition">inhibition</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例: 抑制配置</span></span><br><span class="line"><span class="attr">inhibit_rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">source_matchers:</span>  <span class="comment"># 匹配源告警</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">job=&#x27;node&#x27;</span></span><br><span class="line">  <span class="attr">target_matchers:</span>  <span class="comment"># 匹配目标告警</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">application=&#x27;myapp&#x27;</span></span><br><span class="line">  <span class="attr">equal:</span> []         <span class="comment"># 配置需要在源和目标中必须具有相等值的标签</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此处配置当node主机发出告警通知时, 不再发出myapp应用的告警通知</span></span><br></pre></td></tr></table></figure>
<h3 id="静默">静默</h3>
<p>静默通过配置静默表达式, 使匹配的告警事件不再发送告警通知, 管理员可以在控制台 <a href="http://127.0.0.1:9093/#/silences">/silences</a> 中添加静默表达式, 通常用于主机维护时或夜间运行批处理作业等场景, 添加临时的静默规则可以防止产生不必要的告警, 详见 <a href="https://prometheus.io/docs/alerting/latest/alertmanager/#silences">silences</a></p>
<p>静默提供了一种简单的机制, 可以在给定的时间内忽略可存在的告警, 静默基于 <code>matchers</code> 配置实现, 类似于路由树, 对接收的告警事件进行检查, 判断它们是否和活跃的静默表达式匹配, 如果匹配成功, 就不会将这些告警发送给接收端</p>
<h2 id="amtool">AMTool</h2>
<p><a href="https://github.com/prometheus/alertmanager/tree/main/cmd/amtool">AMTool</a> 是用于与 AlertManager 架构中的 API 模块进行交互的命令行工具, 它可以使用 AlertManager 提供的查询语法, 进行告警事件的查询, 也支持管理服务的静默表达式</p>
<h2 id="集群">集群</h2>
<p>为了避免单节点问题, 通常会对多个 AlertManager 进行集群部署, AlertManager 之间通过 Gossip 机制进行集群成员管理和成员故障检测, 以确保在多个 AlertManager 分别接收到相同告警事件的情况下, 只有一个告警通知被发送给接收端, 要创建 AlertManager 的高可用集群, 可使用 <code>--cluster.*</code> 标志进行配置, 详见 <a href="https://github.com/prometheus/alertmanager/blob/main/README.md#high-availability">high-availability</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 启动服务</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -d -p 9094:9093</span></span><br><span class="line">  -v alertmanager.yml:/etc/alertmanager/alertmanager.yml</span><br><span class="line">  prom/alertmanager</span><br><span class="line">  --config.file=/etc/alertmanager/alertmanager.yml --storage.path=/alertmanager</span><br><span class="line">  --cluster.listen-address=&quot;172.17.0.1:9094&quot;</span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -d -p 9095:9093</span></span><br><span class="line">  -v alertmanager.yml:/etc/alertmanager/alertmanager.yml</span><br><span class="line">  prom/alertmanager</span><br><span class="line">  --config.file=/etc/alertmanager/alertmanager.yml --storage.path=/alertmanager</span><br><span class="line">  --cluster.listen-address=&quot;172.17.0.2:9095&quot; --cluster.peer=&quot;172.17.0.1:9094&quot;</span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -d -p 9096:9093</span></span><br><span class="line">  -v alertmanager.yml:/etc/alertmanager/alertmanager.yml</span><br><span class="line">  prom/alertmanager</span><br><span class="line">  --config.file=/etc/alertmanager/alertmanager.yml --storage.path=/alertmanager</span><br><span class="line">  --cluster.listen-address=&quot;172.17.0.3:9096&quot; --cluster.peer=&quot;172.17.0.1:9094&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件: prometheus.yml</span></span><br><span class="line"><span class="attr">alerting:</span></span><br><span class="line">  <span class="attr">alertmanagers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">static_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">targets:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">172.17</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9094</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">172.17</span><span class="number">.0</span><span class="number">.2</span><span class="string">:9095</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">172.17</span><span class="number">.0</span><span class="number">.3</span><span class="string">:9096</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>AlertManager</tag>
        <tag>Prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>cURL 进阶</title>
    <url>/2020/05/19/curl%20002/</url>
    <content><![CDATA[<h1 id="进阶">进阶</h1>
<p>curl 很少会自己决定做什么, 它试图在最大程度上让开发人员做自己想做的事, 这是一种设计选择, 它允许通过传递选项的方式, 调整 curl 与服务器的交互</p>
<h2 id="调试">调试</h2>
<p>当执行 curl 命令没有返回所期望的数据时, 可以通过选项来输出更多详细的信息</p>
<h3 id="详细模式">详细模式</h3>
<p>使用 <code>-v</code> 或 <code>--verbose</code> 选项来启用 <strong>详细模式</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line">curl -v http://example.com</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行结果</span></span><br><span class="line">* Rebuilt URL to: http://example.com/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用了curl认为不完整的URL, 于是它在尾部添加了斜杠</span></span><br><span class="line">*   Trying 93.184.216.34...</span><br><span class="line"><span class="meta">#</span><span class="bash"> 域名解析为IP地址, 尝试连接到这个IP地址</span></span><br><span class="line">* TCP_NODELAY set</span><br><span class="line">* Connected to example.com (93.184.216.34) port 80 (#0)</span><br><span class="line"><span class="meta">#</span><span class="bash"> curl连接到了目标网站, 以及它连接到的端口上, <span class="comment">#0是curl为这个连接分配的内部数字</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> GET / HTTP/1.1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Host: example.com</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> User-Agent: curl/7.55.1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Accept: */*</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># HTTP请求</span></span></span><br><span class="line">&lt; HTTP/1.1 200 OK</span><br><span class="line">&lt; Age: 509341</span><br><span class="line">&lt; Cache-Control: max-age=604800</span><br><span class="line">&lt; Content-Type: text/html; charset=UTF-8</span><br><span class="line">&lt; Date: Sun, 17 May 2020 14:19:55 GMT</span><br><span class="line">&lt; Etag: &quot;3147526947+ident&quot;</span><br><span class="line">&lt; Expires: Sun, 24 May 2020 14:19:55 GMT</span><br><span class="line">&lt; Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT</span><br><span class="line">&lt; Server: ECS (sjc/4FB8)</span><br><span class="line">&lt; Vary: Accept-Encoding</span><br><span class="line">&lt; X-Cache: HIT</span><br><span class="line">&lt; Content-Length: 1256</span><br><span class="line">&lt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> HTTP响应标头</span></span><br><span class="line">(...省略网页数据...)</span><br><span class="line"><span class="meta">#</span><span class="bash"> HTTP响应正文</span></span><br><span class="line">* Connection #0 to host example.com left intact</span><br></pre></td></tr></table></figure>
<h3 id="跟踪信息">跟踪信息</h3>
<p>当想要保存包括实际传输数据在内的完整信息时, curl 提供了两个选项</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将完整的跟踪信息保存到指定文件(dump)中, 发送和接收的每个字节都以十六进制的数字显示</span></span><br><span class="line">curl --trace dump http://example.com/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 发送和接收的每个字节都以ASCII码显示</span></span><br><span class="line">curl --trace-ascii dump http://example.com/</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用--trace-time为输出信息加上高精度的时间戳</span></span><br><span class="line">curl -trace --trace-time dump http://example.com/</span><br></pre></td></tr></table></figure>
<h3 id="打印信息">打印信息</h3>
<p>curl 提供了 <code>--write-out</code> 选项在传输任务完成后打印一些信息, 并且它提供了大量可添加到输出内容中的变量, 这些变量包含了与传输相关的信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line">curl -w &quot;Type: %&#123;content_type&#125;\nCode: %&#123;response_code&#125;\n&quot; http://example.com/ </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出结果</span></span><br><span class="line">(...省略网页数据...)</span><br><span class="line">Type: text/html; charset=UTF-8</span><br><span class="line">Code: 200</span><br></pre></td></tr></table></figure>
<blockquote>
<p>选项的可用变量见文档 <a href="https://curl.haxx.se/docs/manpage.html#-w">NOTE</a></p>
</blockquote>
<h3 id="静默模式">静默模式</h3>
<p>与详细模式相反的是 <strong>静默模式</strong>, 可以使用 <code>-s</code> 或 <code>--silent</code> 选项让 curl 关闭进度指示器, 而且不会在发生错误时输出任何错误信息</p>
<p>启用静默模式后, 可以通过使用 <code>-S</code> 或 <code>--show-error</code> 来要求它在发生错误时输出错误信息</p>
<h2 id="持久连接">持久连接</h2>
<p>在建立 TCP 连接时, curl 将保留旧连接一段时间, 如果下一次要连接到同一主机, 那么就可以重用相同的连接, 从而节省大量时间, 称之为 <strong>持久连接</strong>, 不过 curl 命令行工具只能在运行期间保持连接处于活跃状态, 因此只要它退出, 就会关闭所有已打开的连接, 这种活跃连接池称为 <strong>连接缓存</strong></p>
<blockquote>
<p>如果需要针对同一主机或相同的 URL 执行 N 次传输或操作, 那么可以考虑使用尽可能少的 curl 命令行来提速, 而不是每次使用一个 URL 并重复调用 curl</p>
</blockquote>
<h3 id="存储指令">存储指令</h3>
<p>curl 默认下载 URL 指定的资源, 将输出内容打印到终端上</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通过-o选项指定一个特定的文件名来保存下载的内容</span></span><br><span class="line">curl http://example.com/file.html -o file.html</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通过-O选项从URL中提取文件名部分作为本地文件名</span></span><br><span class="line">curl http://example.com/file.html -O</span><br></pre></td></tr></table></figure>
<p>HTTP 服务器可以选择在响应消息中提供 <code>Content-Disposition</code> 标头, 这个标头可能包含服务器建议的文件名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用-J或--remote-header-name选项使用标头建议的文件名</span></span><br><span class="line">curl http://example.com/file.html -J</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 只有当响应消息中包含有效的Content-Dispositon标头时, 它才会使用这个建议的文件名</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 它只会使用建议文件名的最右边部分, 因此服务器建议的其他路径或目录都会被忽略</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果服务器恰好提供了与本地文件相同的文件名, 那么将覆盖当前目录中已有的本地文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> curl不会对文件名进行编码, 因此可能得到一个URL编码的文件名</span></span><br></pre></td></tr></table></figure>
<p>存储指令的读取和处理顺序与下载的 URL 的顺序相同, 因此以下写法是等效的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例1</span></span><br><span class="line">curl -o 1.txt -o 2.txt http://example.com/1 http://example.com/2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例2</span></span><br><span class="line">curl -o 1.txt http://example.com/1 -o 2.txt http://example.com/2</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -O只用于单个下载, 如果要下载多个URL, 则需要使用多个-O</span></span><br><span class="line">curl -O -O http://example.com/1 http://example.com/2</span><br><span class="line"><span class="meta">#</span><span class="bash"> curl提供了--remote-name-all选项让所有URL使用自己的文件名</span></span><br><span class="line">curl --remote-name-all http://example.com/1 http://example.com/2</span><br></pre></td></tr></table></figure>
<h3 id="间隔符">间隔符</h3>
<p>curl 提供了 <code>-:</code> 或 <code>--next</code> 选项, 用于在一组选项和 URL 之间插入间隔, 当命令行解析器遇到 <code>--next</code> 选项时, 它会将后面的选项应用于下一组 URL</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 分隔符</span></span><br><span class="line">curl --location http://example.com/1 --next</span><br><span class="line">     --data sendthis http://example.com/2 --next</span><br><span class="line">     --head http://example.com/3</span><br></pre></td></tr></table></figure>
<h3 id="退出码">退出码</h3>
<p>curl 会在处理完最后一个 URL 后返回一个退出码, 一切正常则返回 <code>0</code>, 如果想让 curl 在第一次出现错误时就退出, 可以使用 <code>--fail-early</code> 选项</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用退出码的脚本示例</span></span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line">curl http://example.com</span><br><span class="line">res=$?</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> <span class="string">&quot;<span class="variable">$res</span>&quot;</span> != <span class="string">&quot;0&quot;</span>; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;the curl command failed with: <span class="variable">$res</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>可用的退出码见文档 <a href="https://curl.haxx.se/docs/manpage.html#1">EXIT CODES</a></p>
<p>以非零状态码退出时, curl 还会输出一个错误消息, 这个错误消息可能会包含一些额外的信息, 因此, 相同的错误码可能会与不同的错误消息一起出现</p>
</blockquote>
<h2 id="连接">连接</h2>
<p>在 curl 中使用的大多数协议都是基于 TCP 的, 连接意味着需要进行 TCP 协议握手</p>
<h3 id="主机">主机</h3>
<p>通常同一个 HTTP 服务器实例会有多个名字, 自定义的 <code>Host:</code> 标头可以让服务器返回目标站点的内容, 即使没有使用目标站点的主机名进行连接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 请求本地运行www.example.com的实例</span></span><br><span class="line">curl -H &quot;Host: www.example.com&quot; http://localhost/</span><br></pre></td></tr></table></figure>
<p>可以通过 <code>--resolve</code> 选项将 IP 地址插入 DNS 缓存中, 以便解析得到自己想要的地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 请求www.example.com重定向到本地</span></span><br><span class="line">curl --resolve www.example.com:80:127.0.0.1 http://www.example.com</span><br></pre></td></tr></table></figure>
<p>可以通过 <code>--connect-to</code> 选项为 curl 指定特定主机名和端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 请求www.example.com重定向到example.com</span></span><br><span class="line">curl --connect-to www.example.com:80:example.com:80 http://www.example.com</span><br></pre></td></tr></table></figure>
<h3 id="代理">代理</h3>
<p>代理是代表客户端执行某项操作的机器或软件, curl 支持几种不同类型的代理, curl 使用 <code>-x</code> 或 <code>--proxy</code> 选项指定代理, 默认代理类型是 HTTP, 端口 <code>3128</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> HTTP代理</span></span><br><span class="line">curl -x 127.0.0.1:8080 http://example.com/</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> SOCKS5代理</span></span><br><span class="line">curl -x socks5://proxy.example.com http://example.com/</span><br><span class="line">curl --socks5 proxy.example.com http://example.com/</span><br></pre></td></tr></table></figure>
<p>可以通过设置 <code>[SCHEME]_PROXY</code> 变量来指定代理, curl 会在运行前检查这些特殊的环境变量, 然后根据这些变量决定是否使用代理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> HTTP代理环境变量</span></span><br><span class="line">HTTP_PROXY=http://proxy.example.com:80</span><br></pre></td></tr></table></figure>
<p>可以通过单个变量 <code>ALL_PROXY</code> 来设置所有的协议, 如果存在某个特定的协议变量, 则优先使用这个变量</p>
<p>使用环境变量设置代理时, 可以使用 <code>NO_PROXY</code> 变量将无须使用代理的主机名排除在外, 使用逗号分隔多个主机名, 也可以使用单个星号 <code>*</code> 以匹配所有主机</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> --noproxy选项与NO_PROXY变量的作用相同</span></span><br><span class="line">curl --noproxy * http://example.com/</span><br></pre></td></tr></table></figure>
<h3 id="超时">超时</h3>
<p>curl 的大多数操作默认没有设置超时</p>
<p>可以用 <code>-m</code> 或 <code>--max-time</code> 选项设置 curl 最长有多少时间可用, 以秒为单位</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 允许的最长时间</span></span><br><span class="line">curl --max-time 5.5 http://example.com</span><br></pre></td></tr></table></figure>
<p>可以用 <code>--connect-timeout</code> 限制 curl 连接主机所花费的时间, 以秒为单位</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 允许的最长连接时间</span></span><br><span class="line">curl --connect-time 2.5 http://example.com</span><br></pre></td></tr></table></figure>
<p>作为固定超时时间的替代方案, 可以设置如果传输速率低于某个特定值, 并且在某个时间段内一直低于这个值, 那么就放弃传输</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如果15秒内的传输速率低于1000字节/秒则停止传输</span></span><br><span class="line">curl --speed-time 15 --speed-limit 1000 http://example.com</span><br></pre></td></tr></table></figure>
<p>curl 默认启用 TCP keepalive, 可以使用 <code>--keepalive-time</code> 来指定发送探测的频率, 默认为 <code>60</code> 秒</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 指定探测频率</span></span><br><span class="line">curl --keepalive-time 30 http://example.com</span><br><span class="line"><span class="meta">#</span><span class="bash"> 禁用keepalive</span></span><br><span class="line">curl --no-keepalive http://example.com</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>cURL</tag>
      </tags>
  </entry>
  <entry>
    <title>cURL 协议</title>
    <url>/2020/05/21/curl%20003/</url>
    <content><![CDATA[<h1 id="协议">协议</h1>
<h2 id="http">HTTP</h2>
<p>curl 默认使用 <code>HTTP/1.1</code> 连接 HTTP 服务器, 当 HTTP 客户端被指定一个 URL, URL 将被分成多个部分, 并用于向服务器发起的请求中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例</span></span><br><span class="line">curl http://example.com/</span><br></pre></td></tr></table></figure>
<p>如果路径中包含 <code>/../</code> 或 <code>/./</code> 这样的字符串, curl 会在将路径发送到服务器前自动压缩它们, 这些字符串的含义与本地文件系统中的路径含义是一样的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 可以使用--path-as-is选项防止curl压缩路径</span></span><br><span class="line">curl --path-as-is http://example.com/./</span><br></pre></td></tr></table></figure>
<h3 id="认证">认证</h3>
<p>每个 HTTP 请求都可以进行身份验证, 需要身份验证的服务器会发回 <code>401</code> 响应码和 <code>WWW-Authenticate:</code> 标头, 这个标头列出了服务器支持的所有身份验证方法, 需要身份验证的 HTTP 代理会发回 <code>407</code> 响应码和 <code>WWW-Authenticate:</code> 标头, 这个标头列出了代理支持的所有身份验证方法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> curl默认使用basic认证</span></span><br><span class="line">curl --user username:password http://example.com/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用--basic选项明确指定使用basic认证</span></span><br><span class="line">curl --basic --user username:password http://example.com/</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> curl也支持digest, negotiate, ntlm等认证</span></span><br><span class="line">curl --digest --user username:password http://example.com/</span><br><span class="line">curl --negotiate --user username:password http://example.com/</span><br><span class="line">curl --ntlm --user username:password http://example.com/</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通过--anyauth选项确认服务器是否真的需要身份验证, 它会自动使用curl所知道的最安全的身份验证方法</span></span><br><span class="line">curl --anyauth --user username:password http://example.com/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 同样适用于可能需要身份验证的HTTP代理</span></span><br><span class="line">curl --proxy-anyauth -proxy--user username:password http://example.com/ --proxy http://proxy.example.com/</span><br></pre></td></tr></table></figure>
<h3 id="请求">请求</h3>
<h4 id="method">method</h4>
<p>HTTP 请求都包含了一个方法, 有时也被称为动词, 具体使用哪个方法取决于使用的选项, 默认方法是 <code>GET</code></p>
<table>
<colgroup>
<col style="width: 31%" />
<col style="width: 6%" />
<col style="width: 62%" />
</colgroup>
<thead>
<tr class="header">
<th>选项</th>
<th>方法</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-G --get</code></td>
<td><code>GET</code></td>
<td><code>curl -G 'param=name' http://example.com/</code></td>
</tr>
<tr class="even">
<td><code>-d --data</code><br><code>--data-binary</code></td>
<td><code>POST</code></td>
<td><code>curl -d 'param=name' http://example.com/</code><br><code>curl --data-binary @filename http://example.com/</code></td>
</tr>
<tr class="odd">
<td><code>-T --upload-file</code></td>
<td><code>PUT</code></td>
<td><code>curl -T @filename http://example.com/</code></td>
</tr>
<tr class="even">
<td><code>-I --head</code></td>
<td><code>HEAD</code></td>
<td><code>curl -I http://example.com/</code></td>
</tr>
</tbody>
</table>
<h4 id="header">header</h4>
<p>在 HTTP 请求中, 通常会有很多请求标头, 它们是一组键值对, curl 默认会在请求中添加一些标头, 具体取决于用户要求 curl 执行哪些操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用-H或--header选项让curl使用标头</span></span><br><span class="line">curl -H &quot;Host: test.example&quot; http://example.com/</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用-e或--referer选项设置referer标头</span></span><br><span class="line">curl --referer http://from.example.com http://example.com/</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用-A或--user-agent选项设置User-Agent标头, 这个标头的默认值为 curl/[version]</span></span><br><span class="line">curl --user-agent &quot;Mozilla/5.0 (X11; Linux x86_64; rv:58.0) Gecko/20100101 Firefox/58.0&quot; http://example.com/</span><br></pre></td></tr></table></figure>
<h4 id="cookie">cookie</h4>
<p>HTTP cookie 是存储在客户端的键值对, 在后续请求中, 它们被发回服务器, 用于保持请求间的状态, curl 默认情况下不会使用 cookie, 需要打开 cookie 引擎才能让 curl 跟踪它接收到的 cookie, 然后在后续的请求中发送它们</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> curl从不存在的文件中读取cookie, 那么它会打开引擎, 但内部的cookie存储是空的curl -b non-existing http://example.com/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> curl从指定文件读取初始cookiecurl -b cookies.txt http://example.com/<span class="comment"># 选项-b只是从文件中读取cookie, 如果服务器更新了响应的cookie, 那么curl只会更新内存的cookie存储, 并在退出时将它们全部丢弃</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> curl将cookie写入文件curl -c cookies.txt http://example.com/<span class="comment"># 选项-c只会在curl退出时更新cookie, 而不是生命周期内</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通过-j或--junk-session-cookies选项让curl开始新的cookie会话curl -j -b cookies.txt http://example.com/</span></span><br></pre></td></tr></table></figure>
<h3 id="响应">响应</h3>
<p>当 HTTP 客户端与服务器进行 HTTP 对话时, 服务器将返回 HTTP 响应消息, HTTP 响应消息包含响应码, 用来告诉客户端它是如何处理请求的一种方式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 请求失败示例curl http://www.server.com/<span class="comment"># 服务器未返回响应时, curl显示错误码和错误消息curl: (52) Empty reply from server</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 请求成功示例curl -v http://example.com/<span class="comment"># 响应体&lt; HTTP/1.1 200 OK&lt; Age: 546477&lt; Cache-Control: max-age=604800&lt; Content-Type: text/html; charset=UTF-8&lt; Date: Sun, 24 May 2020 22:54:18 GMT&lt; Etag: &quot;3147526947+ident&quot;&lt; Expires: Sun, 31 May 2020 22:54:18 GMT&lt; Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT&lt; Server: ECS (sjc/4E68)&lt; Vary: Accept-Encoding&lt; X-Cache: HIT&lt; Content-Length: 1256&lt;(...省略网页数据...)# 即使响应码表明无法获取所请求的文档, curl也不会将其视为错误, 只要HTTP发送和接收成功, curl都将其视为正常情况</span></span></span><br></pre></td></tr></table></figure>
<p>HTTP 响应消息能够以压缩的格式进行传输, 服务器通常会在响应中包含 <code>Content-Encoding: gzip</code> 标头, 以告诉客户端内容经过了压缩</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通过--compressed选项让curl请求压缩数据, 并在接收gzip压缩的内容后自动对其进行解压curl --compressed http://example.com/</span></span><br></pre></td></tr></table></figure>
<p>curl 可以直接传递收到的数据, 不对其进行解码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通过--raw选项让curl直接传递数据curl --raw http://example.com/</span></span><br></pre></td></tr></table></figure>
<h2 id="ftp">FTP</h2>
<p><strong>FTP</strong> 协议是一种命令和响应协议, 客户端发送命令, 服务器做出响应, 使用 <code>-v</code> 选项可以看到传输过程涉及的所有命令和响应</p>
<p>当 FTP 客户端开始传输数据时, 它会向服务器指定要使用哪种 <strong>传输模式</strong>, curl 支持的两种传输模式是 <code>ASCII</code> 和 <code>BINARY</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> curl默认使用BINARY模式</span></span><br><span class="line">curl ftp://example.com/foobar.txt</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用-B或--use-ascii选项切换到ASCII模式</span></span><br><span class="line">curl --use-ascii ftp://example.com/foobar.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用;<span class="built_in">type</span>=A作为URL的结尾来切换ASCII模式</span></span><br><span class="line">curl ftp://example.com/foobar.txt;type=A</span><br></pre></td></tr></table></figure>
<p>有些 FTP 允许匿名访问, 使用 curl 进行 FTP 传输但没有指定用户名的情况下, 它将使用用户名 <code>anonymous</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 用户名和密码验证</span></span><br><span class="line">curl --user username:password ftp://example.com/foobar.txt</span><br><span class="line">curl ftp://username:password@example.com/foobar.txt</span><br></pre></td></tr></table></figure>
<h3 id="目录列表">目录列表</h3>
<p>可以用 curl 列出远程 FTP 目录列表</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 默认使用FTP命令LIST列出目录</span></span><br><span class="line">curl -v ftp://example.com/directory/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 命令和响应(简化)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> LIST</span></span><br><span class="line">&lt; 150 Here comes the directory listing.</span><br><span class="line">* Maxdownload = -1</span><br><span class="line">drwxrwxrwx    1 1000     1000         4096 Jan 11  2018 directory1</span><br><span class="line">drwxrwxrwx    1 1000     1000         4096 Jan 11  2018 directory2</span><br><span class="line">drwxrwxrwx    1 1000     1000         4096 Jan 11  2018 directory3</span><br><span class="line"><span class="meta">#</span><span class="bash"> LIST命令返回的目录结构没有标准的格式, 返回的列表通常是可以被人类理解的, 但不同的服务器返回的列表结构稍有不同</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用FTP命令NLST列出目录</span></span><br><span class="line">curl -v --list-only ftp://example.com/directory/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 命令和响应(简化)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> NLST</span></span><br><span class="line">&lt; 150 Here comes the directory listing.</span><br><span class="line">* Maxdownload = -1</span><br><span class="line">directory1</span><br><span class="line">directory2</span><br><span class="line">directory3</span><br><span class="line"><span class="meta">#</span><span class="bash"> NLST列出目录中的所有内容并避免出现特殊格式</span></span><br></pre></td></tr></table></figure>
<h3 id="目标文件">目标文件</h3>
<p>使用 FTP 命令遍历远程文件系统时, curl 可以通过几种不同的方式来访问目标文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> multicwd</span></span><br><span class="line">curl -v --ftp-method multicwd ftp://example.com/one/two/three/file.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 命令和响应(简化)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> CWD one</span></span><br><span class="line">* ftp_perform ends with SECONDARY: 0</span><br><span class="line">&lt; 250 Directory successfully changed.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> CWD two</span></span><br><span class="line">&lt; 250 Directory successfully changed.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> CWD three</span></span><br><span class="line">&lt; 250 Directory successfully changed.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> RETR file.txt</span></span><br><span class="line">&lt; 150 Opening BINARY mode data connection for file.txt (1 bytes).</span><br><span class="line"><span class="meta">#</span><span class="bash"> multicwd方式顺着文件树结构的每个目录执行一次更改目录命令CWD</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> nocwd</span></span><br><span class="line">curl -v --ftp-method nocwd ftp://example.com/one/two/three/file.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 命令和响应(简化)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> RETR one/two/three/file.txt</span></span><br><span class="line">&lt; 150 Opening BINARY mode data connection for one/two/three/file.txt (1 bytes).</span><br><span class="line"><span class="meta">#</span><span class="bash"> nocwd方式不更改目录, 有时在服务器上使用会有问题, 它并不符合标准</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> singlecwd</span></span><br><span class="line">curl -v --ftp-method singlecwd ftp://example.com/one/two/three/file.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 命令和响应(简化)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> CWD one/two/three</span></span><br><span class="line">* ftp_perform ends with SECONDARY: 0</span><br><span class="line">&lt; 250 Directory successfully changed.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> RETR file.txt</span></span><br><span class="line">&lt; 150 Opening BINARY mode data connection for file.txt (1 bytes).</span><br><span class="line"><span class="meta">#</span><span class="bash"> singlecwd方式只会向目标目录发出一个CWD命令</span></span><br></pre></td></tr></table></figure>
<h3 id="上传文件">上传文件</h3>
<p>上传文件到 FTP 服务器, 需要在 URL 中指定整个目标文件的路径和名字</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用-T或--upload-file选项指定要上传的本地文件</span></span><br><span class="line">curl -T localfile ftp://example.com/remotefile</span><br><span class="line"><span class="meta">#</span><span class="bash"> 目标URL以斜杠结尾时, curl会自动将本地的文件名追加到URL中作为远程文件名</span></span><br><span class="line">curl -T localfile ftp://example.com/</span><br></pre></td></tr></table></figure>
<p>curl 支持 <code>-T</code> 参数通配, 这样就可以上传一系列文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通配</span></span><br><span class="line">curl -T image[1-99].jpg ftp://example.com/images/</span><br><span class="line">curl -T &#x27;&#123;one,two,three&#125;.jpg&#x27; ftp://example.com/images/</span><br></pre></td></tr></table></figure>
<h2 id="sftp">SFTP</h2>
<p><strong>SFTP</strong> 建立在 SSH 之上的协议, 使用第三方库 libssh2 来构建 curl, 那么它就可以支持 SFTP 协议</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> SFTP的使用与FTP差不多</span></span><br><span class="line">curl sftp://example.com/directory/</span><br><span class="line">curl sftp://example.com/file</span><br></pre></td></tr></table></figure>
<p>在使用 SFTP 请求文件时, 给定的文件路径被视为远程服务器上的绝对路径, 除非特别指定要使用用户主目录的相对路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用/~/来指定用户主目录的相对路径</span></span><br><span class="line">curl sftp://example.com/~/file</span><br></pre></td></tr></table></figure>
<h2 id="pop3">POP3</h2>
<p><strong>POP3</strong> 是 Post Office Protocol 3 的简称, 即邮局协议的第 3 个版本, 它规定怎样将个人计算机连接到邮件服务器和下载电子邮件的电子协议, POP3 允许用户从服务器上把邮件存储到本地主机上, 同时删除保存在邮件服务器上的邮件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出消息编号和大小</span></span><br><span class="line">curl pop3://mail.example.com/</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载消息</span></span><br><span class="line">curl pop3://mail.example.com/1</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除消息</span></span><br><span class="line">curl --request DELE pop3://mail.example.com/1</span><br></pre></td></tr></table></figure>
<h2 id="smtp">SMTP</h2>
<p><strong>SMTP</strong> 是简单邮件传输协议 (Simple Mail Transfer Protocol) 的简写, curl 支持将数据发送到 SMTP 服务器, 可以通过一系列命令选项将电子邮件发送给指定的一组收件人</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 发送电子邮件</span></span><br><span class="line">curl smtp://mail.example.com</span><br><span class="line">    --mail-from myself@example.com    # 发件人的邮件地址</span><br><span class="line">    --mail-rcpt receiver@example.com  # 收件人的邮件地址, 可以多次使用这个选项指定多个收件人</span><br><span class="line">    --upload-file email.txt           # 要发送的电子邮件数据</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例email.txt</span></span><br><span class="line">From: John Smith &lt;john@example.com&gt;</span><br><span class="line">To: Joe Smith &lt;smith@example.com&gt;</span><br><span class="line">Subject: an example.com example email Date: Mon, 7 Nov 2016 08:45:16 Dear Joe, Welcome to this example email. What a lovely day.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>电子邮件数据是一个文本文件, 由一组标头和正文组成, 格式见 <a href="https://www.rfc-editor.org/rfc/rfc5322.html">RFC 5322</a></p>
</blockquote>
<h2 id="tls">TLS</h2>
<p><strong>TLS</strong> 是传输层 (Transport Layer Security) 的简写, 是 TCP 之上的一个加密安全层, 基于强大的公钥加密和数字签名实现数据防篡改, 并确保服务器的可靠性</p>
<p>curl 支持很多协议的 TLS 版本, 如果服务器端也支持, 则可以在 curl 中使用这些协议的 TLS 版本:</p>
<ul>
<li>如果在 URL 中明确指定了协议的 TLS 版本, curl 将尝试从开始就建立 TLS 连接;</li>
<li>如果指定了非 TLS 版本, 可以使用选项将连接升级到基于 TLS 的连接</li>
</ul>
<table>
<thead>
<tr class="header">
<th>明文</th>
<th>TLS 版本</th>
<th>使用选项</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>HTTP</td>
<td>HTTPS</td>
<td>N</td>
</tr>
<tr class="even">
<td>LDAP</td>
<td>LDAPS</td>
<td>N</td>
</tr>
<tr class="odd">
<td>FTP</td>
<td>FTPS</td>
<td>Y</td>
</tr>
<tr class="even">
<td>POP3</td>
<td>POP3S</td>
<td>Y</td>
</tr>
<tr class="odd">
<td>IMAP</td>
<td>IMAPS</td>
<td>Y</td>
</tr>
<tr class="even">
<td>SMTP</td>
<td>SMTPS</td>
<td>Y</td>
</tr>
</tbody>
</table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用TLS进行连接, 如果TLS协商失败, curl将返回错误</span></span><br><span class="line">curl https://example.com/</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用--ssl选项让curl尝试将连接升级到TLS, 如果失败, 它将继续使用明文协议</span></span><br><span class="line">curl --ssl ftp://example.com/</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用--ssl-reqd选项让curl一定使用TLS连接, 如果无法进行TLS协商, 传输就会失败</span></span><br><span class="line">curl --ssl-reqd ftp://example.com/</span><br></pre></td></tr></table></figure>
<h3 id="ca-证书">CA 证书</h3>
<p>为了确认是否与正确的 TLS 服务器通信, curl 会使用一组存储在本地的 CA 证书来验证服务器的证书签名</p>
<p>在 Windows 上, curl 将按以下顺序在这些目录中搜索名为 <code>curl-ca-bundle.crt</code> 的 CA 证书文件:</p>
<ol type="1">
<li>应用的目录;</li>
<li>当前工作目录;</li>
<li>Windows 系统目录 (如 <code>C:\Windows\System32</code>);</li>
<li>Windows 目录 (如 <code>C:\Windows</code>);</li>
<li><code>%PATH%</code> 中的所有目录</li>
</ol>
<p>可以用 <code>--cacert</code> 选项指定要在 TLS 握手中使用的 CA 证书 (需要采用 <code>PEM</code> 格式) 的目录, 也可以通过环境变量 <code>CURL_CA_BUNDLE</code> 设置 CA 存储的完整路径</p>
<h3 id="客户端证书">客户端证书</h3>
<p>TLS 客户端证书是客户端以加密的方式向服务器证明自己就是真正对等方的一种方式, 在命令行中指定证书和相应的密钥, 然后在与服务器进行 TLS 握手时传递它们</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> curl提供选项指定客户端证书或密钥文件</span></span><br><span class="line">curl https://example.com/</span><br><span class="line">    --cert cert:password --cert-type PEM</span><br><span class="line">    --key key --key-type PEM</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>cURL</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 入门</title>
    <url>/2021/01/27/git%20001/</url>
    <content><![CDATA[<h1 id="入门">入门</h1>
<p><strong>集中式版本控制系统</strong> 中央服务器存储着版本库的当前版本和历史记录, 每个开发者都从该服务器检出到本地工作目录, 修改后定期将修改提交到中央服务器</p>
<p><strong>分布式版本控制系统</strong> 开发者环境和服务器环境之间是没有分隔的, 每个开发者同时拥有一个用于当前文件操作的工作区与一个存储该项目所以版本, 分支以及标签的本地版本库</p>
<h2 id="git">Git</h2>
<p><a href="https://git-scm.com/">Git</a> 是一个免费的开源分布式版本控制系统, 主要由两个层面构成, 其顶层结构就是开发者常用的命令, 称为 <strong>瓷质命令(porcelain command)</strong>, 其底层结构是一组带有少量选项的简单命令, 称为 <strong>管道(plumbing)</strong></p>
<p>Git 会保存每个文件原有的访问权限, 但不会保留文件的修改时间, 因此在执行检出操作时, 文件的修改时间会被设置为当前时间</p>
<blockquote>
<p>许多构建工具的重新生成项目动作都是靠文件的修改时间来触发的, 由于 Git 在进行检出操作时总是用当前时间来充当文件的修改时间, 所以就能确保这些工具正确的完成整个构建过程</p>
</blockquote>
<h2 id="command">command</h2>
<h3 id="配置">配置</h3>
<p>Git 是一个高可配置软件, 配置文件是简单的 <code>.ini</code> 风格的文本文件</p>
<p>Git 支持不同层次的配置文件, 按照优先级递减的顺序:</p>
<ul>
<li><code>.git/config</code> 版本库特定的配置设置, 可用 <code>--file</code> 选项修改;</li>
<li><code>~/.gitconfig</code> 用户特定的配置设置, 可用 <code>--global</code> 选项修改;</li>
<li><code>/etc/gitconfig</code> 系统范围的配置设置, 可用 <code>--system</code> 选项修改</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 用户配置</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git config --global user.name <span class="string">&quot;xxx&quot;</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git config --global user.email <span class="string">&quot;xxx&quot;</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>更多配置参数见 <a href="https://git-scm.com/docs/git-config">config</a></p>
</blockquote>
<h3 id="工作区">工作区</h3>
<p>对于一个带版本库的项目目录, 通常称之为 <strong>工作区(working trees)</strong>, 工作区中所发生的修改添加到 <strong>暂存区(index)</strong>, 再提交到版本库中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 创建版本库</span></span><br><span class="line">git init</span><br><span class="line"><span class="meta">#</span><span class="bash"> init命令会在当前目录中创建一个名为 .git 的隐藏目录, 并在其中创建一个版本库</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 常用命令</span></span><br><span class="line">git add &lt;pathspec&gt;          # 添加工作区指定文件到暂存区</span><br><span class="line">git add --all               # 添加工作区所有文件到暂存区</span><br><span class="line">git rm &lt;pathspec&gt;           # 删除版本库中的文件</span><br><span class="line">git rm --cached &lt;pathspec&gt;  # 删除暂存区中的文件</span><br><span class="line">git diff                    # 对比暂存区和工作区</span><br><span class="line">git diff --staged           # 对比暂存区和版本库</span><br><span class="line">git status                  # 查看工作区相较暂存区的改动</span><br><span class="line">git status --short</span><br><span class="line">git reset                   # 重置暂存区的改动</span><br><span class="line">git commit                  # 提交暂存区的改动到版本库</span><br><span class="line">git commit --amend          # 改变最近一次提交</span><br></pre></td></tr></table></figure>
<blockquote>
<p>更多命令用法见 <a href="https://git-scm.com/docs">command</a></p>
</blockquote>
<h3 id="版本库">版本库</h3>
<p>Git <strong>版本库(repository)</strong> 是一个简单的数据库, 其中包含所有用来维护与管理项目的修订版本和历史的信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 克隆版本库</span></span><br><span class="line">git clone &lt;repository&gt; &lt;directory&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 处理共享版本库时, 应该在URL加上相关的文件传输协议, 其中ssh是使用频率最高的协议</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 不带工作区的版本库称为裸版本库, 通常被用来充当开发者传递提交的汇聚点, 以便其他人可以从中拉回他们所做的修改</span></span><br><span class="line">git clone --bare &lt;repository&gt; &lt;directory&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 常用命令</span></span><br><span class="line">git remote                        # 远程版本库</span><br><span class="line">git fetch &lt;repository&gt; &lt;refspec&gt;  # 拉取</span><br><span class="line">git pull &lt;repository&gt; &lt;refspec&gt;   # 拉取合并</span><br><span class="line">git push &lt;repository&gt; &lt;refspec&gt;   # 推送</span><br><span class="line">git fsck                          # 查看版本库的完整性</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 查看版本库历史</span></span><br><span class="line">git log</span><br><span class="line"></span><br><span class="line">git log -n 3       # 显示最后3次提交</span><br><span class="line">git log --oneline  # 显示概述信息</span><br><span class="line">git log --stat     # 显示被修改的文件</span><br><span class="line">git log --graph    # 显示各提交之间的关系</span><br></pre></td></tr></table></figure>
<h2 id="plumbing">plumbing</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 项目结构</span></span><br><span class="line">├─.git</span><br><span class="line">├─README.md</span><br><span class="line">└─src</span><br><span class="line">    ├─Hello.java</span><br><span class="line">    └─World.java</span><br></pre></td></tr></table></figure>
<p>在版本库中, Git 维护两个主要的数据结构:</p>
<p><strong>对象库(object store)</strong> 包含原始数据文件和日志消息, 以及其他用来重建项目任意版本或分支的信息</p>
<p><strong>索引(index)</strong> 动态的二进制文件, 描述整个版本库的目录结构</p>
<h3 id="对象库">对象库</h3>
<p>Git 放在对象库里的对象只有 4 种类型, 这 4 种原子对象构成高层数据结构的基础:</p>
<ul>
<li>块(blob)</li>
<li>目录树(tree)</li>
<li>提交(commit)</li>
<li>标签(tag)</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 将文件内容作为一条记录存储到对象数据库中</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git hash-object -w README.md</span></span><br><span class="line">5e1c309dae7f45e0f39b1bf3ac3cd9db12e7d689</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例: 打印指定键值存储的对象</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git cat-file -p 5e1c309d</span></span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 查看根目录的对象</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git cat-file -p master^&#123;tree&#125;</span></span><br><span class="line">100644 blob 5e1c309dae7f45e0f39b1bf3ac3cd9db12e7d689    README.md</span><br><span class="line">040000 tree dbd1727ac3048ba4e6710ee670a8adb505fc45bb    src</span><br><span class="line"><span class="meta">#</span><span class="bash"> 每个条目都被分配了相应的访问权限和类型, 以及由该文件内容或目录生成的散列值</span></span><br></pre></td></tr></table></figure>
<pre class="mermaid">flowchart LR
    TITLE["图 对象库中的表现形式"]
    subgraph b8766ae2a
        A1(README.md blob 5e1c309d)
        A2(src tree dbd1727a)
    end
    subgraph 5e1c309d
        B1(Hello World)
    end
    subgraph dbd1727a
        C1(Hello.java blob 81443fc5)
        C2(World.java blob d4f17e98)
    end
    subgraph 81443fc5
        D1("class Hello { ... }")
    end
    subgraph d4f17e98
        D2("class World { ... }")
    end
    A1 --> 5e1c309d
    A2 --> dbd1727a
    C1 --> 81443fc5
    C2 --> d4f17e98
style TITLE fill:#FFF,stroke:#FFF</pre>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 查看提交的对象</span></span><br><span class="line">❯ git cat-file -p 46703b06</span><br><span class="line">tree b8766ae2a83bf3a04231833dd91737ffbedd2c6f</span><br><span class="line">parent cef02a58bb3491036daac6411c3aae730257abe0</span><br><span class="line">author xxxx &lt;xxxx@xx.com&gt; 1610408724 +0800</span><br><span class="line">committer xxxx &lt;xxxx@xx.com&gt; 1610408724 +0800</span><br><span class="line"></span><br><span class="line">fix: update</span><br><span class="line"><span class="meta">#</span><span class="bash"> 除了作者, 提交者, 日期以及注释这些元数据外, 每个提交对象还在对象数据库中放入了一些其他对象的散列值</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> tree对象负责描述该提交的内容, 它还包含了该项目的根目录信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> parent对象指的是上一次提交</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例: 查看标签的对象</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git cat-file -p 8bfc6f9d</span></span><br><span class="line">object b8e7a19269e65b3e456ce149f3820c84f84f196c</span><br><span class="line">type commit</span><br><span class="line">tag 1.0.0</span><br><span class="line">tagger xxxx &lt;xxxx@xx.com&gt; 1611619652 +0800</span><br><span class="line"></span><br><span class="line">210118</span><br></pre></td></tr></table></figure>
<h3 id="索引">索引</h3>
<p>索引会记录和保存暂存变更直到准备好提交, 变更通常是添加, 删除或者编辑文件, 索引使得开发的推进与提交的变更之间能够分离开来</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 显示有关索引和工作区中文件的信息</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git ls-files -s</span></span><br><span class="line">100644 5e1c309dae7f45e0f39b1bf3ac3cd9db12e7d689 0       README.md</span><br><span class="line">100644 8bc1ccf3ae0670f94425069fd69e9e2cf25ff1b7 0       src/Hello.java</span><br><span class="line">100644 d4f17e987606a28852d6b17375e1614ac53382f8 0       src/World.java</span><br></pre></td></tr></table></figure>
<h3 id="散列值">散列值</h3>
<p>Git 对象库被组织及实现成一个内容寻址的存储系统, 对象库中的每个对象都有一个唯一的编码, 称之为 <strong>提交散列值(commit hash)</strong></p>
<blockquote>
<p>可以在指定某个提交散列值时采用缩写形式, 大致上只要指定几个足以识别该提交的字符就可以了, 但如果指定的字符太少, Git 还是会报错的</p>
</blockquote>
<p>为了节省内存空间, Git 对于相同数据将只存储一次</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 保存两个数据一样的文件</span></span><br><span class="line">❯ git hash-object -w .\README.md</span><br><span class="line">5e1c309dae7f45e0f39b1bf3ac3cd9db12e7d689</span><br><span class="line">❯ git hash-object -w .\README-copy.md</span><br><span class="line">5e1c309dae7f45e0f39b1bf3ac3cd9db12e7d689</span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过这种方法, Git不仅能够节省内存, 同时也能在性能上得到提升, 许多Git操作之所以快, 就是因为它们的算法只比较相关的散列值, 而不需要查看其实际数据</span></span><br></pre></td></tr></table></figure>
<p>Git 保存对象时使用松散(loose)的格式, 但是为了节省空间并提高效率, Git 会在以下几种情况下自动进行垃圾回收, 将多个对象打包到一个二进制文件(packfile)中</p>
<ul>
<li>版本库里有过多的松散对象;</li>
<li>当推送(<code>push</code>)到一个远程版本库时;</li>
<li>在执行一些引入许多松散对象的命令之后;</li>
<li>在执行一些明确要求的命令(例如 <code>git reflog expire</code>)之后</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 垃圾回收</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git gc</span></span><br><span class="line">Enumerating objects: 38, done.</span><br><span class="line">Counting objects: 100% (38/38), done.</span><br><span class="line">Delta compression using up to 12 threads</span><br><span class="line">Compressing objects: 100% (23/23), done.</span><br><span class="line">Writing objects: 100% (38/38), done.</span><br><span class="line">Total 38 (delta 1), reused 38 (delta 1), pack-reused 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> Git默认配置会自动执行gc命令, 通常不需要开发者手动执行</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例: 查看packfile</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git verify-pack -v .\.git\objects\pack\pack-8013afbc4a8c8c176671d0f549793efa63ca244a.idx</span></span><br><span class="line">...</span><br><span class="line">42eac1afaf772a41eea83e9f41bf4e456205b414 blob   115 26 212357</span><br><span class="line">0e38150bd03e2f0b6d566fb3af708f77ca426a21 blob   4 14 212460 1 42eac1afaf772a41eea83e9f41bf4e456205b414</span><br><span class="line">...</span><br><span class="line">chain length = 1: 1 object</span><br><span class="line">.\.git\objects\pack\pack-8013afbc4a8c8c176671d0f549793efa63ca244a.pack: ok</span><br><span class="line"><span class="meta">#</span><span class="bash"> 旧版本0e38150b(4bytes)将引用最新版本42eac1af(115bytes), 此处42eac1af是完整存储的版本, 而0e38150b则存储为增量, 这是因为开发者需要更快的访问最新版本</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 版本库</title>
    <url>/2021/01/27/git%20002/</url>
    <content><![CDATA[<h1 id="版本库">版本库</h1>
<h2 id="分支">分支</h2>
<p>当有多个开发者用 Git 并行式开发时, 就需要创建各自的 <strong>分支(branch)</strong>, 在一个 Git 版本库中, 总是唯一存在着一个活动分支, 一般情况下, 活动分支将会被继续用于接受所有新的提交, 并将分支指针移动至最近的那次提交</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 列出当前所有分支</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git branch</span></span><br><span class="line">* master</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例: 列出远程跟踪分支</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git branch -r</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 为当前提交创建分支</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git branch dev</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例: 切换分支</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git checkout dev</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例: 删除分支</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git branch -d dev</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 创建并切换到新分支</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git checkout -b dev</span></span><br></pre></td></tr></table></figure>
<p>分支指针主要用于指向活动分支, 它会每次提交时移动到最新提交上</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 重置分支指针</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git reset --hard 17fb214d</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 工作区和暂存区中的任何更改都将被重置</span></span><br></pre></td></tr></table></figure>
<h3 id="合并">合并</h3>
<p>在 Git 中, 合并必须发生在一个版本库中, 当一个分支中的修改与另一个分支中的修改不发生冲突的时候, Git 会计算合并结果, 并创建一个新提交来代表新的统一状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 合并分支</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git merge dev</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认使用递归算法</span></span><br></pre></td></tr></table></figure>
<p>合并提交通常都会有两个父级提交, 第一个提交叫做 <strong>第一父级提交</strong>, 它是合并执行完后 <code>HEAD</code> 所在的提交, 代表的是该合并所发生的地方</p>
<pre class="mermaid">graph LR
    TITLE["图 第一父级提交历史"]
    subgraph MASTER
        A --1--> A1
        A1 --1--> A2
        A3 --1--> A4
    end
    subgraph DEV1
        A --> B1
        B1 --> B2
        B2 --> B3
        B3 --> B4
        B2 --2--> A1
        B4 --2--> A3
    end
    subgraph DEV2
        A --> C1
        C1 --> C2
        C2 --> C3
        C3 --2--> A2
    end
    subgraph DEV3
        A2 --> D1
        D1 --> D2
        D2 --2--> A4
    end
    A2 --1--> A3
style TITLE fill:#FFF,stroke:#FFF</pre>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 显示第一父级提交历史</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git <span class="built_in">log</span> --first-parent --oneline</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第一父级提交历史提供了一份历史总结报告, 可以从中清楚的看到已被集成的特性, 无需再去查看特性分支上的提交</span></span><br></pre></td></tr></table></figure>
<h3 id="冲突">冲突</h3>
<p>当 Git 遇到自身无法解决的冲突时, 会显示错误消息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 合并冲突</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git merge dev</span></span><br><span class="line">Auto-merging src/Hello.java</span><br><span class="line">CONFLICT (content): Merge conflict in src/Hello.java</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>
<p>冲突标志通常会描述两组修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 文件: src/Hello.java */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">println</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello!&quot;</span></span><br><span class="line">=======</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello.&quot;</span></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决冲突最好的办法是使用像 kdiff3 这样的合并工具, 可以从终端启动合并工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 合并工具</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git mergetool</span></span><br></pre></td></tr></table></figure>
<p>如果在合并或者解决冲突时出错的话, 可以取消合并</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 取消合并</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git reset --merge</span></span><br></pre></td></tr></table></figure>
<h3 id="符号引用">符号引用</h3>
<p>Git 自动维护几个用于特定目的的特殊符号引用, 这些引用可以在使用提交的任何地方使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 查看HEAD指向的分支</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git symbolic-ref HEAD</span></span><br><span class="line">refs/heads/master</span><br></pre></td></tr></table></figure>
<p>Git 还提供一种机制来确定相对于另一个引用的提交, 符号 <code>~</code> 是用来在当前提交路径上回溯父提交, 符号 <code>^</code> 是用来选择不同的父提交的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 以HEAD为例</span></span><br><span class="line">HEAD~3      # 表示当前提交的第一父级提交历史的上第3个提交, 等同于HEAD~~~</span><br><span class="line">HEAD^3      # 表示当前提交的第3父级提交</span><br><span class="line">HEAD^1^1^1  # 表示当前提交的第1父级提交的第1父级提交的第1父级提交, 等同于HEAD^^^</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 等同</span></span><br><span class="line">HEAD = HEAD~0 = HEAD^0</span><br><span class="line">HEAD~ = HEAD~1 = HEAD^ = HEAD^1</span><br><span class="line">HEAD~2 = HEAD^^</span><br><span class="line">HEAD~3 = HEAD^^^</span><br><span class="line">HEAD^2~3 = HEAD^2^^^</span><br></pre></td></tr></table></figure>
<h4 id="head">HEAD</h4>
<p><code>HEAD</code> 始终指向当前分支的最近提交, 当切换分支时, <code>HEAD</code> 会更新为指向新分支的最近提交</p>
<h4 id="orig_head">ORIG_HEAD</h4>
<p>合并或复位等操作会把调整为新值之前的先前版本的 <code>HEAD</code> 记录到 <code>ORIG_HEAD</code> 中, 可以使用 <code>ORIG_HEAD</code> 来恢复或回滚到之前的状态或者做一个比较</p>
<h4 id="fetch_head">FETCH_HEAD</h4>
<p>当使用远程版本库时, <code>FETCH_HEAD</code> 记录最近抓取版本的 <code>HEAD</code>, 并且仅在刚刚抓取操作之后才有效, 使用这个符号引用, 哪怕是一个对没有指定分支名的匿名抓取操作, 也可以在 <code>FETCH_HEAD</code> 中找到提交的 <code>HEAD</code></p>
<h4 id="merge_head">MERGE_HEAD</h4>
<p>当一个合并操作正在进行时, 其他分支的 <code>HEAD</code> 暂时记录在 <code>MERGE_HEAD</code> 中</p>
<h2 id="储藏">储藏</h2>
<p>在日常开发周期中, 需要中断处理其他请求时, Git 提供了 <strong>储藏(stash)</strong> 功能, 可以仅通过一条简单命令就全面彻底的捕获工作目录和索引, 使版本库干净整洁的准备好向另一个方向开发, 并且在方便时再回到原来的工作进度</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 储藏</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git stash</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git stash push -m &lt;message&gt;  <span class="comment"># 自定义储藏消息</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例: 恢复</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git stash pop</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 列出储藏栈</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git stash list</span></span><br><span class="line">stash@&#123;0&#125;: WIP on master: b8e7a19 Merge branch &#x27;dev&#x27;</span><br><span class="line">stash@&#123;1&#125;: WIP on master: b8e7a19 Merge branch &#x27;dev&#x27;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例: 恢复指定的储藏</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git stash pop stash@&#123;1&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="标签">标签</h2>
<p>Git 中可以使用 <strong>标签(tag)</strong> 来标识软件的版本, 标签的作用是为某一版本提供一个永久性的标记</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 创建标签</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git tag 1.0.0 master -m <span class="string">&quot;210118&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为当前版本库的master分支创建名为1.0.0的标签, 并将其注释为210118</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例: 修改标签</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git tag 1.0.1 master -m <span class="string">&quot;210118&quot;</span> --force</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果标签已经被推送到其他版本库并被广泛采用, 最好不要修改它</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 推送标签</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git push origin 1.0.0</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git push --tags</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 列出所有标签</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git tag</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例: 打印对象的散列值</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git show-ref --dereference --tags</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --tags         打印标签对象的散列值</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --dereference  打印标签相应提交对象的散列值</span></span><br></pre></td></tr></table></figure>
<h2 id="引用日志">引用日志</h2>
<p>Git 持续跟踪分支上所发生的所有修改, 并将 <strong>引用日志(reflog)</strong> 保存在 <code>.git/logs</code> 目录中, 当开发过程丢失需要的提交时, 可以通过引用日志搜索并恢复</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 查看引用日志</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git reflog</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git <span class="built_in">log</span> --walk-reflogs</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 配置不可引用对象的清理过期时间</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git config gc.pruneExpire  <span class="comment"># 默认两个星期</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Git通常不会立即删除版本中不可引用的对象, 当调用gc命令时会删除符合清理过期时间的对象</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 配置引用日志清理时间</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git config gc.reflogExpire  <span class="comment"># 默认90天</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git config gc.reflogExpireUnreachable  <span class="comment"># 默认30天</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 配置引用日志是否启用</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git config core.logAllRefUpdates  <span class="comment"># 默认启用</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 服务器上的裸版本库在默认情况下是没有启用引用日志的</span></span><br></pre></td></tr></table></figure>
<h2 id="子项目">子项目</h2>
<p>在 Git 中, 版本库是发行单位, 代表的是一个版本, 如果一个项目中包含了若干个子项目, 它们有各自的发布周期和属于自己的版本, 那就必须为每个子项目建立对应的版本库</p>
<p>对于主项目和子项目之间的关系, 可以通过 Git 中的 <strong>子模块(submodule)</strong> 或 <strong>子树(subtree)</strong> 来实现</p>
<h3 id="子模块">子模块</h3>
<p>在有些情况下, 开发者可能希望能将两个项目视为独立项目, 但仍然能够在其中一个项目中使用另一个项目, Git 使用子模块解决了这个问题, 子模块允许将模块版本库作为主版本库的子目录, 并使提交分开进行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 添加一个子模块</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git submodule add &lt;repository&gt; &lt;path&gt;  <span class="comment"># 模块版本库克隆到主版本库的目录下, 同时主版本库中会同步创建或更新.gitmodules文件</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git add .gitmodules</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git add &lt;path&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git commit  <span class="comment"># 将模块和配置添加到主版本库中</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 主版本库配置文件 .git/config 中会记录模块的信息</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 克隆一个带子模块的版本库</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git <span class="built_in">clone</span> &lt;repository&gt; &lt;directory&gt;  <span class="comment"># 克隆主版本库</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">cd</span> &lt;directory&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git submodule init    <span class="comment"># 配置 .git/config</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git submodule update  <span class="comment"># 更新模块</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 查看根目录的对象</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git cat-file -p master^&#123;tree&#125;</span></span><br><span class="line">100644 blob 3eeb7e21164a9915d563336827f788696e5308eb    .gitmodules</span><br><span class="line">100644 blob 5e1c309dae7f45e0f39b1bf3ac3cd9db12e7d689    README.md</span><br><span class="line">040000 tree 40ce11f08120d524425d18f54dc0155336a2e13d    src</span><br><span class="line">160000 commit b8e7a19269e65b3e456ce149f3820c84f84f196c  sub</span><br><span class="line"><span class="meta">#</span><span class="bash"> 模块sub被识别成commit类型, 散列值引用的模块版本库中的提交</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 子模块常用命令</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">cd</span> &lt;path&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git pull &lt;repository&gt; &lt;refspec&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git push &lt;repository&gt; &lt;refspec&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 子模块依然作为独立项目, 使用命令同git</span></span><br></pre></td></tr></table></figure>
<h3 id="子树">子树</h3>
<p>与子模块不同的是, 子树是一个被嵌入的模块版本库, 其全部内容是被导入主版本库, 而不在仅仅是引用了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 嵌入一个子树</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git subtree add -P &lt;prefix&gt; &lt;repository&gt; &lt;ref&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 克隆一个带子树的版本库</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git <span class="built_in">clone</span> &lt;repository&gt; &lt;directory&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 查看根目录的对象</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git cat-file -p master^&#123;tree&#125;</span></span><br><span class="line">100644 blob 5e1c309dae7f45e0f39b1bf3ac3cd9db12e7d689    README.md</span><br><span class="line">040000 tree 40ce11f08120d524425d18f54dc0155336a2e13d    src</span><br><span class="line">040000 tree 738ff033664289be3d43d2ee44601b56b07067d1    sub</span><br><span class="line"><span class="meta">#</span><span class="bash"> 模块sub被识别成tree类型</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 子树常用命令</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git subtree pull -P &lt;prefix&gt; &lt;repository&gt; &lt;ref&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git subtree push -P &lt;prefix&gt; &lt;repository&gt; &lt;ref&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 分支</title>
    <url>/2021/01/27/git%20003/</url>
    <content><![CDATA[<h1 id="分支">分支</h1>
<h2 id="合并">合并</h2>
<p>当不发生冲突时, Git 会计算合并结果, 并创建一个新的提交来代表新的统一状态, 当分支冲突时, Git 并不解决冲突, 这通常出现在对同一个文件的同一行进行修改的时候, 相反 Git 把这种争议性的修改在索引中标记为未合并(unmerged), 留给开发人员来处理, 当 Git 无法自动合并时, 需要在所有冲突都解决后做一次最终提交</p>
<h3 id="退化合并">退化合并</h3>
<p><strong>退化合并</strong> 的情况下执行合并实际都不引入新的提交, Git 只将目标分支的当前指针前移到最新的位置</p>
<p>当来自合并分支的所有提交都存在于目标分支上时, 即使它已经在自己的分支上前进了, 目标分支还是已经更新到最新的, 因此没有新的提交添加到目标分支上, 称为 <strong>already up-to-date</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: already up-to-date</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git merge master</span></span><br><span class="line">Already up to date.</span><br></pre></td></tr></table></figure>
<p>当目标分支已经在合并分支中完全存在或表示时, 就会发生快进合并 <strong>fast-forward</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: fast-forward</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git merge master</span></span><br><span class="line">Updating 81764e6..b8e7a19</span><br><span class="line">Fast-forward</span><br></pre></td></tr></table></figure>
<h3 id="常规合并">常规合并</h3>
<p><strong>常规合并</strong> 都会产生一个最终提交, 添加到当前分支中, 表示合并的组合状态, Git 实现了 3 种不同的合并算法:</p>
<ul>
<li><strong>解决(resolve)</strong> 解决策略只操作两个分支, 定位共同的祖先作为合并基础, 然后执行一个直接的三方合并, 通过对目标分支施加从合并基础到合并分支的变化</li>
<li><strong>递归(recursive)</strong> 递归策略只操作两个分支, 它能处理在两个分支之间有多个合并基础的情况, 在这种情况下, Git 会生成一个临时合并来包含所有相同的合并基础, 然后以此为基础, 通过三方合并算法导出两个给定分支的最终合并</li>
<li><strong>章鱼(octopus)</strong> 章鱼策略是专为合并两个以上分支而设计的, 在内部, 它多次调用 recursive 合并策略, 要合并的每个分支调一次, 然而这个策略不能处理需要用户交互解决的冲突, 在这种情况下, 必须做一系列常规合并, 一次解决一个冲突</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 指定resolve策略</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git merge -s resolve master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认情况下, 不使用-s指定合并策略时, 单个合并分支使用recursive策略, 多个合并分支使用octopus策略</span></span><br></pre></td></tr></table></figure>
<h3 id="特殊合并">特殊合并</h3>
<p><strong>特殊合并</strong> 有两个特别的合并策略:</p>
<ul>
<li><strong>我们的(ours)</strong> 策略合并任意数量的其他分支, 但它实际上丢弃那些分支的修改, 只使用当前分支的文件, ours 合并结果跟当前分支是相同的, 但是其他分支也记为父提交</li>
<li><strong>子树(subtree)</strong> 子树策略合并到另一个分支, 但是那个分支会合并到当前树的特定子树</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 指定ours策略</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git pull -s ours &lt;repository&gt; &lt;refspec&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例: 指定subtree策略</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git pull -s subtree &lt;repository&gt; &lt;refspec&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="差异">差异</h2>
<p>通常, 差异比较时可以通过提交名, 分支名或者标签名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 比较暂存区和工作区</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git diff</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 一般情况下, Git 会逐行比较两个文件, 因为在源代码中, 开发人员往往修改的都是单行内容, 其邻近行通常不会被波及</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例: 比较暂存区和指定提交</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git diff --staged  <span class="comment"># 默认为HEAD</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git diff --staged HEAD</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 按单词比较</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git diff --word-diff</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git diff --word-diff=color  <span class="comment"># 以不同颜色显示</span></span></span><br></pre></td></tr></table></figure>
<p>可以将提交视为自上一次提交以来项目中所纳入的一组修改, 所以版本库实质上也是一部项目的修改历史</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 比较两次提交</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git diff 01ac6b50 HEAD</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例: 比较提交与前次提交</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git diff 01ac6b50^!</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 指定路径限制输出版本库的子集</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git diff ./src</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例: 差异的统计数据, 显示文件修改的行数</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git diff --<span class="built_in">stat</span></span></span><br></pre></td></tr></table></figure>
<h2 id="排查">排查</h2>
<p>Git 提供了几种机制, 有助于开发人员在版本库中找到符合特定条件的提交</p>
<h3 id="bisect">bisect</h3>
<p>在开发过程中, 开发人员经常会突然遇到一个错误, 是之前早期版本在成功通过测试时没有出现的, Git 支持用二分法来搜索引发问题的提交</p>
<blockquote>
<p><strong>二分法</strong> 是基于二分搜索的一种查找方法, 查找的起点是已确认没问题的提交, 终点是已明确有错误的提交, 两者之间这段提交历史将会被分半, 位于中间的提交会在工作区中被激活, 开发人员对被激活的提交进行错误检查, 接着再根据是否在被激活提交中找到该错误的情况, 再对错误必然会隐藏的那段剩余的提交历史进行重新分半, 并检查新的中间提交, 如此反复, 最终就会找到第一次出现该错误的提交</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 执行二分法排错</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git bisect start HEAD b8e7a192</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Git使用一个分离的HEAD来管理版本库的当前检出版本, 这个分离的HEAD本质上是一个匿名分支, 第一个提交被标志成bad, 第二个提交被标志为good</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 对当前提交进行标志</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git bisect good  <span class="comment"># 错误不在其中</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git bisect bad   <span class="comment"># 错误就在其中</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git bisect skip  <span class="comment"># 当前提交无法被测试</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 停止或取消二分查找</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git bisect reset</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 工作区中的内容重置回正常的开发版本</span></span><br></pre></td></tr></table></figure>
<h3 id="blame">blame</h3>
<p>Git 可以查找文件中代码的来源, 确定最终修改的开发人员以及修改的时间, 即使这些代码已被移动或复制到别处</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 查找指定文件中2-4行的提交</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">  git blame -L 2,4 src\Hello.java</span></span><br><span class="line">53d4cf4c (xxxx 2021-01-18 16:42:27 +0800 2)     public String println() &#123;</span><br><span class="line">53d4cf4c (xxxx 2021-01-18 16:42:27 +0800 3)         return &quot;hello!&quot;</span><br><span class="line">53d4cf4c (xxxx 2021-01-18 16:42:27 +0800 4)     &#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> -L 指定行范围, 可以指定多次, 允许重叠范围</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -M 检测文件中移动或复制的行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -C 检测从同一提交中修改的其他文件移动或复制的行</span></span><br></pre></td></tr></table></figure>
<h3 id="pickaxe">pickaxe</h3>
<p>Git 通过搜索修订版本间的差异可以找到执行改变的提交</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 查找日志中改变包含指定表达式的记录</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git <span class="built_in">log</span> -S&lt;string&gt; --pickaxe-regex</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git <span class="built_in">log</span> -G&lt;regex&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="提交">提交</h2>
<p>作为一般原则, 只要没有其他开发人员已经获得版本库的副本, 就可以自由的修改和完善版本库提交历史记录, 一般情况下, 如果能让提交更简洁和利于理解, 开发人员应该力求简练且结构良好的补丁, Git 提供了几个工具和命令, 专门用来修改完善版本库中的提交序列</p>
<h3 id="reset">reset</h3>
<p><code>git reset</code> 命令会把版本库和工作目录改变为已知状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 将HEAD指向给定提交, 默认使用--mixed模式</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git reset &lt;commit&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --soft   索引和工作目录的内容保持不变</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --mixed  索引改变以符合提交的树结构, 工作目录中的内容保持不变</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --hard   索引改变以符合提交的树结构, 工作目录中的内容也改变以反映提交表示的树状态</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例: 将HEAD指向前一次提交, 并保留工作目录中的内容</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git reset HEAD^</span></span><br></pre></td></tr></table></figure>
<h3 id="cherry-pick">cherry-pick</h3>
<p><code>git cherry-pick</code> 命令会在当前分支上应用给定提交引入的变更, 这将引入一个新的提交</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 应用指定提交的变更</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git cherry-pick &lt;commit&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例: 在master分支上应用dev分支的最新提交的变更</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git checkout master</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git cherry-pick dev</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 重建一系列提交, 在master分支上倒序应用dev分支的最新3次提交的变更</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git checkout master</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git cherry-pick dev</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git cherry-pick dev^</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git cherry-pick dev~2</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在这种情况下, 提交的顺序改变很可能不得不解决冲突, 这完全取决于提交之间的关系, 如果它们是高度耦合的, 并且修改的行有重叠, 那就有冲突需要解决</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例: 发生冲突时可以执行的命令</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git cherry-out (--<span class="built_in">continue</span> | --skip | --abort | --quit)</span></span><br></pre></td></tr></table></figure>
<h3 id="revert">revert</h3>
<p><code>git revert</code> 命令会在当前分支上应用给定提交的逆过程, 这将引入一个新的提交</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 撤销指定提交的变更</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git revert &lt;commit&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例: 撤销前第3次提交的变更</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git revert HEAD~3</span></span><br></pre></td></tr></table></figure>
<h3 id="rebase">rebase</h3>
<p><code>git rebase</code> 命令用来改变分支的基础提交</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 变基</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git rebase master</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通常不会直接调用rebase命令, 而是对远程版本库中的修改进行变基处理</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git pull --rebase</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 将dev分支的基础提交改成master分支的最新提交</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git checkout dev</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git rebase master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 变基操作后, 按旧基础的提交还会保留在版本库中, 虽然它们不再直接可见, 但是依然可以用过提交散列值进行访问, 只有在执行gc命令清理后才会真正从版本库中删除</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例: 发生冲突时可以执行的命令</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git rebase (--<span class="built_in">continue</span> | --skip | --abort | --quit | --edit-todo | --show-current-patch)</span></span><br></pre></td></tr></table></figure>
<h2 id="忽略">忽略</h2>
<p>可以通过往项目根目录下的 <code>.gitignore</code> 文件中添加条目的方式让 Git 忽略这些文件, 并且可以使用通配符, 也可以在项目的子目录中创建一个 <code>.gitignore</code> 文件, 这样该文件只能影响该目录下的文件和路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: .gitignore</span></span><br><span class="line">target/</span><br><span class="line">pom.xml.tag</span><br><span class="line">pom.xml.releaseBackup</span><br><span class="line">pom.xml.versionsBackup</span><br><span class="line">pom.xml.next</span><br><span class="line">release.properties</span><br><span class="line">dependency-reduced-pom.xml</span><br><span class="line">buildNumber.properties</span><br><span class="line">.mvn/timing.properties</span><br><span class="line"><span class="meta">#</span><span class="bash"> https://github.com/takari/maven-wrapper<span class="comment">#usage-without-binary-jar</span></span></span><br><span class="line">.mvn/wrapper/maven-wrapper.jar</span><br></pre></td></tr></table></figure>
<blockquote>
<p>模板参考 <a href="https://github.com/github/gitignore">gitignore</a></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 忽略已经被版本化的文件</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git update-index --assume-unchanged &lt;file&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>GraphQL 示例</title>
    <url>/2021/05/19/graphql%20002/</url>
    <content><![CDATA[<h1 id="示例">示例</h1>
<p>GraphQL 支持的开发语言, 参考 <a href="https://graphql.cn/code/">language</a></p>
<p>Java 开发, 参考 <a href="https://github.com/graphql-java/graphql-java">graphql-java</a> <a href="https://www.graphql-java-kickstart.com/spring-boot/">graphql-spring-boot</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 示例: Maven配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.graphql-java<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>graphql-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;latest-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="schema">Schema</h2>
<p>GraphQL-Java 提供了通过代码编程定义 schema 的方式, 详见 <a href="https://www.graphql-java.com/documentation/v16/schema/">schema</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 代码方式 */</span></span><br><span class="line">GraphQLObjectType hero = GraphQLObjectType.newObject()</span><br><span class="line">    .name(<span class="string">&quot;Hero&quot;</span>)</span><br><span class="line">    .field(f -&gt; f.name(<span class="string">&quot;id&quot;</span>).type(Scalars.GraphQLID))</span><br><span class="line">    .field(f -&gt; f.name(<span class="string">&quot;name&quot;</span>).type(Scalars.GraphQLString))</span><br><span class="line">    .build();</span><br><span class="line">GraphQLObjectType query = GraphQLObjectType.newObject()</span><br><span class="line">    .name(<span class="string">&quot;Query&quot;</span>)</span><br><span class="line">    .field(f -&gt; f.name(<span class="string">&quot;hero&quot;</span>).type(hero)</span><br><span class="line">           .argument(a -&gt; a.name(<span class="string">&quot;id&quot;</span>).type(Scalars.GraphQLID)))</span><br><span class="line">    .build();</span><br><span class="line">GraphQLSchema schema = GraphQLSchema.newSchema()</span><br><span class="line">    .query(query)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;等同于以下示例(GraphQL SDL)&quot;</span></span><br><span class="line">schema &#123;</span><br><span class="line">    query: Query</span><br><span class="line">&#125;</span><br><span class="line">type Query &#123;</span><br><span class="line">    hero(<span class="name">id:</span> ID): Hero</span><br><span class="line">&#125;</span><br><span class="line">type Hero &#123;</span><br><span class="line">    id: ID</span><br><span class="line">    name: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>推荐使用 GraphQL SDL 语言, 可以将 schema 字符串写到代码变量里, 或者以文本形式写到 <code>.graphql</code> 为扩展名的文件, 再读取到应用内存中</p>
</blockquote>
<p>类型解析器 <code>TypeResolver</code> 用于决定具体值的类型, 这是接口和联合需要的功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: TypeResolver */</span></span><br><span class="line">TypeResolver resolver = env -&gt; &#123;</span><br><span class="line">    Object javaObject = env.getObject();  <span class="comment">// 获取对象</span></span><br><span class="line">    <span class="keyword">if</span> (javaObject <span class="keyword">instanceof</span> Human) &#123;    <span class="comment">// 根据Java类型返回定义的对象类型</span></span><br><span class="line">        <span class="keyword">return</span> env.getSchema().getObjectType(<span class="string">&quot;Human&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (javaObject <span class="keyword">instanceof</span> Droid) &#123;</span><br><span class="line">        <span class="keyword">return</span> env.getSchema().getObjectType(<span class="string">&quot;Droid&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>数据解析器 <code>DataFetcher</code> 为定义的类型和字段提供数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: DataFetcher */</span></span><br><span class="line">DataFetcher&lt;HeroDTO&gt; fetcher = env -&gt; &#123;</span><br><span class="line">    String id = env.getArgument(<span class="string">&quot;id&quot;</span>);  <span class="comment">// 可通过env获取参数</span></span><br><span class="line">    <span class="keyword">return</span> bizImpl.getHeroById(id);     <span class="comment">// 返回获取的数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>运行时线路 <code>RuntimeWiring</code> 和 <code>GraphQLSchema</code> 组合成一个可执行的 schema</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: RuntimeWiring */</span></span><br><span class="line">RuntimeWiring runtime = RuntimeWiring.newRuntimeWiring()</span><br><span class="line">    .type(<span class="string">&quot;Query&quot;</span>, trw -&gt; trw.dataFetcher(<span class="string">&quot;hero&quot;</span>, fetcher))  <span class="comment">// 配置字段获取数据的解析器</span></span><br><span class="line">    .type(<span class="string">&quot;Character&quot;</span>, trw -&gt; trw.typeResolver(resolver))    <span class="comment">// 配置接口或联合确定类型的解析器</span></span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">File file = loadSchema(<span class="string">&quot;schema.graphql&quot;</span>);                    <span class="comment">// 读取schema文件</span></span><br><span class="line">TypeDefinitionRegistry registry = <span class="keyword">new</span> SchemaParser().parse(file);</span><br><span class="line">GraphQLSchema schema = <span class="keyword">new</span> SchemaGenerator().makeExecutableSchema(registry, runtime);</span><br></pre></td></tr></table></figure>
<p>GraphQL-Java 允许将 schema 拆分成多个文件, 并在使用前将多个文件合并到一个逻辑单元中, 详见 <a href="https://www.graphql-java.com/documentation/v16/schema/#modularising-the-schema-sdl">modular</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 合并多文件 */</span></span><br><span class="line">SchemaParser parser = <span class="keyword">new</span> SchemaParser();</span><br><span class="line">SchemaGenerator generator = <span class="keyword">new</span> SchemaGenerator();</span><br><span class="line">TypeDefinitionRegistry registry = <span class="keyword">new</span> TypeDefinitionRegistry();</span><br><span class="line"></span><br><span class="line">File file = loadSchema(<span class="string">&quot;schema1.graphql&quot;</span>);</span><br><span class="line">File file2 = loadSchema(<span class="string">&quot;schema2.graphql&quot;</span>);</span><br><span class="line">File file3 = loadSchema(<span class="string">&quot;schema3.graphql&quot;</span>);</span><br><span class="line">registry.merge(parser.parse(file));</span><br><span class="line">registry.merge(parser.parse(file2));</span><br><span class="line">registry.merge(parser.parse(file3));</span><br><span class="line"></span><br><span class="line">GraphQLSchema schema = generator.makeExecutableSchema(registry, runtime);</span><br></pre></td></tr></table></figure>
<h2 id="执行">执行</h2>
<p>要对 schema 执行查询, 需要构建一个 GraphQL 类型的对象, 详见 <a href="https://www.graphql-java.com/documentation/v16/execution/">execution</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 执行查询 */</span></span><br><span class="line">GraphQL graphql = GraphQL.newGraphQL(schema).build();  <span class="comment">// 创建GraphQL对象</span></span><br><span class="line"><span class="comment">// 创建查询的选择集</span></span><br><span class="line">ExecutionInput query = ExecutionInput.newExecutionInput().query(</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        hero &#123;</span></span><br><span class="line"><span class="string">            id</span></span><br><span class="line"><span class="string">            name</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">).build();</span><br><span class="line">ExecutionResult result = graphql.execute(query);    <span class="comment">// 执行查询</span></span><br><span class="line">String response = <span class="keyword">new</span> ObjectMapper()                <span class="comment">// 结果转Json格式</span></span><br><span class="line">    .writerWithDefaultPrettyPrinter()               <span class="comment">// 结构化输出</span></span><br><span class="line">    .writeValueAsString(result.toSpecification());  <span class="comment">// 返回符合响应规范的集合</span></span><br></pre></td></tr></table></figure>
<h3 id="异步">异步</h3>
<p>实际上, GraphQL-Java 引擎查询数据时使用完全异步的执行, 并使调用看起来是同步的, 详见 <a href="https://www.graphql-java.com/documentation/v16/execution/#asynchronous-execution">async</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 以下两种方式等同 */</span></span><br><span class="line"><span class="comment">// 方式一</span></span><br><span class="line">ExecutionResult result = graphql.execute(query);</span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line">CompletableFuture&lt;ExecutionResult&gt; promise = graphql.executeAsync(query);</span><br><span class="line">ExecutionResult result = promise.join();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 异步回调的方式 */</span></span><br><span class="line">CompletableFuture&lt;ExecutionResult&gt; promise = graphql.executeAsync(query);</span><br><span class="line">promise.thenAccept(result -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (result.isDataPresent()) &#123;         <span class="comment">// 判断是否执行成功</span></span><br><span class="line">        HeroDTO data = result.getData();  <span class="comment">// 获取查询结果的数据集合</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String error = result.getErrors().get(<span class="number">0</span>).getMessage();  <span class="comment">// 获取错误信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">promise.join();</span><br></pre></td></tr></table></figure>
<h3 id="策略">策略</h3>
<p>GraphQL-Java 提供了许多不同的策略, 用于处理不同的请求操作, 详见 <a href="https://www.graphql-java.com/documentation/v16/execution/#execution-strategies">strategy</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 配置执行策略 */</span></span><br><span class="line">GraphQL graphql = GraphQL.newGraphQL(schema)</span><br><span class="line">    .queryExecutionStrategy(<span class="keyword">new</span> AsyncExecutionStrategy())</span><br><span class="line">    .mutationExecutionStrategy(<span class="keyword">new</span> AsyncSerialExecutionStrategy())</span><br><span class="line">    .subscriptionExecutionStrategy(<span class="keyword">new</span> SubscriptionExecutionStrategy())</span><br><span class="line">    .build();</span><br><span class="line"><span class="comment">// 以上代码相当于默认设置, 并且在大多数情况下是合理的选择</span></span><br></pre></td></tr></table></figure>
<h3 id="缓存">缓存</h3>
<p>GraphQL-Java 引擎执行查询之前, 必须对请求的选择集进行解析和验证, GraphQL 可以通过配置缓存, 来避免重复解析验证的过程, 详见 <a href="https://www.graphql-java.com/documentation/v16/execution/#query-caching">cache</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 示例使用caffeine作为缓存方案 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>caffeine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;latest-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 配置缓存 */</span></span><br><span class="line">Cache&lt;String, PreparsedDocumentEntry&gt; cache = Caffeine.newBuilder()</span><br><span class="line">    .maximumSize(<span class="number">10_000</span>)                      <span class="comment">// 缓存的最大条目数量</span></span><br><span class="line">    .expireAfterWrite(Duration.ofMinutes(<span class="number">5L</span>)) <span class="comment">// 缓存条目的过期时间</span></span><br><span class="line">    .build();</span><br><span class="line">PreparsedDocumentProvider preparsedCache = (executionInput, computeFunction) -&gt; &#123;</span><br><span class="line">    Function&lt;String, PreparsedDocumentEntry&gt; mapCompute = key -&gt; computeFunction.apply(executionInput);</span><br><span class="line">    <span class="keyword">return</span> cache.get(executionInput.getQuery(), mapCompute);</span><br><span class="line">&#125;;</span><br><span class="line">GraphQL graphQL = GraphQL.newGraphQL(schema)</span><br><span class="line">    .preparsedDocumentProvider(preparsedCache)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意这是缓存解析的文档, 并不缓存查询结果, 建议将字段参数作为变量传递, 以达到高效的缓存命中率</p>
</blockquote>
<h2 id="订阅">订阅</h2>
<p>GraphQL-Java 使用响应流实现订阅功能, 当客户端订阅的数据变更时, 服务端将发送新的结果, 详见 <a href="https://www.graphql-java.com/documentation/v16/subscriptions/">subscription</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 示例使用reactive-streams处理响应流 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.reactivestreams<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>reactive-streams<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;latest-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: DataFetcher */</span></span><br><span class="line">DataFetcher&lt;Publisher&lt;StockDTO&gt;&gt; fetcher = env -&gt; &#123;</span><br><span class="line">    String code = env.getArgument(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> buildPublisherForStock(code);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 订阅请求 */</span></span><br><span class="line">ExecutionInput query = ExecutionInput.newExecutionInput().query(</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    subscription StockSubscription &#123;</span></span><br><span class="line"><span class="string">        stock(code: &quot;</span>IBM<span class="string">&quot;) &#123;</span></span><br><span class="line"><span class="string">            code</span></span><br><span class="line"><span class="string">            count</span></span><br><span class="line"><span class="string">            price</span></span><br><span class="line"><span class="string">            datetime</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">).build();</span><br><span class="line">ExecutionResult executionResult = graphQL.execute(query);</span><br><span class="line">Publisher&lt;ExecutionResult&gt; stockPriceStream = executionResult.getData();</span><br><span class="line">AtomicReference&lt;Subscription&gt; subscriptionRef = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">stockPriceStream.subscribe(<span class="keyword">new</span> Subscriber&lt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription s)</span> </span>&#123;</span><br><span class="line">        subscriptionRef.set(s);</span><br><span class="line">        s.request(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(ExecutionResult er)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理数据</span></span><br><span class="line">        processStock(er.getData());</span><br><span class="line">        <span class="comment">// 等待下一个响应</span></span><br><span class="line">        subscriptionRef.get().request(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">        log.info(t.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;the subscription has completed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>GraphQL-Java 只产生结果流, 它不关心通过网络发送数据的套接字等, 这与 GraphQL 规范无关, 更多关于响应流代码的详细信息, 可见 <a href="http://www.reactive-streams.org/">reactive-streams</a></p>
<blockquote>
<p>其它流行的响应式实现, 详见 <a href="http://reactivex.io/intro.html">RxJava</a> <a href="https://projectreactor.io/">Reactor</a></p>
</blockquote>
<h2 id="解析器">解析器</h2>
<p>GraphQL 的数据通过 <code>graphql.schema.DataFetcher</code> 解析器来获取, 详见 <a href="https://www.graphql-java.com/documentation/v16/data-fetching/">fetcher</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: DataFetcher */</span></span><br><span class="line">DataFetcher fetcher = env -&gt; &#123;</span><br><span class="line">    <span class="comment">// 获取父数据的结果, 可以检查它以了解如何获取当前字段的特定信息</span></span><br><span class="line">    T source = env.getSource();</span><br><span class="line">    <span class="comment">// 获取参数的集合</span></span><br><span class="line">    Map&lt;String, Object&gt; arguments = env.getArguments();</span><br><span class="line">    <span class="comment">// 上下文对象是请求第一次执行时设置, 并在请求的生命周期内保持不变</span></span><br><span class="line">    T context = env.getContext();</span><br><span class="line">    <span class="comment">// 请求的调用路径, 可以向上导航查看导致当前字段执行的类型和字段</span></span><br><span class="line">    ExecutionStepInfo stepInfo = env.getExecutionStepInfo();</span><br><span class="line">    <span class="comment">// 当前请求选择的字段集合, 这有助于提前查看客户端想要的字段信息</span></span><br><span class="line">    DataFetchingFieldSelectionSet set = env.getSelectionSet();</span><br><span class="line">    <span class="comment">// 请求会生成唯一的执行id, 可以使用它来记录每个独立的请求</span></span><br><span class="line">    ExecutionId eid = env.getExecutionId();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>GraphQL-Java 中字段默认的数据解析器是 <code>graphql.schema.PropertyDataFetcher</code> 类, 它使用标准的表达式来获取对象的字段值, 默认情况下, 对于选择集中的字段, 它会从 <code>POJO</code> 的属性或 <code>Map</code> 的映射键中寻找同名的字段</p>
<p>在 GraphQL SDL 中可以使用 <code>@fetch</code> 指令来修改字段的映射</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;示例: @fetch&quot;</span></span><br><span class="line">type Hero &#123;</span><br><span class="line">    id: ID</span><br><span class="line">    name: String</span><br><span class="line">    description: String @fetch(<span class="name">from:</span> <span class="string">&quot;desc&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字段选择">字段选择</h3>
<p>了解请求的选择集有助于提高 <code>DataFetcher</code> 的效率, 选择集的路径匹配使用 GLOB 语法, 详见 <a href="https://www.graphql-java.com/documentation/v16/fieldselection/">fieldselection</a></p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;示例: 请求的选择集&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    user(<span class="name">id:</span> <span class="string">&quot;1&quot;</span>) &#123;</span><br><span class="line">        id</span><br><span class="line">        name</span><br><span class="line">        info &#123;</span><br><span class="line">            phone</span><br><span class="line">            email</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: DataFetcher */</span></span><br><span class="line">DataFetcher&lt;UserDTO&gt; fetcher = env -&gt; &#123;</span><br><span class="line">    String userId = env.getArgument(<span class="string">&quot;id&quot;</span>);                      <span class="comment">// 获取参数</span></span><br><span class="line">    DataFetchingFieldSelectionSet set = env.getSelectionSet();  <span class="comment">// 获取请求的选择集</span></span><br><span class="line">    <span class="keyword">if</span> (env.contains(<span class="string">&quot;info/*&quot;</span>)) &#123;                               <span class="comment">// 当有子类字段时一并获取</span></span><br><span class="line">        List&lt;SelectedField&gt; fields = set.getFields(<span class="string">&quot;info/*&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; infoFields = fields.stream().map(SelectedField::getName).collect(Collectors.toSet());</span><br><span class="line">        <span class="comment">// 伪代码 SELECT user.*, info.$&#123;infoFields&#125; FROM user JOIN info WHERE user.id = $&#123;userId&#125;</span></span><br><span class="line">        <span class="keyword">return</span> bizImpl.getUser(userId, infoFields);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bizImpl.getUserById(userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字段可见性">字段可见性</h3>
<p>默认情况下, schema 中的每个字段都是可用的, GraphQL-Java 提供了阻止字段可见的配置, 支持使用正则表达式的语法, 详见 <a href="https://www.graphql-java.com/documentation/v16/fieldvisibility/">fieldvisibility</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: GraphqlFieldVisibility */</span></span><br><span class="line">GraphqlFieldVisibility visibility = BlockedFields.newBlock()</span><br><span class="line">    .addPattern(<span class="string">&quot;User.password&quot;</span>)  <span class="comment">// 指定完整路径的字段</span></span><br><span class="line">    .addPattern(<span class="string">&quot;.*\\.cert&quot;</span>)      <span class="comment">// 指定末级为cert的字段</span></span><br><span class="line">    .build();</span><br><span class="line">GraphQLSchema.newSchema()</span><br><span class="line">    .query(query)</span><br><span class="line">    .codeRegistry(GraphQLCodeRegistry.newCodeRegistry()</span><br><span class="line">        .fieldVisibility(visibility)</span><br><span class="line">        .build())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
<h2 id="优化">优化</h2>
<p>GraphQL-Java 提供了一些特性, 以提高数据获取的性能</p>
<h3 id="批处理">批处理</h3>
<p>GraphQL-Java 支持使用数据加载器 <code>org.dataloader.DataLoader</code> 高效的处理批量的数据获取操作, 它会根据唯一键自动合并同级的对象请求参数, 并缓存获取的结果, 当再次获取相同键的对象时直接从缓存返回结果, 详见 <a href="https://www.graphql-java.com/documentation/v16/batching/">batching</a> <a href="https://github.com/graphql-java/java-dataloader">java-dataloader</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 查询 */</span></span><br><span class="line">String query =</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        hero(id = &quot;</span><span class="number">2001</span><span class="string">&quot;) &#123;</span></span><br><span class="line"><span class="string">            name</span></span><br><span class="line"><span class="string">            friends &#123;  // 嵌套的好友列表可能会重复, 且二维数组会导致乘积数量的获取次数</span></span><br><span class="line"><span class="string">                name   // DataLoader缓存会过滤已请求的对象, 且自动合并同级的请求来减少获取次数</span></span><br><span class="line"><span class="string">                friends &#123;</span></span><br><span class="line"><span class="string">                    name</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: DataFetcher */</span></span><br><span class="line">DataFetcher heroDataFetcher = env -&gt; &#123;</span><br><span class="line">    String id = env.getArgument(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">    DataLoader&lt;String, Character&gt; dataLoader = env.getDataLoader(<span class="string">&quot;character&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> dataLoader.load(id);</span><br><span class="line">&#125;;</span><br><span class="line">DataFetcher friendsDataFetcher = env -&gt; &#123;</span><br><span class="line">    Character c = env.getSource();  <span class="comment">// 使用父结果中的数据来获取参数</span></span><br><span class="line">    List&lt;String&gt; friendIds = c.getFriendIds();</span><br><span class="line">    DataLoader&lt;String, Character&gt; dataLoader = env.getDataLoader(<span class="string">&quot;character&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> dataLoader.loadMany(friendIds);</span><br><span class="line">&#125;;</span><br><span class="line">RuntimeWiring runtime = RuntimeWiring.newRuntimeWiring()</span><br><span class="line">    .type(TypeRuntimeWiring.newTypeWiring(<span class="string">&quot;Query&quot;</span>)</span><br><span class="line">          .dataFetcher(<span class="string">&quot;hero&quot;</span>, heroDataFetcher()))</span><br><span class="line">    .type(TypeRuntimeWiring.newTypeWiring(<span class="string">&quot;Hero&quot;</span>)</span><br><span class="line">          .dataFetcher(<span class="string">&quot;friends&quot;</span>, friendsDataFetcher()))</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 批处理 */</span></span><br><span class="line">GraphQL graphQL = GraphQL.newGraphQL(schema).build();</span><br><span class="line">BatchLoader&lt;String, Character&gt; characterBatchLoader = keys -&gt; CompletableFuture</span><br><span class="line">    .supplyAsync(() -&gt; bizImpl.getCharacterByIds(keys));</span><br><span class="line">DataLoader&lt;String, Character&gt; characterDataLoader = DataLoader.newDataLoader(characterBatchLoader);</span><br><span class="line">DataLoaderRegistry registry = <span class="keyword">new</span> DataLoaderRegistry();</span><br><span class="line">registry.register(<span class="string">&quot;character&quot;</span>, characterDataLoader);  <span class="comment">// 配置数据加载器</span></span><br><span class="line">ExecutionInput input = ExecutionInput.newExecutionInput()</span><br><span class="line">    .query(query)</span><br><span class="line">    .dataLoaderRegistry(registry)</span><br><span class="line">    .build();</span><br><span class="line">ExecutionResult executionResult = graphQL.execute(input);  <span class="comment">// 此示例最多只会触发3次数据获取操作</span></span><br></pre></td></tr></table></figure>
<p>数据加载器 <code>DataLoader</code> 的实例范围很重要, 如果数据操作需要按用户角色返回特定数据的情况, 则需要为不同的用户角色分别实例化数据加载器, 以避免缓存数据提供给错误的用户</p>
<h3 id="缓存-1">缓存</h3>
<p>通过配置数据加载器的缓存实现, 改为使用 Memcached 或 Redis 等外部缓存, 则可以实现缓存数据的跨节点共享</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 示例使用redis缓存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;latest-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 配置redis缓存 */</span></span><br><span class="line">CacheMap&lt;String, Object&gt; cacheMap = <span class="keyword">new</span> CacheMap&lt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Autowired</span>  <span class="comment">// 注入redis操作对象</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisImpl;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisImpl.hasKey(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisImpl.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheMap&lt;String, Object&gt; <span class="title">set</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        redisImpl.opsForValue().set(key, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheMap&lt;String, Object&gt; <span class="title">delete</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        redisImpl.delete(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheMap&lt;String, Object&gt; <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        redisImpl.keys(<span class="string">&quot;*&quot;</span>).forEach(redisImpl::delete);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">DataLoaderOptions options = DataLoaderOptions</span><br><span class="line">    .newOptions().setCacheMap(cacheMap);  <span class="comment">// 配置指定的缓存实现</span></span><br><span class="line">DataLoader&lt;String, Character&gt; dataLoader = DataLoader</span><br><span class="line">    .newDataLoader(characterBatchLoader, options);</span><br></pre></td></tr></table></figure>
<h3 id="延迟">延迟</h3>
<p>在执行查询时, 通常有两类数据, 需要立即获取的数据和可以稍后获取的数据, GraphQL-Java 使用 <code>@defer</code> 指令实现了对延迟获取的支持, 详见 <a href="https://www.graphql-java.com/documentation/v16/defer/">defer</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 延迟 */</span></span><br><span class="line">ExecutionInput query = ExecutionInput.newExecutionInput().query(</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        post &#123;</span></span><br><span class="line"><span class="string">            postText           // 直接获取的字段</span></span><br><span class="line"><span class="string">            comments @defer &#123;  // 被标记@defer的字段将通过扩展使用订阅来获取</span></span><br><span class="line"><span class="string">                commentText</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">            reviews @defer &#123;</span></span><br><span class="line"><span class="string">                reviewText</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">).build();</span><br><span class="line">ExecutionResult result = graphql.execute(query);</span><br><span class="line">Map map = result.getData();       <span class="comment">// 立即获取的数据</span></span><br><span class="line"><span class="comment">// 通过扩展获取订阅</span></span><br><span class="line">Publisher&lt;ExecutionResult&gt; deferred = (Publisher&lt;ExecutionResult&gt;)result.getExtensions().get(GraphQL.DEFERRED_RESULTS);</span><br><span class="line"><span class="comment">// 订阅延迟的数据</span></span><br><span class="line">deferred.subscribe(<span class="keyword">new</span> Subscriber&lt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(ExecutionResult er)</span> </span>&#123;</span><br><span class="line">        Map map2 = er.getData();  <span class="comment">// 延迟获取的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="扩展">扩展</h2>
<p>GraphQL-Java 允许应用声明非标准的自定义扩展, 注意这在跨语言的开发中, 可能会导致难处理的语义</p>
<h3 id="标量">标量</h3>
<p>GraphQL 规定所有实现都必须具有 5 种基础的标量类型, GraphQL-Java 可以通过 <code>Scalars</code> 对象获取已定义的静态标量, 详见 <a href="https://www.graphql-java.com/documentation/v16/scalars/">scalars</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 内置标量 */</span></span><br><span class="line">Scalars.GraphQLString</span><br><span class="line">Scalars.GraphQLBoolean</span><br><span class="line">Scalars.GraphQLInt</span><br><span class="line">Scalars.GraphQLFloat</span><br><span class="line">Scalars.GraphQLID</span><br></pre></td></tr></table></figure>
<p>应用可以编写自定义的标量实现, 或者使用 GraphQL-Java 的扩展标量, 详见 <a href="https://github.com/graphql-java/graphql-java-extended-scalars">extended-scalars</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 自定义标量 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomScalars</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> GraphQLScalarType EMAIL = GraphQLScalarType.newScalar()</span><br><span class="line">        .name(<span class="string">&quot;Email&quot;</span>)                                       <span class="comment">// 定义schema中使用的标量关键字</span></span><br><span class="line">        .description(<span class="string">&quot;A custom scalar that handles emails&quot;</span>)  <span class="comment">// 描述性文本</span></span><br><span class="line">        .coercing(<span class="keyword">new</span> EmailCoercing())                       <span class="comment">// 标量实现对象</span></span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailCoercing</span> <span class="keyword">implements</span> <span class="title">Coercing</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span>  <span class="comment">// 将Java对象序列化为标量的输出形式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(Object dataFetcherResult)</span> <span class="keyword">throws</span> CoercingSerializeException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serializeEmail(dataFetcherResult);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span>  <span class="comment">// 将标量的输入对象转化为Java对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">parseValue</span><span class="params">(Object input)</span> <span class="keyword">throws</span> CoercingParseValueException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parseEmailFromVariable(input);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span>  <span class="comment">// 将AST字面量转化为Java对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">parseLiteral</span><span class="params">(Object input)</span> <span class="keyword">throws</span> CoercingParseLiteralException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parseEmailFromAstLiteral(input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 配置</span></span><br><span class="line">RuntimeWiring runtime = RuntimeWiring.newRuntimeWiring()</span><br><span class="line">    .scalar(CustomScalars.EMAIL)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
<h3 id="指令">指令</h3>
<p>GraphQL 规范包含两个内置的指令, 并且允许应用编写自定义的指令, 详见 <a href="https://www.graphql-java.com/documentation/v16/sdl-directives/">directive</a></p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;示例: 自定义指令&quot;</span></span><br><span class="line">directive @dateFormat(<span class="name">format:</span> String = <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>) on FIELD_DEFINITION</span><br><span class="line">type user &#123;</span><br><span class="line">    id: ID!</span><br><span class="line">    name: String!</span><br><span class="line">    register_date: String @dateFormat(<span class="name">format</span>)</span><br><span class="line">    birth_date: String @dateFormat(<span class="name">format:</span> <span class="string">&quot;yyyy-MM-dd&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 指令实现 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateFormatter</span> <span class="keyword">implements</span> <span class="title">SchemaDirectiveWiring</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GraphQLFieldDefinition <span class="title">onField</span><span class="params">(SchemaDirectiveWiringEnvironment&lt;GraphQLFieldDefinition&gt; environment)</span> </span>&#123;</span><br><span class="line">        String format = (String)environment.getDirective().getArgument(<span class="string">&quot;format&quot;</span>).getValue();</span><br><span class="line">        GraphQLFieldDefinition field = environment.getElement();</span><br><span class="line">        GraphQLFieldsContainer parentType = environment.getFieldsContainer();</span><br><span class="line">        DataFetcher originalFetcher = environment.getCodeRegistry().getDataFetcher(parentType, field);</span><br><span class="line">        DataFetcher dataFetcher = dataFetchingEnvironment -&gt; &#123;</span><br><span class="line">            Object value = originalFetcher.get(dataFetchingEnvironment);</span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Date) &#123;</span><br><span class="line">                <span class="keyword">return</span> DateFormatUtils.format((Date)value, format);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;;</span><br><span class="line">        environment.getCodeRegistry().dataFetcher(parentType, field, dataFetcher);</span><br><span class="line">        <span class="keyword">return</span> field;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 配置</span></span><br><span class="line">RuntimeWiring runtime = RuntimeWiring.newRuntimeWiring()</span><br><span class="line">    .directive(<span class="string">&quot;dateFormat&quot;</span>, <span class="keyword">new</span> DateFormatter())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
<h3 id="异常">异常</h3>
<p>GraphQL-Java 引擎遇到特殊情况时, 将抛出运行时异常(<code>RuntimeException</code>), <a href="https://www.graphql-java.com/documentation/v16/exceptions/">exceptions</a> 页面列出了执行过程可能抛出的运行时异常</p>
<p>应用可以创建自定义的异常和异常处理程序, 详见 <a href="https://www.graphql-java.com/documentation/v16/execution/#exceptions-while-fetching-data">exception</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 自定义异常 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomRuntimeException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> <span class="keyword">implements</span> <span class="title">GraphQLError</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;SourceLocation&gt; <span class="title">getLocations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span>  <span class="comment">// 异常类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ErrorClassification <span class="title">getErrorType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ErrorType.DataFetchingException;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span>  <span class="comment">// 额外数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getExtensions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ImmutableMap.of(</span><br><span class="line">            <span class="string">&quot;extra&quot;</span>, <span class="string">&quot;extra data&quot;</span>,</span><br><span class="line">            <span class="string">&quot;desc&quot;</span>, <span class="string">&quot;A custom exception.&quot;</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 自定义异常处理 */</span></span><br><span class="line">DataFetcherExceptionHandler handler = <span class="keyword">new</span> SimpleDataFetcherExceptionHandler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataFetcherExceptionHandlerResult <span class="title">onException</span><span class="params">(DataFetcherExceptionHandlerParameters handlerParameters)</span> </span>&#123;</span><br><span class="line">        Throwable exception = handlerParameters.getException();</span><br><span class="line">        <span class="keyword">if</span>(exception <span class="keyword">instanceof</span> CustomRuntimeException) &#123;</span><br><span class="line">             log.info(exception.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onException(handlerParameters);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 配置</span></span><br><span class="line">ExecutionStrategy strategy = <span class="keyword">new</span> AsyncExecutionStrategy(handler);</span><br><span class="line">GraphQL graphal = GraphQL.newGraphQL(schema)</span><br><span class="line">    .queryExecutionStrategy(strategy)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
<h2 id="跟踪器">跟踪器</h2>
<p>GraphQL-Java 提供了 <code>graphql.execution.instrumentation.Instrumentation</code> 接口, 用以观察查询的执行, 也可以改变运行时的行为, 它的主要用例是监视和记录日志, 但也可以用于许多不同目的, 详见 <a href="https://www.graphql-java.com/documentation/v16/instrumentation/">instrumentation</a></p>
<p>GraphQL-Java 内置 3 个跟踪器的实现:</p>
<ul>
<li><code>DataLoaderDispatcherInstrumentation</code> 跟踪数据加载器的执行分派和统计</li>
<li><code>TracingInstrumentation</code> 是遵循 <a href="https://github.com/apollographql/apollo-tracing">apollo-tracing</a> 中定义的跟踪格式的跟踪器, 跟踪的详细信息将在结果的扩展部分返回</li>
<li><code>FieldValidationInstrumentation</code> 是用于查询执行之前验证字段及其参数的跟踪器, 如果在此过程中验证错误, 则中止查询执行, 错误将在查询结果中返回</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 配置跟踪器 */</span></span><br><span class="line">List&lt;Instrumentation&gt; instrumentations = Lists.newArrayList();</span><br><span class="line">instrumentations.add(<span class="keyword">new</span> DataLoaderDispatcherInstrumentation());</span><br><span class="line">instrumentations.add(<span class="keyword">new</span> TracingInstrumentation());</span><br><span class="line"><span class="comment">// SimpleFieldValidation对象可使用addRule添加字段验证规则</span></span><br><span class="line">instrumentations.add(<span class="keyword">new</span> FieldValidationInstrumentation(<span class="keyword">new</span> SimpleFieldValidation()));</span><br><span class="line">GraphQL.newGraphQL(schema)</span><br><span class="line">    <span class="comment">// ChainedInstrumentation允许组合跟踪链</span></span><br><span class="line">    .instrumentation(<span class="keyword">new</span> ChainedInstrumentation(instrumentations))</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开发</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>GraphQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 工具</title>
    <url>/2021/01/30/git%20004/</url>
    <content><![CDATA[<h1 id="工具">工具</h1>
<h2 id="服务器">服务器</h2>
<p>Git 版本库分为 <strong>裸(bare)版本库</strong> 和 <strong>开发(development, nonbare)版本库</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 版本库</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">cd</span> /d</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git init --bare bare.git              <span class="comment"># 初始化一个裸版本库</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git <span class="built_in">clone</span> file:///d/bare.git dev.git  <span class="comment"># 从裸版本库克隆一个开发版本库</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果没有使用--initial-branch指定初始分支名称时, 则默认使用名称master</span></span><br></pre></td></tr></table></figure>
<p>默认情况下, 每个新的克隆版本库都通过一个称为 <code>origin</code> 的远程版本库, 建立一个链接指回它的父版本库, 但是, 原始版本库并不知道任何克隆版本库, 也不维护指向克隆版本库的链接, 这是一个单向关系</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 查看远程版本库列表</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">cd</span> dev.git</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git remote -v</span></span><br><span class="line">origin  file:///d/bare.git (fetch)</span><br><span class="line">origin  file:///d/bare.git (push)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> origin这个名称并没有什么特别之处, 如果不想使用它, 只须在克隆操作过程中通过--origin选项指定替代名</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git <span class="built_in">clone</span> -o &lt;name&gt; &lt;repository&gt; &lt;directory&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git <span class="built_in">clone</span> --origin &lt;name&gt; &lt;repository&gt; &lt;directory&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 修改链接远程版本库的名称</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git remote rename &lt;old&gt; &lt;new&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用文件协议的共享方式的优点在如今许多企业环境都已经部署有现成的网络共享设备, 以作为其文件共享系统的一部分, 这对于部署一个中央版本库来说, 无疑是方便的选择, 而缺点则在于当开发人员的工作地点与中央版本库不在同一位置上时, 这个选项就很难设置了, 而且在 Git 中, 文件访问并不是最有效的一种方式</p>
</blockquote>
<h3 id="协议">协议</h3>
<h4 id="daemon">daemon</h4>
<p>标准的 Git 安装包中都会内置一个服务器程序, 该程序提供了一种简单的网络协议来访问版本库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: daemon</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git daemon --base-path=/d --<span class="built_in">enable</span>=receive-pack</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --base-path=&lt;path&gt; 指定基本路径, 使URL不依赖于特定的目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --<span class="built_in">enable</span>=receive-pack 默认导出的版本库只有读权限, 使用此选项打开写权限</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例: 在基于服务器的项目中配置</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">cd</span> bare.git</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> touch git-daemon-export-ok  <span class="comment"># 该文件允许Git提供无需授权的项目访问服务</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 克隆版本库</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git <span class="built_in">clone</span> git://127.0.0.1/bare.git dev.git</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">cd</span> dev.git</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git ls-remote  <span class="comment"># 显示远程版本库的引用列表</span></span></span><br><span class="line">From git://127.0.0.1/bare.git</span><br><span class="line">e9fa0ffc1cb77bf75b1f224d5f1e22a3f2739576        refs/heads/master</span><br></pre></td></tr></table></figure>
<blockquote>
<p>详情参考 <a href="https://git-scm.com/book/zh/v2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-Git-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B">daemon</a></p>
<p>Git deamon 提供了有效快速的从中央版本库中传输数据的方式, 而其缺点则是缺少用户验证的功能, 除此之外, 由于需要设置共享端口, 所以需要考虑防火墙的问题</p>
</blockquote>
<h4 id="http">http</h4>
<p>标准的 Git 安装包中自带一个 CGI 脚本, 该脚本允许经由 Web 服务器来访问版本库</p>
<blockquote>
<p>详情参考 <a href="https://git-scm.com/book/zh/v2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-Smart-HTTP">http</a></p>
<p>在 Web 环境中访问版本库是非常方便的, 如果还想让它更安全一点, 可以使用 https 协议, 另外, 用户认证也可以通过 Web 服务器来完成, 而其缺点在于, 需要一个 Web 服务器, 并且要经由它来进行操作和管理</p>
</blockquote>
<h4 id="ssh">ssh</h4>
<p>为了能使用 ssh 来共享版本库, 必须至少要有一台安装了 ssh 服务的计算机, 所有项目参与者要有这台服务器上的 ssh 账户, 将包含项目文件的裸版本库复制到主机上</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 配置服务器</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> adduser git  <span class="comment"># 添加用户</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例: 复制版本库到主机上</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> scp bare.git git@127.0.0.1:/shared/bare.git</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 克隆版本库</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git <span class="built_in">clone</span> ssh://git@127.0.0.1:/shared/bare.git dev.git</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>详情参考 <a href="https://www.openssh.com/">openssh</a> <a href="https://git-scm.com/book/zh/v2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E9%85%8D%E7%BD%AE%E6%9C%8D%E5%8A%A1%E5%99%A8">ssh</a></p>
<p>通过这种方法, 可以快速搭建一个具有读写权限, 面向多个开发人员的 Git 服务器, 需要注意的是, 目前所有开发人员都能以系统用户 <code>git</code> 的身份登录服务器, 需要额外修改配置加以限制</p>
</blockquote>
<h3 id="gitlab">GitLab</h3>
<p><a href="https://about.gitlab.com/">GitLab</a> 是一个数据库支持的 Web 应用, 相比于其他 Git 服务器, 它的安装过程涉及到更多的东西, GitLab 作为一个成熟的系统, 它提供了许多其他产品帮助协同工作, 服务器设置和运行以后, 绝大多数的管理和日常使用都可以在浏览器界面中完成</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: install</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> docker run --detach \</span></span><br><span class="line"><span class="bash">	--hostname 127.0.0.1 \</span></span><br><span class="line"><span class="bash">	--publish 443:443 --publish 80:80 --publish 22:22 \</span></span><br><span class="line"><span class="bash">	--name gitlab \</span></span><br><span class="line"><span class="bash">	--restart always \</span></span><br><span class="line"><span class="bash">	--volume <span class="variable">$GITLAB_HOME</span>/config:/mnt/d/gitlab/config \</span></span><br><span class="line"><span class="bash">	--volume <span class="variable">$GITLAB_HOME</span>/logs:/mnt/d/gitlab/logs \</span></span><br><span class="line"><span class="bash">	--volume <span class="variable">$GITLAB_HOME</span>/data:/mnt/d/gitlab/data \</span></span><br><span class="line"><span class="bash">	gitlab/gitlab-ce:latest</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>详情参考 <a href="https://git-scm.com/book/zh/v2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-GitLab">gitlab</a> <a href="https://docs.gitlab.com/omnibus/settings/README.html">configure</a></p>
<p>如果不设立自己的 Git 服务器, 可以选择将 Git 项目托管到外部专业的托管网站, 参考列表 <a href="https://git.wiki.kernel.org/index.php/GitHosting">git hosting</a></p>
</blockquote>
<h2 id="文件包">文件包</h2>
<h3 id="补丁">补丁</h3>
<p>在有些情况下, 无法使用 Git 协议在版本库间交换数据时, Git 提供了以 <strong>补丁(patch)</strong> 的形式, 通常通过 email 来进行数据交换</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 生成补丁</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git format-patch &lt;until&gt;..&lt;since&gt;  <span class="comment"># 指定提交范围, 不包含范围起点</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git format-patch -&lt;n&gt;  <span class="comment"># 为最近n次提交生成补丁</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认情况下, Git为每个提交生成单独的补丁文件, 用一序列数字加上提交的日志消息为其命名</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例: 生成最近一次提交的补丁</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git format-path -1</span></span><br><span class="line">0001-fix_update.patch</span><br></pre></td></tr></table></figure>
<p>格式化的补丁一般是要通过电子邮件发送的, 可以直接使用电子邮件用户代理(Mail User Agent, MUA), 或者执行 Git 命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 配置SMTP, 以163为例</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git config --global sendemail.smtpServer smtp.163.com</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git config --global sendemail.smtpEncryption ssl</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git config --global sendemail.smtpServerPort 465</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git config --golbal sendemail.smtpPass xxxx</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>有许多选项来解决 SMTP 功能或问题, 将特殊的 SMTP 信息记录在全局配置文件中是很方便的, 详情参考 <a href="https://git-scm.com/docs/git-config#Documentation/git-config.txt-sendemailidentity">sendemail</a></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 发送补丁</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git send-email xxxx@xx.com 0001-fix_update.patch</span></span><br></pre></td></tr></table></figure>
<p>其他开发人员通过邮件接收补丁, 储存在磁盘之后, 可以通过 Git 命令应用这些补丁</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 应用补丁</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git am 0001-fix.patch</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git am 0*.patch  <span class="comment"># 使用通配符指定多个补丁</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例: 发生冲突时可以执行的命令</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git am (--<span class="built_in">continue</span> | --skip | --abort | --quit | --show-current-patch[=(diff|raw)])</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>详情参考 <a href="https://git-scm.com/book/zh/v2/%E5%88%86%E5%B8%83%E5%BC%8F-Git-%E5%90%91%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E8%B4%A1%E7%8C%AE#_project_over_email">patch</a></p>
</blockquote>
<h3 id="打包">打包</h3>
<p>在有些情况下, 如果不希望通过补丁的方式传输数量过多的提交时, Git 提供了以 <strong>打包(bundle)</strong> 的形式, 将 <code>git push</code> 命令所传输的所有内容打包成一个二进制文件, 可以通过邮件或闪存介质传给其他人</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 打包</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git bundle create &lt;file&gt; &lt;git-rev-list-args&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成的文件包含了所有重建该版本库分支所需的数据</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例: 打包master分支</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git bundle create bare.bundle HEAD master</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 从包中克隆版本库</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git <span class="built_in">clone</span> bare.bundle dev</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>详情参考 <a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E6%89%93%E5%8C%85">bundle</a></p>
</blockquote>
<h3 id="归档">归档</h3>
<p>Git 提供了归档命令将项目的内容导出, 创建一个不带 Git 元数据(即不包含 <code>.git</code> 目录) 的压缩包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 归档</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git archive &lt;tree-ish&gt; --format=&lt;fmt&gt; -o &lt;file&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例: 归档zip文件</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git archive HEAD --format=zip -o release.zip</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git archive HEAD target -o target.tar  <span class="comment"># 归档指定子目录</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>详情参考 <a href="https://git-scm.com/book/zh/v2/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-Git-%E5%B1%9E%E6%80%A7#_%E5%AF%BC%E5%87%BA%E7%89%88%E6%9C%AC%E5%BA%93">archive</a></p>
</blockquote>
<h2 id="扩展">扩展</h2>
<h3 id="环境变量">环境变量</h3>
<p>像通常的程序一样, Git 的常规行为依赖于环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 环境变量: 全局行为</span></span><br><span class="line">GIT_EXEC_PATH  # Git子程序的位置</span><br><span class="line">GIT_PAGER      # 控制在命令行上显示多页输出的程序</span><br><span class="line">GIT_EDITOR     # Git编辑器</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 环境变量: 版本库</span></span><br><span class="line">GIT_DIR                  # .git目录的位置</span><br><span class="line">GIT_CEILING_DIRECTORIES  # 控制查找.git目录的行为</span><br><span class="line">GIT_WORK_TREE            # 非空版本库的工作目录的根目录</span><br><span class="line">GIT_INDEX_FILE           # 索引文件的路径</span><br><span class="line">GIT_OBJECT_DEIRECTORY    # .git/objects目录的位置</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 环境变量: 路径规划</span></span><br><span class="line">GIT_GLOB_PATHSPECS     # 控制通配符在路径规划中的默认行为, 使用通配符模式</span><br><span class="line">GIT_NOGLOB_PATHSPECS   # 控制通配符在路径规划中的默认行为, 不使用通配符模式</span><br><span class="line">GIT_LITERAL_PATHSPECS  # 禁用上面的两种行为</span><br><span class="line">GIT_ICASE_PATHSPECS    # 让所有的路径规范忽略大小写</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 环境变量: 提交</span></span><br><span class="line">GIT_AUTHOR_NAME      # author字段的可读名字</span><br><span class="line">GIT_AUTHOR_EMAIL     # author字段的邮件</span><br><span class="line">GIT_AUTHOR_DATE      # author字段的时间戳</span><br><span class="line">GIT_COMMITTER_NAME   # committer字段的可读名字</span><br><span class="line">GIT_COMMITTER_EMAIL  # committer字段的邮件</span><br><span class="line">GIT_COMMITTER_DATE   # committer字段的时间戳</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 环境变量: 网络</span></span><br><span class="line">GIT_CURL_VERBOSE          # Git使用curl库时显示详细信息</span><br><span class="line">GIT_SSL_NO_VERIFY         # 禁用验证SSL证书</span><br><span class="line">GIT_HTTP_LOW_SPEED_LIMIT  # 最低网速</span><br><span class="line">GIT_HTTP_LOW_SPEED_TIME   # 最低时间, 当操作在最低网速持续最低时间, Git会终止该操作</span><br><span class="line">GIT_HTTP_USER_AGENT       # 设置Git在请求HTTP时使用的user-agent请求头</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 环境变量: 比较和合并</span></span><br><span class="line">GIT_DIFF_OPTS          # 控制git diff命令中显示的内容行数</span><br><span class="line">GIT_EXTERNAL_DIFF      # 执行git diff时调用的程序</span><br><span class="line">GIT_MERGE_VERBOSITY    # 控制递归合并策略的输出</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 环境变量: 调试</span></span><br><span class="line">GIT_TRACE              # 控制常规跟踪</span><br><span class="line">GIT_TRACE_PACK_ACCESS  # 控制访问打包文件的跟踪信息</span><br><span class="line">GIT_TRACE_PACKET       # 打开网络操作包级别的跟踪信息</span><br><span class="line">GIT_TRACE_PERFORMANCE  # 控制性能数据的日志打印</span><br><span class="line">GIT_TRACE_SETUP        # 显示关于版本库和交互环境的信息</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 环境变量: 其它</span></span><br><span class="line">GIT_SSH            # Git连接SSH时使用的程序</span><br><span class="line">GIT_ASKPASS        # Git需要向用户请求验证时用到的程序</span><br><span class="line">GIT_NAMESPACE      # 控制有命令空间的引用的访问</span><br><span class="line">GIT_FLUSH          # 强制Git在向标准输出增量写入时使用没有缓存的I/O</span><br><span class="line">GIT_REFLOG_ACTION  # 指定描述性的文字写到reflog中</span><br></pre></td></tr></table></figure>
<blockquote>
<p>详情参考 <a href="https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">environment variables</a></p>
</blockquote>
<h3 id="钩子">钩子</h3>
<p>Git 提供 <strong>钩子(hook)</strong> 可以在特定的重要动作发生时触发自定义脚本, 钩子只属于并作用于一个特定的版本库, 在克隆操作的时候不会复制, 钩子被存储在 <code>.git/hooks</code> 目录中, 当使用 <code>git init</code> 初始化一个新版本库时, Git 默认会在这个目录中放置一些示例脚本, 这些示例的名字都是以 <code>.sample</code> 结尾, 如果想启用它们, 得先移除这个后缀, 钩子分为以下两类:</p>
<p><strong>客户端</strong> 客户端钩子由诸如提交和合并这样的操作所调用;</p>
<p><strong>服务器端</strong> 服务器端钩子作用于诸如接收被推送的提交这样的联网操作</p>
<blockquote>
<p>可用的钩子列表 <a href="https://git-scm.com/docs/githooks#_hooks">hooks</a></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 文件: .git/hooks/pre-commit</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">idea.bat format -r src  # 使用idea格式化代码</span><br><span class="line">git add .</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 提交</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git commit -m <span class="string">&quot;fix: format&quot;</span></span></span><br><span class="line">IntelliJ IDEA 2020.3.2, build IU-203.7148.57 Formatter</span><br><span class="line">2021-02-04 15:49:52,149 [   2558]   WARN - roject.impl.ProjectManagerImpl - Do not open project in EDT</span><br><span class="line">Formatting D:/dev.git/src/main/java/com/janz/demo/App.java...OK</span><br><span class="line">Formatting D:/dev.git/src/test/java/com/janz/demo/AppTest.java...OK</span><br><span class="line"></span><br><span class="line">2 file(s) formatted.</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>
<blockquote>
<p>详情参考 <a href="https://git-scm.com/book/zh/v2/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-Git-%E9%92%A9%E5%AD%90">hook</a> <a href="https://typicode.github.io/husky/">husky</a></p>
</blockquote>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>GraphQL 入门</title>
    <url>/2021/05/17/graphql%20001/</url>
    <content><![CDATA[<h1 id="入门">入门</h1>
<p><a href="https://graphql.org/">GraphQL</a> 是一种用于 API 的查询语言, 也是一个满足数据查询的运行时, GraphQL 对 API 中的数据提供了一套易于理解的完整描述, 使得客户端能够准确的获得它需要的数据, 而且没有任何冗余, 也让 API 更容易的随着时间推移而演进, 规范详见 <a href="https://spec.graphql.cn/">spec</a></p>
<h2 id="schema">Schema</h2>
<p>GraphQL 使用模板定义语言(Schema Definitin Language, SDL) 用于定义强类型的文档, 无论使用何种语言或框架构建应用程序, GraphQL SDL 都是相同的, GraphQL Schema 定义了应用程序中的可用类型, 服务端和客户端通过它来验证 GraphQL 请求</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;文件: schema.graphql&quot;</span></span><br><span class="line">schema &#123;</span><br><span class="line">    query: Query           <span class="string">&quot;操作类型&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">type Query &#123;               <span class="string">&quot;定义初始类型&quot;</span></span><br><span class="line">    hero(<span class="name">id:</span> ID): Hero</span><br><span class="line">&#125;</span><br><span class="line">type Hero &#123;                <span class="string">&quot;定义对象类型&quot;</span></span><br><span class="line">    id: ID!                <span class="string">&quot;ID用于对象类型中的唯一标识符&quot;</span></span><br><span class="line">    name: String!          <span class="string">&quot;感叹号表示字段是非空字段&quot;</span></span><br><span class="line">    appearsIn: [<span class="name">Episode</span>]!  <span class="string">&quot;方括号用于列表字段&quot;</span></span><br><span class="line">    totalCredits: Int</span><br><span class="line">&#125;</span><br><span class="line">enum Episode &#123;             <span class="string">&quot;定义枚举类型&quot;</span></span><br><span class="line">    NEWHOPE</span><br><span class="line">    EMPIRE</span><br><span class="line">    JEDI</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类型">类型</h3>
<p>GraphQL schema 中最基本的单元是类型, 每个 GraphQL 服务都会定义一套类型, 详见 <a href="https://spec.graphql.cn/#sec-Types-">types</a></p>
<p><strong>初始类型(initial types)</strong> 定义了 schema 的入口, GraphQL 有 3 种初始类型, 详见 <a href="https://spec.graphql.cn/#sec-Initial-types-">initial</a></p>
<ul>
<li>查询(<code>Query</code>)</li>
<li>更改(<code>Mutation</code>)</li>
<li>订阅(<code>Subscription</code>)</li>
</ul>
<p><strong>标量类型(scalar types)</strong> 是最基本的类型, GraphQL 有 5 种内置的标量类型, 详见 <a href="https://spec.graphql.cn/#sec-Scalars-">scalars</a></p>
<ul>
<li>整数(<code>Int</code>)</li>
<li>浮点数(<code>Float</code>)</li>
<li>字符串(<code>String</code>)</li>
<li>布尔值(<code>Boolean</code>)</li>
<li>唯一标识符(<code>ID</code>)</li>
</ul>
<p>枚举类型(<code>Enum</code>) 是基于标量类型的变体, 其表示可能值的一个有限集, 详见 <a href="https://spec.graphql.cn/#sec-Enums-">enum</a></p>
<p>在 GraphQL 服务实现中, 可以有自定义标量类型的方式, 详见 <a href="https://graphql.cn/learn/schema/#scalar-types">define</a></p>
<h3 id="接口">接口</h3>
<p>GraphQL 接口表示一个具名字段列表以及其参数, GraphQL 对象可以实现接口, 并保证包含接口中的字段, 接口上的字段拥有和对象上相同的规则, 详见 <a href="https://spec.graphql.cn/#sec-Interfaces-">interfaces</a></p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">interface Character &#123;  <span class="string">&quot;定义接口&quot;</span></span><br><span class="line">    id: ID!</span><br><span class="line">    name: String!</span><br><span class="line">&#125;</span><br><span class="line">type Human implements Character &#123;</span><br><span class="line">    id: ID!</span><br><span class="line">    name: String!</span><br><span class="line">    totalCredits: Int</span><br><span class="line">&#125;</span><br><span class="line">type Droid implements Character &#123;</span><br><span class="line">    id: ID!</span><br><span class="line">    name: String!</span><br><span class="line">    primaryFunction: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="联合">联合</h3>
<p>GraphQL 联合表示一个对象的类型是对象类型列表中之一, 但不保证这些类型之间的字段, 另一个区别于接口的方面是, 对象会声明其实现的接口, 而不知道它被包含的联合, 详见 <a href="https://spec.graphql.cn/#sec-Unions-">unions</a></p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">type Query &#123;</span><br><span class="line">    search(<span class="name">name:</span> String!): [<span class="name">SearchResult!</span>]!</span><br><span class="line">&#125;</span><br><span class="line">union SearchResult = Human | Droid | Starship  <span class="string">&quot;定义联合类型&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="参数">参数</h3>
<p>GraphQL 对象类型上的每个字段都可以有零个或者多个参数, 所有参数都是具名的, 可以是必选或者可选的, 当一个参数可选时, 可以定义其默认值, 详见 <a href="https://graphql.cn/learn/schema/#arguments">arguments</a></p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">type Starship &#123;</span><br><span class="line">    id: ID!</span><br><span class="line">    name: String!</span><br><span class="line">    length(<span class="name">unit:</span> LengthUnit = METER): Float  <span class="string">&quot;可选参数且定义默认值&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输入对象">输入对象</h3>
<p>GraphQL 也可以使用复杂对象作为参数, 输入对象定义了输入字段的一个集合, 这在更改中特别有用, 因为有时候需要传递整个对象作为更改的参数, 详见 <a href="https://spec.graphql.cn/#sec-Input-Objects-">input-objects</a></p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">type Mutation &#123;</span><br><span class="line">    createReview(<span class="name">review:</span> ReviewInput!): Review</span><br><span class="line">&#125;</span><br><span class="line">input ReviewInput &#123;  <span class="string">&quot;定义输入类型&quot;</span></span><br><span class="line">    stars: Int!</span><br><span class="line">    commentary: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="文档">文档</h3>
<p>在编写 GraphQL Schema 时, 可以为每个字段添加注释, 从而解释 schema 的类型和字段, 写好文档注释无疑可以帮助开发团队和其它用户理解项目的类型系统, 并且在使用相关的 GraphQL 可视化工具时, 也可以通过内省查询来查看这些描述</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">三个双引号添加多行注释</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;一个双引号添加单行注释&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="内省">内省</h3>
<p>GraphQL 服务端支持基于 schema 来支持内省, 内省查询遵循 GraphQL 查询语言的规则, 可通过查询操作的根级类型上的元数据来接入, 详见 <a href="https://spec.graphql.cn/#sec-Introspection-">introspection</a></p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;查看schema中定义的类型&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    __schema &#123;</span><br><span class="line">        types &#123;</span><br><span class="line">            name</span><br><span class="line">            description</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;查看Hero对象类型的字段&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    __type(<span class="name">name:</span> <span class="string">&quot;Hero&quot;</span>) &#123;</span><br><span class="line">        name</span><br><span class="line">        fields &#123;</span><br><span class="line">            name</span><br><span class="line">            type &#123;</span><br><span class="line">                name</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="请求">请求</h2>
<p>GraphQL 服务运行起来, 它就能接收 GraphQL 请求, 并验证和执行, 接收到的请求首先会被检查确保它只引用了已定义的类型和字段, 然后运行指定的解析函数来生成结果</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">query HeroIdAndName &#123;  <span class="string">&quot;操作类型和名称&quot;</span></span><br><span class="line">    hero &#123;             <span class="string">&quot;选择集&quot;</span></span><br><span class="line">        id</span><br><span class="line">        name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>操作类型可以是 <code>query</code>, <code>mutation</code>, <code>subscription</code>, 对应 GraphQL Schema 初始类型定义的入口</p>
<p>操作名称是有意义和明确的名称, 详见 <a href="https://graphql.cn/learn/queries/#operation-name">operation-name</a></p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;操作类型和名称可以省略, 简化为以下示例&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    hero &#123;</span><br><span class="line">        id</span><br><span class="line">        name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>操作类型和名称仅在多个操作的文档中是必需的, 但是鼓励使用, 因为它对于调试和日志记录非常有用, 当网络或是服务端的日志中出现问题时, 通过名称来从代码中找到相关请求更容易</p>
</blockquote>
<h3 id="查询">查询</h3>
<p>编写查询时, 把需要的字段用大括号括起来, 这些块被称为选择集(selection set), 在选择集内定义的字段和 GraphQL 类型直接相关, 可以通过指定别名来更改查询结果中返回对象的字段名称</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    empireHero: hero &#123;  <span class="string">&quot;字段设置别名&quot;</span></span><br><span class="line">        id</span><br><span class="line">        name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="片段">片段</h4>
<p>片段是可以在多个操作中重用的选择集, 使用片段的好处是, 可以通过修改一个片段来同时修改许多个用于不同查询的选择集, 详见 <a href="https://graphql.cn/learn/queries/#fragments">fragments</a></p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    leftComparison: hero(<span class="name">episode:</span> EMPIRE) &#123;</span><br><span class="line">        ...comparisonFields</span><br><span class="line">    &#125;</span><br><span class="line">    rightComparison: hero(<span class="name">episode:</span> JEDI) &#123;</span><br><span class="line">        ...comparisonFields</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fragment comparisonFields on Character &#123;  <span class="string">&quot;定义具名片段&quot;</span></span><br><span class="line">    name</span><br><span class="line">    appearsIn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="内联片段">内联片段</h4>
<p>查询的字段返回的是接口或者联合类型时, 需要使用内联片段来取出具体类型的数据, 详见 <a href="https://graphql.cn/learn/queries/#inline-fragments">inline-fragments</a></p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">query Hero &#123;</span><br><span class="line">    hero &#123;</span><br><span class="line">        name</span><br><span class="line">        __typename           <span class="string">&quot;通过元数据获取对象的类型名称&quot;</span></span><br><span class="line">        ... on Droid &#123;       <span class="string">&quot;类型为Droid时返回此字段&quot;</span></span><br><span class="line">            primaryFunction</span><br><span class="line">        &#125;</span><br><span class="line">        ... on Human &#123;       <span class="string">&quot;类型为Human时返回此字段&quot;</span></span><br><span class="line">            height</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="变量">变量</h4>
<p>在应用中, 字段的参数可能是动态的, 将这些动态参数直接传进查询字符串并不是好主意, GraphQL 支持将动态值提取到查询之外, 作为分离的字典传进去, 这些动态值即称为变量, 详见 <a href="https://graphql.cn/learn/queries/#variables">variables</a></p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">query Hero(<span class="name">$episode:</span> Episode = <span class="string">&quot;JEDI&quot;</span>) &#123;</span><br><span class="line">    hero(<span class="name">episode:</span> $episode) &#123;  <span class="string">&quot;变量episode可选, 且默认值为JEDI&quot;</span></span><br><span class="line">        name</span><br><span class="line">        friends &#123;</span><br><span class="line">            name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="指令">指令</h4>
<p>GraphQL 提供了称为指令的特性, 指令可以附着在字段或者片段包含的字段上, 然后以任何服务端期待的方式来改变查询的执行, GraphQL 的核心规范包含两个指令:</p>
<ul>
<li><code>@include(if: Boolean)</code> 仅在参数为 <code>true</code> 时, 包含此字段</li>
<li><code>@skip(if: Boolean)</code> 如果参数为 <code>true</code> 时, 跳过此字段</li>
</ul>
<p>服务端实现也可以定义新的指令来添加新的特性, 详见 <a href="https://graphql.cn/learn/queries/#directives">directives</a></p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">query Hero(<span class="name">$withFriends:</span> Boolean!) &#123;</span><br><span class="line">    hero &#123;</span><br><span class="line">        name</span><br><span class="line">        friends @include(<span class="name">if:</span> $withFriends) &#123;  <span class="string">&quot;参数变量为true时, 包含此字段&quot;</span></span><br><span class="line">            name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="变更">变更</h3>
<p>如同查询一样, 变更操作可以返回一个选择集, 获取对象变更后的新状态也是十分有用的, 不同之处在于, 变更操作对数据的更改会影响服务端的数据状态, 详见 <a href="https://graphql.cn/learn/queries/#mutations">mutation</a></p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">mutation CreateReviewForEpisode(<span class="name">$review:</span> ReviewInput!) &#123;</span><br><span class="line">    createReview(<span class="name">review:</span> $review) &#123;</span><br><span class="line">        stars</span><br><span class="line">        commentary</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="订阅">订阅</h3>
<p>订阅功能允许客户端监听 GraphQL API 以进行实时的数据更改, 订阅是保持开放的, 新的数据变更都会推送到该订阅, 若要停止监听需要取消订阅, 详见 <a href="https://spec.graphql.cn/#sec-Subscription-">subscription</a></p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">subscription HeroMonitor &#123;</span><br><span class="line">    hero &#123;</span><br><span class="line">        name</span><br><span class="line">        appearsIn</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="响应">响应</h2>
<p>GraphQL 服务端会返回一个良好格式化的响应, 如果请求操作执行成功, 服务端的响应则描述其执行结果, 否则描述执行期间遇到的错误, 详见 <a href="https://spec.graphql.cn/#sec-Response-">response</a></p>
<p>GraphQL 并不要求特定的序列化格式, 然而客户端应该使用一种支持 GraphQL 响应中的映射集类型的序列化格式, 特别需要支持一下原始类型, 通常偏好于使用 Json 序列化方式</p>
<h3 id="数据">数据</h3>
<p>响应中的 <code>data</code> 条目是请求操作执行的结果, 如果在执行前遇到错误, 结果中将不应有 <code>data</code> 条目, 如果在执行中遇到错误, 并导致不能返回有效响应, 则 <code>data</code> 条目应该为 <code>null</code></p>
<h3 id="错误">错误</h3>
<p>响应中的 <code>errors</code> 是一个非空错误列表, 每个错误是一个映射集, 如果在执行请求的操作中未遇到错误, 结果中将不应有 <code>errors</code> 条目, 如果响应结果中没有 <code>data</code> 条目, 则响应中的 <code>errors</code> 条目不可为空, 其必须包含至少一条错误, 这个错误应指出为什么没有数据返回</p>
<p>每个错误都必须包含键为 <code>message</code> 的条目, 其包含了针对开发的错误描述, 以便修正错误</p>
<p>如果一个错误能和请求的 GraphQL 文档特定点所匹配, 它应该包含键为 <code>locations</code> 的条目, 其内容为一个定位列表, 每个定位都是键为 <code>line</code> 和 <code>column</code> 的映射集, 两者都是从 <code>1</code> 开始的正数, 用以描述相关的语法元素的起始位置</p>
<p>如果一个错误能和 GraphQL 结果中的特定字段关联, 它必须包含键为 <code>path</code> 的条目, 其描述了响应中面临错误的字段, 这能让客户端鉴别一个 <code>null</code> 是正常逻辑还是运行时错误</p>
<h3 id="扩展">扩展</h3>
<p>响应可以包含键为 <code>extensions</code> 的条目, 此条目是作为协议扩展而为实现者保留的, 因此并没有对其内容附加限制要求</p>
<h2 id="工具">工具</h2>
<p>GraphQL 已有多种编程语言支持, <a href="https://graphql.cn/code/">code</a> 包含一些流行的服务端框架, 客户端库, 服务和其它有用的内容</p>
<p><a href="https://github.com/graphql/graphiql">GraphiQL</a> 是由 Facebook 创建的浏览器内的集成开发环境(IDE), 方便开发人员查询和浏览 GraphQL API, 提供语法高亮显示, 代码完成和错误警告, 可以在浏览器中直接运行并查看查询结果</p>
<p><a href="https://www.graphql-java.com/tutorials/getting-started-with-spring-boot/">GraphQL-Java</a> 是 GraphQL 的 Java 实现, 其中 GraphQL Java Engine 引擎只关心执行查询, 它本身不处理任何 Http 或 Json 相关的主题, 而是通过使用 <a href="https://github.com/graphql-java/graphql-java-spring">graphql-java-spring</a> 的适配器, 从而实现与 Spring Web 的集成</p>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>GraphQL</tag>
      </tags>
  </entry>
  <entry>
    <title>GraphQL 接口</title>
    <url>/2021/05/20/graphql%20003/</url>
    <content><![CDATA[<h1 id="接口">接口</h1>
<p>使用 GraphQL 时, 最常见被选用的跨端协议是 HTTP, 通常使用单个端点来提供服务的完整功能, 服务通常使用文本格式的 Json 语法返回数据, <a href="https://graphql.cn/learn/serving-over-http/">serving-over-http</a> 页面提供了使用 HTTP 服务的最佳实践</p>
<h2 id="准则">准则</h2>
<p>GraphQL 规范特意忽略了网络处理的问题, 但这并不意味着在使用 GraphQL 时没有针对这些问题的解决方案, 可代以工程上通行的准则来实现, 这些准则是基于服务端与 <a href="https://relay.dev/">relay</a> 客户端兼容来写的, 但是对于任何客户端都有用</p>
<h3 id="路由">路由</h3>
<p>GraphQL 服务在单个入口端点, 通常是 <code>/graphql</code> 上运行, 并且所有提供服务的 GraphQL 请求都应被导向此入口端点</p>
<blockquote>
<p>虽然 GraphQL 也可以暴露多个资源端点, 但这可能导致开发人员在使用 GraphiQL 等工具时遇到困难</p>
</blockquote>
<h3 id="请求">请求</h3>
<p>GraphQL 服务应能够处理 <code>GET</code> 和 <code>POST</code> 方法</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET /graphql?query=&amp;operationName=&amp;variables=</span><br></pre></td></tr></table></figure>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">POST /graphql</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &quot;&quot;,</span><br><span class="line">    &quot;operationName&quot;: &quot;&quot;,</span><br><span class="line">    &quot;variables&quot;: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常建议支持另外两种情况:</p>
<ol type="1">
<li>如果存在 <code>query</code> 这个查询字符串参数, 则应当以与 <code>GET</code> 相同的方式进行解析和处理</li>
<li>如果存在 <code>Content-Type: application/graphql</code> 请求头, 则将 <code>POST</code> 请求体内容视为 GraphQL 查询字符串</li>
</ol>
<h3 id="响应">响应</h3>
<p>无论使用任何方法发送查询和变量, 响应都应当以 Json 格式返回, 注意需按 <a href="https://spec.graphql.cn//#sec-Data-">规范</a> 的条目规则</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 响应结构</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: &#123;&#125;,    <span class="comment">// 请求执行成功时返回的选择集对象</span></span><br><span class="line">    <span class="attr">&quot;errors&quot;</span>: [],  <span class="comment">// 请求执行失败时返回的错误条目</span></span><br><span class="line">    <span class="attr">&quot;extensions&quot;</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="示例">示例</h2>
<p>GraphQL 接口开发, 参考 <a href="https://github.com/facebook/relay">facebook-relay</a> <a href="https://github.com/apollographql/apollo">apollo</a></p>
<p>GraphQL-Java 开发示例, 参考 <a href="https://github.com/graphql-java/graphql-java-examples">graphql-java-examples</a></p>
<ol type="1">
<li>Http 集成示例 <a href="https://github.com/graphql-java/graphql-java-examples/blob/master/spring-boot-integration/README.md">example</a></li>
<li>Http 使用数据加载器 <code>DataLoader</code>, 跟踪器 <code>instrumentatin</code> 的示例 <a href="https://github.com/graphql-java/graphql-java-examples/blob/master/http-example/readme.md">example</a></li>
<li>使用套接字提供订阅功能的示例 <a href="https://github.com/graphql-java/graphql-java-examples/blob/master/subscription-example/readme.md">example</a></li>
<li>使用响应流提供订阅功能, 延迟字段的示例 <a href="https://github.com/graphql-java/graphql-java-examples/blob/master/defer/server/README.md">example</a></li>
<li>Hibernate 集成示例 <a href="https://github.com/graphql-java/graphql-java-examples/blob/master/hibernate-example/readme.md">example</a></li>
<li>通过优化检查配置, 限制客户端滥用查询的示例 <a href="https://github.com/graphql-java/graphql-java-examples/blob/master/performance-checks/README.md">example</a></li>
</ol>
<h3 id="校验">校验</h3>
<p>GraphQL-Java 提供了字段和参数的扩展校验 <a href="https://github.com/graphql-java/graphql-java-extended-validation">extended-validation</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 示例: Maven配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.graphql-java<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>graphql-java-extended-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;latest-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>支持的校验指令, 详见 <a href="https://github.com/graphql-java/graphql-java-extended-validation#the-supplied-directive-constraints">directive-constrains</a></p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;示例: 引入需要的校验指令&quot;</span></span><br><span class="line">directive @Size(<span class="name">min:</span> Int = <span class="number">0</span>, max: Int = <span class="number">2147483647</span>, message: String = <span class="string">&quot;graphql.validation.Size.message&quot;</span>) on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION</span><br><span class="line">type Query &#123;</span><br><span class="line">    <span class="string">&quot;在字段或参数上添加校验指令&quot;</span></span><br><span class="line">    hero(<span class="name">id:</span> ID @Size(<span class="name"><span class="builtin-name">min</span></span> : <span class="number">3</span>, max: <span class="number">2048</span>)): Hero</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 配置 */</span></span><br><span class="line">ValidationRules validationRules = ValidationRules.newValidationRules()</span><br><span class="line">    <span class="comment">// 校验失败的策略, 此处为校验失败时数据date将返回null</span></span><br><span class="line">    .onValidationErrorStrategy(OnValidationErrorStrategy.RETURN_NULL)</span><br><span class="line">    .build();</span><br><span class="line">ValidationSchemaWiring schemaWiring = <span class="keyword">new</span> ValidationSchemaWiring(validationRules);</span><br><span class="line">RuntimeWiring runtime = RuntimeWiring.newRuntimeWiring()</span><br><span class="line">    .directiveWiring(schemaWiring)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 执行校验失败的结果 */</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;errors&quot;</span> : [ &#123;</span><br><span class="line">    <span class="attr">&quot;message&quot;</span> : <span class="string">&quot;/hero/id size must be between 3 and 2048&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;locations&quot;</span> : [ &#123;</span><br><span class="line">      <span class="attr">&quot;line&quot;</span> : <span class="number">2</span>,</span><br><span class="line">      <span class="attr">&quot;column&quot;</span> : <span class="number">3</span></span><br><span class="line">    &#125; ],</span><br><span class="line">    <span class="attr">&quot;path&quot;</span> : [ <span class="string">&quot;hero&quot;</span> ],</span><br><span class="line">    <span class="attr">&quot;extensions&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;classification&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;ExtendedValidationError&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;validatedPath&quot;</span> : [ <span class="string">&quot;hero&quot;</span>, <span class="string">&quot;id&quot;</span> ],</span><br><span class="line">        <span class="attr">&quot;constraint&quot;</span> : <span class="string">&quot;@Size&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; ],</span><br><span class="line">  <span class="attr">&quot;data&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;hero&quot;</span> : <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="集成">集成</h3>
<p>GraphQL-Java-Spring 集成开发, 参考 <a href="https://github.com/graphql-java/graphql-java-spring">graphql-java-spring</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 示例: Maven配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  <span class="comment">&lt;!--webmvc--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.graphql-java<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>graphql-java-spring-boot-starter-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;latest-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  <span class="comment">&lt;!--webflux--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.graphql-java<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>graphql-java-spring-boot-starter-webflux<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;latest-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置文件</span></span><br><span class="line"><span class="attr">graphql:</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/graphql</span></span><br></pre></td></tr></table></figure>
<h3 id="测试">测试</h3>
<p>测试基于 Junit5 框架</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 测试 */</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> GraphQLController controller;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MockMvc mockMvc = MockMvcBuilders.standaloneSetup(controller)</span><br><span class="line">        .alwaysDo(MockMvcResultHandlers.print())  <span class="comment">// 打印测试的结果</span></span><br><span class="line">        .build();</span><br><span class="line">    String query = <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        hero(id: &quot;</span><span class="number">1</span><span class="string">&quot;) &#123;</span></span><br><span class="line"><span class="string">            id</span></span><br><span class="line"><span class="string">            name</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// GET方式</span></span><br><span class="line">    mockMvc.perform(get(<span class="string">&quot;/graphql&quot;</span>)</span><br><span class="line">             .param(<span class="string">&quot;query&quot;</span>, query))</span><br><span class="line">        .andExpect(status().isOk());</span><br><span class="line">    <span class="comment">// POST方式</span></span><br><span class="line">    mockMvc.perform(post(<span class="string">&quot;/graphql&quot;</span>)</span><br><span class="line">            .header(HttpHeaders.CONTENT_TYPE, <span class="string">&quot;application/graphql&quot;</span>))</span><br><span class="line">            .content(query)</span><br><span class="line">        .andExpect(status().isOk());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="graphiql">GraphiQL</h2>
<p><a href="https://github.com/graphql-java-kickstart/graphql-spring-boot">GraphiQL-Spring-Boot</a> 嵌入 GraphiQL 工具用于内省和查询, GraphiQL 在测试和开发过程中非常有用, 但在生产环境下应当默认被禁用</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 示例: Maven配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.graphql-java-kickstart<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>graphql-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;latest-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.graphql-java-kickstart<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>graphiql-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;latest-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置文件</span></span><br><span class="line"><span class="attr">graphiql:</span></span><br><span class="line">  <span class="attr">mapping:</span> <span class="string">/graphiql</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">graphql:</span> <span class="string">/graphql</span></span><br><span class="line">    <span class="attr">subscriptions:</span> <span class="string">/subscriptions</span></span><br><span class="line">  <span class="attr">subscriptions:</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">30</span></span><br><span class="line">    <span class="attr">reconnect:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">basePath:</span> <span class="string">/</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">pageTitle:</span> <span class="string">GraphiQL</span></span><br><span class="line">  <span class="attr">cdn:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">latest</span></span><br><span class="line">  <span class="attr">props:</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">query:</span> <span class="string">query.graphql</span></span><br><span class="line">      <span class="attr">defaultQuery:</span> <span class="string">defaultQuery.graphql</span></span><br><span class="line">      <span class="attr">variables:</span> <span class="string">variables.graphql</span></span><br><span class="line">    <span class="attr">variables:</span></span><br><span class="line">      <span class="attr">editorTheme:</span> <span class="string">&quot;solarized light&quot;</span></span><br><span class="line">  <span class="attr">headers:</span></span><br><span class="line">    <span class="attr">Authorization:</span> <span class="string">&quot;Bearer &lt;your-token&gt;&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开发</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>GraphQL</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>gRPC 入门</title>
    <url>/2021/03/01/grpc%20001/</url>
    <content><![CDATA[<h1 id="入门">入门</h1>
<p><strong>gRPC</strong> 是一项进程间通信技术, 可以用来连接, 调用, 操作和调试分布式异构应用程序</p>
<h2 id="简介">简介</h2>
<p>在开发 gRPC 应用程序时, 先要定义服务接口, 借助服务定义, 可以生成服务端代码 (骨架 skeleton), 它通过提供低层级的通信抽象简化了服务端的逻辑, 同时, 还可以生成客户端代码 (存根 stub), 它使用抽象简化了客户端的通信, 为不同的编程语言隐藏了低层级的通信</p>
<pre class="mermaid">flowchart LR
TITLE["图 基于gRPC的微服务"]
A(服务定义)
subgraph 提供者
    B(服务端骨架)
end
subgraph 消费者
    C(客户端存根)
end
TITLE --- B
A -.生成.-> B
A -.生成.-> C
B <--protocol buffers--> C

style TITLE fill:#FFF,stroke:#FFF
linkStyle 0 stroke:#FFF,stroke-width:0;</pre>
<p>gRPC 主要有以下几个优势:</p>
<ul>
<li><p>提供高效的进程间通信</p>
<p>gRPC 在 HTTP/2 之上实现了基于 protocol buffers 的二进制协议, 从而能够更快的处理进程间的通信</p></li>
<li><p>强类型的接口定义</p>
<p>gRPC 为应用程序开发提供了一种契约优先的方式, 首先必须定义服务接口, 然后才能去处理实现细节, 使用静态类型可以避免程序运行时或互操作产生的大多数错误</p></li>
<li><p>支持多语言</p>
<p>gRPC 基于 protocol buffers 的服务定义是语言中立的, 因此, 可以选择任意一种语言, 都能与现有的服务端或客户端进行互操作</p></li>
<li><p>支持双工流</p>
<p>gRPC 在服务端和客户端都提供了对流的原生支持, 这些功能都被整合到了服务定义本身之中</p></li>
<li><p>内置的商业化特性</p>
<p>gRPC 提供的内置支持, 如认证加密, 弹性, 元数据交换, 负载均衡, 服务发现等, 大多数现代框架和技术也对 gRPC 提供了原生支持</p></li>
</ul>
<h3 id="服务定义">服务定义</h3>
<p>开发 gRPC 应用程序时, 要先定义服务接口, 其中包含允许远程调用的方法, 以及调用这些方法所使用的消息格式等, gRPC 使用 protocol buffers 作为接口定义语言 (interface definition language, IDL) 来定义服务接口, <a href="https://developers.google.com/protocol-buffers/">protocol-buffers</a> 是语言中立, 平台无关, 实现结构化, 数据序列化的可扩展机制, 因为服务定义是规范的扩展, 所以可以借助 gRPC 插件来根据 proto 文件生成代码</p>
<p>proto 语法指南参考 <a href="https://developers.google.com/protocol-buffers/docs/proto">proto2</a> <a href="https://developers.google.com/protocol-buffers/docs/proto3">proto3</a></p>
<p><strong>服务(service)</strong> 是暴露给客户端的远程方法集合</p>
<p><strong>消息(message)</strong> 是客户端和服务端交换的数据结构</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例: 服务定义文件</span></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;  <span class="comment">// 指定所使用的版本</span></span><br><span class="line"><span class="keyword">package</span> com.demo;   <span class="comment">// 指定包名, 避免协议消息类型之间的命名冲突</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务接口的定义</span></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">Biz</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> insert(Entity) <span class="keyword">returns</span> (Identification)</span>; <span class="comment">// 服务方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 消息结构的定义</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Identification</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int32</span> id = <span class="number">1</span>; <span class="comment">// 结构字段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Entity</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int32</span> id = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">string</span> code = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 protobuf 最直接的 RPC 框架是 <a href="https://github.com/grpc/grpc">gRPC</a>, 其它可用的第三方项目, 参考 <a href="https://github.com/protocolbuffers/protobuf/blob/master/docs/third_party.md">third party</a></p>
<h2 id="原理">原理</h2>
<p>gRPC 应用程序使用 RPC 通过网络进行通信, 对于实现 RPC 的底层细节, 所使用的消息编码技术以及在网络中的运行方式, 这些底层通信细节都是由服务定义所生成的代码实现的, 开发人员需要做的就是处理高层级的抽象</p>
<p>在设计复杂的 gRPC 应用程序或设法调试现有的应用程序时, 理解底层通信细节很有帮助</p>
<h3 id="通信">通信</h3>
<p>gRPC 应用程序的 4 种基础通信模式:</p>
<ul>
<li><p>一元 RPC</p>
<p>一元 PRC 模式也称为简单 RPC 模式, 在该模式中, 当客户端调用服务端的远程方法时, 客户端发送请求至服务端并获得一个响应</p></li>
<li><p>服务端流 RPC</p>
<p>在服务端流 RPC 模式中, 服务端在接收到客户端的请求消息后, 会发回响应的序列, 这种多个响应所组成的序列也被称为流</p></li>
<li><p>客户端流 RPC</p>
<p>在客户端流 RPC 模式中, 客户端会发送多个请求给服务端, 而不再是单个请求, 服务端则会发送一个响应给客户端</p></li>
<li><p>双向流 RPC</p>
<p>在双向流 RPC 模式中, 客户端以消息流的形式发送请求到服务端, 服务端也以消息流的形式进行响应</p></li>
</ul>
<h3 id="编码">编码</h3>
<p>gRPC 使用 protocol buffers 编写服务定义, 支持的语言都有对应的编译器来生成源代码, protocol buffers 支持多种编码技术, 它会根据数据类型使用不同的编码技术</p>
<h4 id="消息">消息</h4>
<p><span class="math display">\[
\overbrace{
\underbrace{
\overbrace{
\fbox{字段索引}
\fbox{线路类型}
}^{\large\textbf{标签}}
\fbox{值}
}_{\large\textbf{字段1}}
\underbrace{
\fbox{标签}
\fbox{值}
}_{\large\textbf{字段2}}
\cdots
\underbrace{
\fbox{标签}
\fbox{值}
}_{\large\textbf{字段n}}
\fbox{0}
}^{\large\textbf{消息}}
\]</span></p>
<p>标签(1byte) 也称字段标识符, 由字段索引和线路类型构成</p>
<p>字段索引 是在定义消息时, 为每个消息字段所设置的唯一数字</p>
<p>线路类型(3bit) 是基于字段类型的, 线路类型会提供信息来确定值的长度</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例: 消息结构定义</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Identification</span> </span>&#123; <span class="comment">// 定义消息名</span></span><br><span class="line">  <span class="built_in">int32</span> id = <span class="number">1</span>; <span class="comment">// 字段类型 字段名 字段索引</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可用的线路类型及其对应的字段类型, 见表 <a href="https://developers.google.com/protocol-buffers/docs/encoding#structure">structure</a></p>
<blockquote>
<p>在设计消息定义时, 了解各种数据类型对应的编码技术很重要, 这样做能够为每个消息字段设置最合适的数据类型, 从而让消息能够在运行时高效编码</p>
<p>比如, 对于负整数, 推荐使用 <code>sint32</code> 有符号整数类型, 负数首先会使用 zigzag 编码转换成正数, 然后再使用 varint 进行编码, 如果使用 <code>int32</code> 这样的常规类型, 就意味着使用 varint 编码将负值转换成二进制值, 但这比转换正值要使用更多的字节, 详见 <a href="https://developers.google.com/protocol-buffers/docs/encoding#signed_integers">signed integers</a></p>
</blockquote>
<h4 id="分帧">分帧</h4>
<p>通常, 消息分帧会构建消息和通信, 以便于接收方很容易的提取信息, gRPC 使用 <strong>长度前缀分帧(length-prefix framing)</strong> 的消息分帧技术, 在写入消息本身之前, 写入长度信息, 来表明每条消息的大小 <span class="math display">\[
\fbox{压缩标记}
\fbox{消息长度}
\underbrace{
\fbox{字段}
\cdots
\fbox{0}
}_{\large\textbf{消息}}
\]</span></p>
<p>压缩标记(1byte) 用来表明数据是否进行了压缩</p>
<p>消息长度(4byte) 设置消息的大小</p>
<blockquote>
<p>对于简单的消息, 只需要处理一条长度前缀分帧, 而对于流消息, 就会有多条长度前缀分帧的消息需处理</p>
</blockquote>
<h3 id="协议">协议</h3>
<p>gRPC 使用 HTTP/2 作为其传输协议, 实现通过网络发送消息, 当把基于长度前缀的消息分帧以请求消息或响应消息的形式通过网络进行发送时, 除了消息本身, 还要发送额外的头信息, 详见 <a href="https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md">http2</a></p>
<h4 id="请求">请求</h4>
<p>请求消息用于初始化远程调用, 在 gRPC 中, 请求消息始终由客户端应用程序来触发, 它包含 3 部分:</p>
<ul>
<li>请求头信息</li>
<li>以长度作为前缀的消息</li>
<li>流结束标记 (简称 EOS 标记)</li>
</ul>
<h4 id="响应">响应</h4>
<p>响应消息由服务端生成, 用来响应客户端的请求, 它包含 3 部分:</p>
<ul>
<li>响应头信息</li>
<li>以长度作为前缀的消息</li>
<li>trailer 标记</li>
</ul>
<p>单独的 trailer 来提醒客户端响应消息已发送, trailer 会携带状态码以及请求的状态信息</p>
<p>gRPC 状态码见 <a href="https://github.com/grpc/grpc/blob/master/doc/statuscodes.md">statuscodes</a> <a href="https://github.com/grpc/grpc/blob/master/doc/http-grpc-status-mapping.md">httpstatus</a></p>
<h2 id="工具">工具</h2>
<p><a href="https://github.com/protocolbuffers/protobuf">protobuf</a> 包含 protoc 编译器, 用于编译 <code>.proto</code> 文件, 生成的类为消息结构的字段提供 <code>getters</code> 和 <code>setters</code>, 并作为一个单元来处理读取和写入 protocol buffer 的细节</p>
<p><a href="https://github.com/grpc/grpc-java">grpc-java</a> 用于 Java 项目, 生成较高层次上的源码, 包含三个不同的层:</p>
<ul>
<li>存根(stub) 存根层是向开发人员公开的层, 它为数据模型 / IDL / 接口提供类型安全的绑定</li>
<li>通道(channel) 通道层是对传输处理的抽象, 适合于拦截 / 修饰, 并且比存根层向应用程序公开更多的行为</li>
<li>传输(transport) 传输层完成了从线上读取字节的工作</li>
</ul>
<p><a href="https://github.com/fullstorydev/grpcurl">grpcurl</a> 用于 gRPC 服务交互的命令行工具</p>
<p><a href="https://github.com/fullstorydev/grpcui">grpcui</a> 是一个命令行工具, 它提供了一个基于浏览器的 GUI, 允许开发者以交互方式构造 gRPC 服务端的请求</p>
<p><a href="https://github.com/pseudomuto/protoc-gen-doc">protoc-gen-doc</a> 是一个用于 protoc 的文档生成器, 该工具可以根据 <code>proto</code> 文件中的定义和注释生成 Html, Json, DocBook 或 Markdown 文档</p>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>gRPC</tag>
      </tags>
  </entry>
  <entry>
    <title>gRPC 示例</title>
    <url>/2021/03/02/grpc%20002/</url>
    <content><![CDATA[<h1 id="示例">示例</h1>
<p>gRPC 支持的语言及示例, 参考 <a href="https://grpc.io/docs/languages/">languages</a></p>
<h2 id="grpc-java">grpc-java</h2>
<p>Java 开发, 参考 <a href="https://github.com/grpc/grpc-java">grpc-java</a> <a href="https://github.com/grpc/grpc-java/blob/master/examples/README.md">examples</a></p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;  <span class="comment">// 指定所使用的版本</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/wrappers.proto&quot;</span>;  <span class="comment">// 导入其他文件中定义的消息结构</span></span><br></pre></td></tr></table></figure>
<p>封装类型 <code>google/protobuf</code> 列表, 参考 <a href="https://developers.google.com/protocol-buffers/docs/reference/google.protobuf">protobuf</a></p>
<p><strong>service</strong></p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">Biz</span> </span>&#123;  <span class="comment">// 定义服务</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> insert(Entity) <span class="keyword">returns</span> (Identification)</span>;                              <span class="comment">// 一元模式</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> search(Query) <span class="keyword">returns</span> (stream Entity)</span>;                                <span class="comment">// 服务端流模式</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> delete(stream Identification) <span class="keyword">returns</span> (google.protobuf.Int32Value)</span>;   <span class="comment">// 客户端流模式</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> update(stream Entity) <span class="keyword">returns</span> (stream Identification)</span>;                <span class="comment">// 双向流模式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>message</strong></p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Identification</span> </span>&#123;  <span class="comment">// 定义消息</span></span><br><span class="line">  <span class="keyword">oneof</span> identity &#123;  <span class="comment">// oneof表示同时最多只能设置一个字段</span></span><br><span class="line">    <span class="built_in">int32</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">string</span> code = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Query</span> </span>&#123;</span><br><span class="line">  <span class="keyword">repeated</span> <span class="built_in">int32</span> id = <span class="number">1</span>;     <span class="comment">// repeated表示可重复任意次数的字段</span></span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">string</span> name = <span class="number">2</span>;  <span class="comment">// optional表示可选参数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Entity</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int32</span> id = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">string</span> code = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 字段索引的取值范围为1~(2^29-1), 其中19000~19999用于预留编号</span></span><br></pre></td></tr></table></figure>
<p>字段类型及其对应开发语言的类型, 见表 <a href="https://developers.google.com/protocol-buffers/docs/proto3#scalar">scalar</a>, 解析消息时, 如果消息中特定类型的字段没有赋值, 则使用特定类型的默认值, 参考 <a href="https://developers.google.com/protocol-buffers/docs/proto3#default">default</a></p>
<p><strong>option</strong></p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">option</span> java_multiple_files = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">option</span> java_package = <span class="string">&quot;com.demo&quot;</span>;</span><br><span class="line"><span class="keyword">option</span> java_outer_classname = <span class="string">&quot;BizProto&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>可以使用多个选项注解 <code>proto</code> 文件中的个别声明, 选项不会更改声明的整体含义, 但可能会影响其在特定上下文中处理的方式, 选项可分为: 文件级, 消息级, 字段级</p>
<p>完整的选项列表定义在 <code>google/protobuf/descriptor.proto</code> 文件中, 第三方扩展的选项, 详见 <a href="https://github.com/protocolbuffers/protobuf/blob/master/docs/options.md#existing-registered-extensions">extensions</a></p>
<h3 id="protoc">protoc</h3>
<p>定义的消息类型, 生成开发语言的源码文件时, 需要使用 protocol buffers 编译器 <a href="https://developers.google.com/protocol-buffers/docs/downloads">protoc</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 基于Java的编译命令</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> protoc --proto_path=IMPORT_PATH --java_out=DST_DIR path/to/file.proto</span></span><br></pre></td></tr></table></figure>
<p>不同开发语言的参考文档, 详见 <a href="https://developers.google.com/protocol-buffers/docs/reference/overview">reference</a> <a href="https://github.com/protocolbuffers/protobuf/tree/master/java">protobuf java</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 示例: 基于Maven配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.protobuf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protobuf-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  <span class="comment">&lt;!-- 可选工具 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.protobuf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protobuf-java-util<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">extensions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">extension</span>&gt;</span>  <span class="comment">&lt;!-- 用于生成系统相关的环境变量 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>kr.motd.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>os-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">extension</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.xolstice.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protobuf-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">protocArtifact</span>&gt;</span>com.google.protobuf:protoc:$&#123;protobuf.version&#125;:exe:$&#123;os.detected.classifier&#125;<span class="tag">&lt;/<span class="name">protocArtifact</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pluginId</span>&gt;</span>grpc-java<span class="tag">&lt;/<span class="name">pluginId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pluginArtifact</span>&gt;</span>io.grpc:protoc-gen-grpc-java:$&#123;grpc.version&#125;:exe:$&#123;os.detected.classifier&#125;<span class="tag">&lt;/<span class="name">pluginArtifact</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile-custom<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>插件 <code>protoc-gen-grpc-java</code> 为每个 <code>.proto</code> 文件生成数据类和一个 <code>Grpc</code> 类, 这个类包含以下组件:</p>
<ul>
<li><code>ImplBase</code> 映射实现到 grpc 服务的抽象类, 开发者需要继承并实现具体的服务逻辑</li>
<li><code>Stub</code> 客户端实现</li>
</ul>
<h3 id="server">server</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 服务端实现 */</span></span><br><span class="line"><span class="meta">@Log</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BizImpl</span> <span class="keyword">extends</span> <span class="title">BizGrpc</span>.<span class="title">BizImplBase</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Entity request, StreamObserver&lt;Identification&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 参数校验</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(request.getName())) &#123;</span><br><span class="line">            responseObserver.onError(Status.INVALID_ARGUMENT.withDescription(<span class="string">&quot;name is not be blank.&quot;</span>).asRuntimeException());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        responseObserver.onNext(Identification.newBuilder().setId(request.getId()).build());</span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">(Query request, StreamObserver&lt;Entity&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        responseObserver.onNext(Entity.newBuilder().setId(<span class="number">1</span>).setName(<span class="string">&quot;name&quot;</span>).build());</span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StreamObserver&lt;Identification&gt; <span class="title">delete</span><span class="params">(StreamObserver&lt;Int32Value&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StreamObserver&lt;Identification&gt;() &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">boolean</span> error = <span class="keyword">false</span>;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Identification request)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (request.hasId()) &#123;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (request.hasCode()) &#123;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    error = <span class="keyword">true</span>;</span><br><span class="line">                    responseObserver.onError(Status.UNIMPLEMENTED.withDescription(<span class="string">&quot;not supported&quot;</span>).asRuntimeException());</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;&#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">                    responseObserver.onNext(Int32Value.of(count));</span><br><span class="line">                    responseObserver.onCompleted();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StreamObserver&lt;Entity&gt; <span class="title">update</span><span class="params">(StreamObserver&lt;Identification&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StreamObserver&lt;Entity&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Entity request)</span> </span>&#123;</span><br><span class="line">                responseObserver.onNext(Identification.newBuilder().setId(request.getId()).build());</span><br><span class="line">                responseObserver.onCompleted();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;&#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 配置启动 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> port = <span class="number">9090</span>;</span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Server server = ServerBuilder.forPort(port)</span><br><span class="line">            .addService(<span class="keyword">new</span> BizImpl()).build()</span><br><span class="line">            <span class="comment">// 服务端始终会使用客户端所指定的压缩方法, 如果对应的压缩器没有注册, 则会向客户端返回一个Unimplemented状态</span></span><br><span class="line">            <span class="comment">// .compressorRegistry(CompressorRegistry.getDefaultInstance()) // 配置压缩</span></span><br><span class="line">            .start();</span><br><span class="line">        <span class="comment">// 终端添加退出句柄</span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(server)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 有序关闭服务, 已存在的连接会等待30s完成调用, 新连接会被拒绝</span></span><br><span class="line">                    server.shutdown().awaitTermination(<span class="number">30</span>, TimeUnit.SECONDS);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">                log.info(<span class="string">&quot;server shutdown.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(server)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;server started, listening on &quot;</span> + port);</span><br><span class="line">            server.awaitTermination(<span class="number">30</span>, TimeUnit.SECONDS); <span class="comment">// 终端等待30s</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="client">client</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 客户端调用 */</span></span><br><span class="line"><span class="meta">@Log</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BizImpl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BizGrpc.BizStub bizStub;           <span class="comment">// 异步</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BizGrpc.BizBlockingStub bizStub2;  <span class="comment">// 同步</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Identification identification = bizStub2.insert(Entity.newBuilder().setId(<span class="number">1</span>).setName(<span class="string">&quot;&quot;</span>).build());</span><br><span class="line">            log.info(<span class="string">&quot;insert id: &quot;</span> + identification.getId());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (StatusRuntimeException e) &#123;</span><br><span class="line">            log.warning(<span class="string">&quot;error: &quot;</span> + e.getStatus().getDescription());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Iterator&lt;Entity&gt; entity = bizStub2.search(Query.newBuilder().setName(<span class="string">&quot;name&quot;</span>).build());</span><br><span class="line">        log.info(<span class="string">&quot;search: &quot;</span> + entity.next());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StreamObserver&lt;Identification&gt; response = bizStub.delete(<span class="keyword">new</span> StreamObserver&lt;Int32Value&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Int32Value value)</span> </span>&#123;</span><br><span class="line">                log.info(<span class="string">&quot;count: &quot;</span> + value.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;&#125;</span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        response.onNext(Identification.newBuilder().setId(<span class="number">1</span>).build());</span><br><span class="line">        response.onNext(Identification.newBuilder().setCode(<span class="string">&quot;2&quot;</span>).build());</span><br><span class="line">        response.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StreamObserver&lt;Entity&gt; response = bizStub.update(<span class="keyword">new</span> StreamObserver&lt;Identification&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Identification value)</span> </span>&#123;</span><br><span class="line">                log.info(<span class="string">&quot;id: &quot;</span> + value.getId());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;&#125;</span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        response.onNext(Entity.newBuilder().setId(<span class="number">1</span>).setName(<span class="string">&quot;name&quot;</span>).build());</span><br><span class="line">        response.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 配置启动 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String target = <span class="string">&quot;localhost:9090&quot;</span>;</span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ManagedChannel channel = ManagedChannelBuilder.forTarget(target)</span><br><span class="line">            <span class="comment">// .useTransportSecurity() // 使用TLS</span></span><br><span class="line">            .usePlaintext() <span class="comment">// 使用明文</span></span><br><span class="line">            <span class="comment">// .enableRetry() // 启用重试</span></span><br><span class="line">            <span class="comment">// .compressorRegistry(CompressorRegistry.getDefaultInstance()) // 配置压缩</span></span><br><span class="line">            .build();</span><br><span class="line">        bizStub = BizGrpc.newStub(channel)</span><br><span class="line">            .withDeadline(Deadline.after(<span class="number">2L</span>, TimeUnit.SECONDS)); <span class="comment">// 配置客户端截止时间为2s</span></span><br><span class="line">        bizStub2 = BizGrpc.newBlockingStub(channel);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BizImpl biz = <span class="keyword">new</span> BizImpl();</span><br><span class="line">            biz.insert();</span><br><span class="line">            biz.search();</span><br><span class="line">            biz.delete();</span><br><span class="line">            biz.update();</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123; channel.shutdown(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="安全">安全</h2>
<h3 id="tls">TLS</h3>
<p>传输层安全协议(transport layer security, TLS) 旨在为两个应用程序之间的通信提供隐私性和数据完整性, 它可用于在 gRPC 服务端和客户端的应用程序之间提供安全连接, 示例见 <a href="https://github.com/grpc/grpc-java/tree/master/examples/example-tls">tls</a></p>
<h3 id="jwt">JWT</h3>
<p>JWT 定义了在服务端和客户端传输身份信息的容器, 签名的 JWT 可用作自包含的访问令牌, 这意味着资源服务器无须与授权服务器通信来验证客户端的令牌, 它可以通过验证签名来校验令牌, gRPC 内置了对 JWT 的支持, 示例见 <a href="https://github.com/grpc/grpc-java/tree/master/examples/example-jwt-auth">jwt</a></p>
<h2 id="元数据">元数据</h2>
<p>在某些场景中, 因为预期共享的信息可能与业务上下文并没有关联, 所以它们不应该作为参数的一部分, 在这样的场景中, 可以使用 gRPC 元数据, 示例见 <a href="https://github.com/grpc/grpc-java/tree/master/examples/src/main/java/io/grpc/examples/header">header</a></p>
<h2 id="拦截器">拦截器</h2>
<p>gRPC 提供简单的拦截器, 用来在应用程序中执行一些通用逻辑, 比如日志, 身份验证, 授权, 性能度量指标, 跟踪以及其它自定义需求, gRPC 拦截器可以分为两类:</p>
<ul>
<li>一元拦截器(unary interceptor)</li>
<li>流拦截器(streaming interceptor)</li>
</ul>
<p>gRPC 拦截器可以用在服务端, 也可以用在客户端</p>
<h3 id="server-1">server</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 自定义服务端拦截器 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">ServerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;ReqT, RespT&gt; ServerCall.<span class="function">Listener&lt;ReqT&gt; <span class="title">interceptCall</span><span class="params">(ServerCall&lt;ReqT, RespT&gt; call, Metadata headers, ServerCallHandler&lt;ReqT, RespT&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// return next.startCall(call, headers);</span></span><br><span class="line">        call = <span class="keyword">new</span> ForwardingServerCall.SimpleForwardingServerCall&lt;ReqT, RespT&gt;(call) &#123;</span><br><span class="line">            <span class="meta">@Override</span>  <span class="comment">// 服务端接收请求时</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(<span class="keyword">int</span> numMessages)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.request(numMessages);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span>  <span class="comment">// 服务端发送元数据时</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendHeaders</span><span class="params">(Metadata headers)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// StreamObserver&lt;RespT&gt;.onNext</span></span><br><span class="line">                <span class="keyword">super</span>.sendHeaders(headers);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span>  <span class="comment">// 服务端发送消息时</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(RespT message)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// StreamObserver&lt;RespT&gt;.onNext</span></span><br><span class="line">                <span class="keyword">super</span>.sendMessage(message);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span>  <span class="comment">// 服务端关闭时</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Status status, Metadata trailers)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// StreamObserver&lt;RespT&gt;.onError</span></span><br><span class="line">                <span class="comment">// StreamObserver&lt;RespT&gt;.onCompleted</span></span><br><span class="line">                <span class="keyword">super</span>.close(status, trailers);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ForwardingServerCallListener.SimpleForwardingServerCallListener&lt;ReqT&gt;(next.startCall(call, headers)) &#123;</span><br><span class="line">            <span class="meta">@Override</span>  <span class="comment">// 客户端准备好时</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReady</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.onReady();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span>  <span class="comment">// 客户端发送消息时</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(ReqT message)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// StreamObserver&lt;ReqT&gt;.onNext</span></span><br><span class="line">                <span class="keyword">super</span>.onMessage(message);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span>  <span class="comment">// 客户端半关时</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onHalfClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// StreamObserver&lt;ReqT&gt;.onCompleted</span></span><br><span class="line">                <span class="keyword">super</span>.onHalfClose();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span>  <span class="comment">// 客户端完成时</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.onComplete();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span>  <span class="comment">// 客户端退出时(截止时间等触发)</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// StreamObserver&lt;ReqT&gt;.onError</span></span><br><span class="line">                <span class="keyword">super</span>.onCancel();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="client-1">client</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 自定义客户端拦截器 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">ClientInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;ReqT, RespT&gt; <span class="function">ClientCall&lt;ReqT, RespT&gt; <span class="title">interceptCall</span><span class="params">(MethodDescriptor&lt;ReqT, RespT&gt; method, CallOptions callOptions, Channel next)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// return next.newCall(method, callOptions);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ForwardingClientCall.SimpleForwardingClientCall&lt;ReqT, RespT&gt;(next.newCall(method, callOptions)) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Listener&lt;RespT&gt; responseListener, Metadata headers)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.start(</span><br><span class="line">                    <span class="keyword">new</span> ForwardingClientCallListener.SimpleForwardingClientCallListener&lt;RespT&gt;(responseListener) &#123;</span><br><span class="line">                        <span class="meta">@Override</span>  <span class="comment">// 服务端准备好时</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReady</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">super</span>.onReady();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="meta">@Override</span>  <span class="comment">// 服务端发送元数据时</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onHeaders</span><span class="params">(Metadata headers)</span> </span>&#123;</span><br><span class="line">                            <span class="comment">// </span></span><br><span class="line">                            <span class="keyword">super</span>.onHeaders(headers);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="meta">@Override</span>  <span class="comment">// 服务端发送消息时</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(RespT message)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">super</span>.onMessage(message);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="meta">@Override</span>  <span class="comment">// 服务端关闭时</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">(Status status, Metadata trailers)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">super</span>.onClose(status, trailers);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, headers);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span>  <span class="comment">// 客户端发起请求时</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(<span class="keyword">int</span> numMessages)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.request(numMessages);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span>  <span class="comment">// 客户端发送消息时</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(ReqT message)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.sendMessage(message);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span>  <span class="comment">// 客户端半关时</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">halfClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.halfClose();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span>  <span class="comment">// 客户端退出时</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">(<span class="meta">@Nullable</span> String message, <span class="meta">@Nullable</span> Throwable cause)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.cancel(message, cause);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="负载均衡">负载均衡</h2>
<p>在开发生产级 gRPC 应用程序时, 通常需要确保该应用程序能够满足高可用性和高扩展性的需求, 因此在生产环境中, 始终需要多个 gRPC 服务端, 在这些服务之间的分发处理需要使用负载均衡器, gRPC 通常使用以下两种主要的负载均衡机制:</p>
<ul>
<li><p>负载均衡代理</p>
<p>在代理负载均衡场景中, 客户端向负载均衡器代理发起 RPC, 负载均衡器代理将 RPC 分发给一台可用的 gRPC 服务端, 负载均衡器代理会跟踪每台服务端的负载, 并为服务端分配负载提供不同的负载均衡算法, 例如, 可以使用 Nginx, Envoy 等作为 gRPC 应用程序的负载均衡器代理</p></li>
<li><p>客户端负载均衡</p>
<p>客户端负载均衡不借助中间代理层, 而是在 gRPC 客户端层实现负载均衡的逻辑, 客户端要知道多台 gRPC 服务端, 并为每个 RPC 选择一台 gRPC 服务端, gRPC 有两个默认支持的负载均衡算法:</p>
<ul>
<li><code>pick_fist</code> 始终选择第一个地址, 如果失败则会尝试下一个地址</li>
<li><code>round_robin</code> 按顺序使用地址</li>
</ul></li>
</ul>
<p>负载均衡逻辑可以完全作为客户端应用程序 (也被称为厚客户端) 的一部分来进行开发, 也可以实现为一个专用的服务端, 称为后备负载均衡器, 详情见 <a href="https://github.com/grpc/grpc-java/issues/1771">balancer</a></p>
<h3 id="负载测试">负载测试</h3>
<p>使用常规的工具很难对 gRPC 应用程序进行负载测试和基准测量, 这是因为这些应用程序都或多或少是与特定协议 (如 HTTP) 绑定的, 对于 gRPC 来说, 需要定制的负载测试工具</p>
<p><a href="https://ghz.sh/">ghz</a> 是使用 Go 语言实现的命令行工具, 能够生成对服务端的虚拟 RPC 负载, 从而实现对 gRPC 服务端的负载测试, 也能用在自动化持续集成环境中, 实现性能回归测试, 示例见 <a href="https://ghz.sh/docs/examples">example</a></p>
<h2 id="度量指标">度量指标</h2>
<p>度量指标是一段时间内测量数据的数字形式表示, 在讨论度量指标时, 通常会收集两种类型的数据:</p>
<ul>
<li>系统级的指标 例如 CPU 使用情况, 内存使用情况等</li>
<li>应用级的指标 例如入站请求率, 请求错误率等</li>
</ul>
<p><a href="https://prometheus.io/">Prometheus</a> 是一个用于系统监控和警告的开源工具集</p>
<p><a href="https://github.com/grpc-ecosystem/java-grpc-prometheus">java-grpc-prometheus</a></p>
<h3 id="日志">日志</h3>
<p>在 gRPC Java 应用程序中, 没有控制日志级别的环境变量, 可以通过提供 <a href="http://commons.apache.org/proper/commons-logging/">logging</a> 配置文件来启用日志</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件: logging.properties</span></span><br><span class="line"><span class="attr">handlers</span>=<span class="string">java.util.logging.ConsoleHandler</span></span><br><span class="line"><span class="meta">io.grpc.netty.level</span>=<span class="string">FINE</span></span><br><span class="line"><span class="meta">java.util.logging.ConsoleHandler.level</span>=<span class="string">FINE</span></span><br><span class="line"><span class="meta">java.util.logging.ConsoleHandler.formatter</span>=<span class="string">java.util.logging.SimpleFormatter</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 项目启动时指定配置文件</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> java -jar app.jar -Djava.util.logging.config.file=logging.properties</span></span><br></pre></td></tr></table></figure>
<h2 id="生态系统">生态系统</h2>
<p>gRPC 生态系统项目不是核心 gRPC 实现的一部分, 但在构建和运行真正的 gRPC 应用程序时, 它们可能会非常有用, 这些项目是围绕 gRPC 构建的, 用来克服使用 gRPC 构建生态系统时所遇到的问题或限制</p>
<p><a href="https://grpc-ecosystem.github.io/grpc-gateway/">grpc-gateway</a> 网关插件能够让 protocol buffers 编译器读取 gRPC 服务定义, 并生成反向代理服务端, 该服务端能够将 RESTful JSON API 翻译为 gRPC, 这是专门为 Go 编写的, 为了同时支持从 gRPC 和 HTTP 客户端应用程序调用 gRPC 服务</p>
<p><a href="https://github.com/grpc-ecosystem/grpc-httpjson-transcoding">grpc-httpjson-transcoding</a> 当客户端应用程序不支持 gRPC, 并且需要通过基于 HTTP 的 JSON 方式提供对 gRPC 服务的访问时, 该插件可以将 HTTP JSON 调用转换成 RPC, 并将它们传递给 gRPC 服务</p>
<p><a href="https://github.com/grpc/grpc/blob/master/doc/server-reflection.md">server-reflection</a> 是在 gRPC 服务端定义的一个服务, 它能提供该服务端上可公开访问的 gRPC 服务的信息, 因此客户端不需要预编译服务定义就能与服务端进行通信</p>
<p><a href="https://github.com/grpc-ecosystem/go-grpc-middleware">grpc-middleware</a> 是基于 Go 语言的一组拦截器, 辅助器和工具的集合, 在构建基于 gRPC 的应用程序时, 它允许在服务端或客户端以拦截器链的形式应用多个拦截器</p>
<p><a href="https://github.com/grpc/grpc/blob/master/doc/health-checking.md">health-checking</a> gRPC 定义了一个健康检查协议(Health Checking API), 它根据服务端是否响应非健康状态来确定服务端的状态, 当服务端还没有准备好处理 RPC 或者根本没有响应健康探针的请求时, 响应就会表明服务端处于非健康状态或者在规定时间窗口内没有收到响应, 这样消费者就能采取相应的行动</p>
<p><a href="https://github.com/grpc-ecosystem/grpc-health-probe">grpc-health-probe</a> 是社区提供的健康探针工具, 用来检查服务端的健康状态, 这是一个通用的客户端, 能够与 gRPC 标准的健康检查服务通信, 可以以 CLI 工具的方式来使用</p>
]]></content>
      <categories>
        <category>开发</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>gRPC</tag>
      </tags>
  </entry>
  <entry>
    <title>gRPC 接口</title>
    <url>/2021/03/03/grpc%20003/</url>
    <content><![CDATA[<h1 id="接口">接口</h1>
<p><a href="https://github.com/yidongnan/grpc-spring-boot-starter">grpc-spring-boot-starter</a> 将 gRPC 与 SpringBoot 进行整合, 该项目简化了 gRPC 服务端和客户端的设置, 提供的特性仍能复用使用 gRPC 的经验, 并且允许开发者执行任何自定义操作, 详见 <a href="https://yidongnan.github.io/grpc-spring-boot-starter/zh-CN/">文档</a></p>
<h2 id="示例">示例</h2>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 示例: Maven配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.devh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-server-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.devh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-client-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="server">server</h3>
<p>将 <code>@GrpcService</code> 注解添加到 <code>ImplBase</code> 的实现类上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: @GrpcService */</span></span><br><span class="line"><span class="meta">@GrpcService</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BizImpl</span> <span class="keyword">extends</span> <span class="title">BizGrpc</span>.<span class="title">BizImplBase</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 配置类参考 net.devh.boot.grpc.server.config.GrpcServerProperties</span></span><br></pre></td></tr></table></figure>
<p>服务端配置可以复用 gRPC 的 <code>ServerBuilder</code> 配置方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 配置 */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> GrpcServerConfigurer <span class="title">configurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> serverBuilder -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (serverBuilder <span class="keyword">instanceof</span> NettyServerBuilder) &#123;</span><br><span class="line">            ((NettyServerBuilder) serverBuilder)</span><br><span class="line">                    .keepAliveTime(<span class="number">30</span>, TimeUnit.SECONDS)</span><br><span class="line">                    .keepAliveTimeout(<span class="number">5</span>, TimeUnit.SECONDS)</span><br><span class="line">                    .permitKeepAliveWithoutCalls(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="client">client</h3>
<p>将 <code>@GrpcClient</code> 注解添加在需要注入客户端的字段上, 支持 <code>Channel</code> 和各种类型的 <code>Stub</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: @GrpcClient */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BizImpl</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GrpcClient(&quot;bizService&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> BizGrpc.BizStub bizStub;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 配置类参考 net.devh.boot.grpc.client.config.GrpcChannelProperties</span></span><br></pre></td></tr></table></figure>
<p>客户端配置可以复用 gRPC 的 <code>ChannelBuilder</code> 配置方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 配置 */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> GrpcChannelConfigurer <span class="title">keepAliveClientConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (channelBuilder, name) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (channelBuilder <span class="keyword">instanceof</span> NettyChannelBuilder) &#123;</span><br><span class="line">            ((NettyChannelBuilder) channelBuilder)</span><br><span class="line">                    .keepAliveTime(<span class="number">30</span>, TimeUnit.SECONDS)</span><br><span class="line">                    .keepAliveTimeout(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在注入客户端之前可以通过 <code>StubTransformer</code> 配置修改 <code>Stub</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 配置 */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StubTransformer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (name, stub) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;inProcess&quot;</span>.equals(name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> stub.withWaitForReady();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> stub;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="上下文">上下文</h2>
<p>grpc-java 中, 消息发送和请求处理的不同阶段可能在不同的线程中运行, 流式调用中也是这样, 如果需要在会话或请求中存储数据, 需要使用 gRPC 的 <code>Context</code> 或 <code>grpcRequest</code> 作用域, 详见 <a href="https://yidongnan.github.io/grpc-spring-boot-starter/zh-CN/server/contextual-data.html">contextual-data</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: Context */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Context.Key&lt;String&gt; CRED_KEY = Context.key(<span class="string">&quot;CRED_KEY&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// A阶段</span></span><br><span class="line">Context.current().withValue(CRED_KEY, cred);</span><br><span class="line"><span class="comment">// B阶段</span></span><br><span class="line">String cred = CRED_KEY.get();</span><br><span class="line"><span class="comment">// 常用于拦截器中对安全认证或分布式部署时信息的存储</span></span><br></pre></td></tr></table></figure>
<p>grpc-spring-boot-starter 项目添加了一个 <code>grpcRequest</code> 范围, 该功能类似 Spring Web 的 <code>request</code> 作用域, 它只适用于单个请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: grpcRequest */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope(scopeName = GrpcRequestScope.GRPC_REQUEST_SCOPE_NAME, proxyMode = ScopedProxyMode.TARGET_CLASS)</span></span><br><span class="line"><span class="keyword">public</span> Context.<span class="function">Key&lt;String&gt; <span class="title">credKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Context.key(<span class="string">&quot;CRED_KEY&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Context.Key&lt;String&gt; credKey;</span><br><span class="line"><span class="comment">// A阶段</span></span><br><span class="line">Context.current().withValue(credKey, cred);</span><br><span class="line"><span class="comment">// B阶段</span></span><br><span class="line">String cred = credKey.get();</span><br><span class="line"><span class="comment">// 常用于单个请求的数据隔离</span></span><br></pre></td></tr></table></figure>
<h2 id="状态码">状态码</h2>
<p>gRPC 使用一组定义良好的状态码 <a href="https://github.com/grpc/grpc/blob/master/doc/statuscodes.md">statuscodes</a> 作为 API 的一部分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 状态码 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BizImpl</span> <span class="keyword">extends</span> <span class="title">BizGrpc</span>.<span class="title">BizImplBase</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Entity request, StreamObserver&lt;Identification&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(request.getName())) &#123;</span><br><span class="line">            responseObserver.onError(</span><br><span class="line">                <span class="comment">// 返回参数错误的状态码</span></span><br><span class="line">                Status.INVALID_ARGUMENT.withDescription(<span class="string">&quot;name is not be blank.&quot;</span>).asRuntimeException()</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        responseObserver.onNext(Identification.newBuilder().setId(request.getId()).build());</span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>grpc-spring-boot-starter 项目支持在切面中配置全局异常映射为 gRPC 的状态码, 详见 <a href="https://github.com/yidongnan/grpc-spring-boot-starter/issues/358">exception-handler</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 全局异常 */</span></span><br><span class="line"><span class="meta">@GrpcAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BizExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将参数错误的异常映射为状态码</span></span><br><span class="line">    <span class="meta">@GrpcExceptionHandler(IllegalArgumentException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Status <span class="title">handler</span><span class="params">(IllegalArgumentException exception)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Status.fromCode(Status.Code.INVALID_ARGUMENT)</span><br><span class="line">            .withDescription(exception.getMessage())</span><br><span class="line">            .withCause(exception);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="扩展">扩展</h3>
<p><a href="https://cloud.google.com/apis/design/errors">errors</a> 谷歌设计指南中介绍了通用的错误处理, 错误模型由 <a href="https://github.com/googleapis/googleapis/blob/master/google/rpc/status.proto">google/rpc/status.proto</a> 逻辑定义, 该实例在应用发生错误时返回给客户端, 可以在 <a href="https://github.com/googleapis/googleapis/blob/master/google/rpc/error_details.proto">google/rpc/error_details.proto</a> 中找到一组标准的错误类型, 它们涵盖了对于错误处理的最常见需求</p>
<ul>
<li><code>ErrorInfo</code> 提供稳定又可扩展的结构化错误信息</li>
<li><code>RetryInfo</code> 描述客户端何时可以重试失败的请求</li>
<li><code>QuotaFailure</code> 描述配额检查失败的方式</li>
<li><code>BadRequest</code> 描述客户端请求中的违规行为</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 错误详情 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BizImpl</span> <span class="keyword">extends</span> <span class="title">BizGrpc</span>.<span class="title">BizImplBase</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Entity request, StreamObserver&lt;Identification&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(request.getName())) &#123;</span><br><span class="line">            BadRequest detail = BadRequest.newBuilder()</span><br><span class="line">                .addFieldViolations(BadRequest.FieldViolation.newBuilder()</span><br><span class="line">                    .setField(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">                    .setDescription(<span class="string">&quot;name is not be blank.&quot;</span>)</span><br><span class="line">                    .build())</span><br><span class="line">                .build()</span><br><span class="line">            com.google.rpc.Status status = com.google.rpc.Status.newBuilder()</span><br><span class="line">                .setCode(Status.Code.INVALID_ARGUMENT.value())</span><br><span class="line">                .setMessage(<span class="string">&quot;validation failed.&quot;</span>)</span><br><span class="line">                .addDetails(Any.pack(detail))</span><br><span class="line">                .build();</span><br><span class="line">            responseObserver.onError(StatusProto.toStatusException(status));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        responseObserver.onNext(Identification.newBuilder().setId(request.getId()).build());</span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="校验">校验</h2>
<p>参数校验功能, 参考 <a href="https://github.com/yidongnan/grpc-spring-boot-starter/pull/487">validator</a></p>
<h3 id="javax">Javax</h3>
<p>使用 <code>javax.validation</code> 方案时, 由于无法向未生成的结构化类中添加约束注解, 所以需要通过 XML 配置编写消息字段的约束</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 示例: Maven配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>XML 配置参考 <a href="https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/?v=7.0#chapter-xml-configuration">xml-configuration</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 文件: META-INF/validation.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">validation-config</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://jboss.org/xml/ns/javax/validation/configuration&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constraint-mapping</span>&gt;</span>META-INF/validation/biz.xml<span class="tag">&lt;/<span class="name">constraint-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.validator.fail_fast&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">validation-config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 文件: META-INF/validation/biz.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constraint-mappings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://jboss.org/xml/ns/javax/validation/mapping&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;lib.Entity&quot;</span> <span class="attr">ignore-annotations</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">getter</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">constraint</span> <span class="attr">annotation</span>=<span class="string">&quot;javax.validation.constraints.Min&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">element</span> <span class="attr">name</span>=<span class="string">&quot;value&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">element</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">constraint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">getter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">getter</span> <span class="attr">name</span>=<span class="string">&quot;code&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">constraint</span> <span class="attr">annotation</span>=<span class="string">&quot;javax.validation.constraints.NotBlank&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">getter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">getter</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">constraint</span> <span class="attr">annotation</span>=<span class="string">&quot;org.hibernate.validator.constraints.Length&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">element</span> <span class="attr">name</span>=<span class="string">&quot;min&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">element</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">element</span> <span class="attr">name</span>=<span class="string">&quot;max&quot;</span>&gt;</span>4<span class="tag">&lt;/<span class="name">element</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">constraint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">getter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">constraint-mappings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: Validator */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BizImpl</span> <span class="keyword">extends</span> <span class="title">BizGrpc</span>.<span class="title">BizImplBase</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Validator validator;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Entity request, StreamObserver&lt;Identification&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 参数校验</span></span><br><span class="line">        Optional&lt;ConstraintViolation&lt;Entity&gt;&gt; opt = validator.validate(request).stream().findFirst();</span><br><span class="line">        <span class="keyword">if</span> (opt.isPresent()) &#123;</span><br><span class="line">            responseObserver.onError(Status.INVALID_ARGUMENT.withDescription(</span><br><span class="line">                opt.get().getPropertyPath().toString() + opt.get().getMessage()</span><br><span class="line">            ).asRuntimeException());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        responseObserver.onNext(Identification.newBuilder().setId(request.getId()).build());</span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了 XML 配置以外, 也可以通过代码以构造的方式定义约束的映射关系, 详见 <a href="https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/?v=7.0#section-programmatic-api">constraint-declaration</a></p>
<h3 id="pgv">PGV</h3>
<p><a href="https://github.com/envoyproxy/protoc-gen-validate">protoc-gen-validate</a> 是一个 protoc 插件, 用于生成多语言的消息验证器, 虽然 protocol buffers 协议有效的保证了结构化数据的类型, 但它不能强制值的语义规则, 这个插件添加了生成代码的约束验证的支持</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 示例: Maven配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span> io.envoyproxy.protoc-gen-validate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pgv-java-stub<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.envoyproxy.protoc-gen-validate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pgv-java-grpc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">extensions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">extension</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>kr.motd.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>os-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">extension</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.xolstice.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protobuf-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">protocArtifact</span>&gt;</span>com.google.protobuf:protoc:$&#123;protoc.version&#125;:exe:$&#123;os.detected.classifier&#125;<span class="tag">&lt;/<span class="name">protocArtifact</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>protoc-java-pgv<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile-custom<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">pluginParameter</span>&gt;</span>lang=java<span class="tag">&lt;/<span class="name">pluginParameter</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">pluginId</span>&gt;</span>java-pgv<span class="tag">&lt;/<span class="name">pluginId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">pluginArtifact</span>&gt;</span>io.envoyproxy.protoc-gen-validate:protoc-gen-validate:$&#123;pgv.version&#125;:exe:$&#123;os.detected.classifier&#125;<span class="tag">&lt;/<span class="name">pluginArtifact</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>插件定义的可用约束的类型和规则, 详见 <a href="https://github.com/envoyproxy/protoc-gen-validate/blob/main/validate/validate.proto">validate.proto</a></p>
<p>插件定义的约束在不同开发语言中的可用性, 详见 <a href="https://github.com/envoyproxy/protoc-gen-validate/blob/main/rule_comparison.md">rule-comparison</a></p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;示例: proto文件&quot;</span></span><br><span class="line">import <span class="string">&quot;validate/validate.proto&quot;</span><span class="comment">;</span></span><br><span class="line">message Entity &#123;</span><br><span class="line">  int<span class="number">32</span> id = <span class="number">1</span> [(<span class="name">validate.rules</span>).int32.gt = <span class="number">0</span>]<span class="comment">;</span></span><br><span class="line">  string code = <span class="number">2</span> [(<span class="name">validate.rules</span>).string = &#123;</span><br><span class="line">                   pattern: <span class="string">&quot;^[0-9A-Za-z]+$&quot;</span>,</span><br><span class="line">                   max_bytes: <span class="number">256</span></span><br><span class="line">                   &#125;]<span class="comment">;</span></span><br><span class="line">  string name = <span class="number">3</span> [(<span class="name">validate.rules</span>).string.email = true]<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 拦截器方式 */</span></span><br><span class="line"><span class="meta">@GrpcGlobalServerInterceptor</span>  <span class="comment">// 服务端配置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServerInterceptor <span class="title">serverInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ValidatingServerInterceptor(<span class="keyword">new</span> ReflectiveValidatorIndex());</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@GrpcGlobalClientInterceptor</span>  <span class="comment">// 客户端配置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ClientInterceptor <span class="title">clientInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ValidatingClientInterceptor(<span class="keyword">new</span> ReflectiveValidatorIndex());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 代码调用方式 */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Entity request, StreamObserver&lt;Identification&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> ReflectiveValidatorIndex().validatorFor(request.getClass()).assertValid(request);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ValidationException e) &#123;</span><br><span class="line">        responseObserver.onError(Status.INVALID_ARGUMENT.withDescription(e.getMessage()).asRuntimeException());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    responseObserver.onNext(Identification.newBuilder().setId(request.getId()).build());</span><br><span class="line">    responseObserver.onCompleted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="安全">安全</h2>
<p>grpc-spring-boot-starter 原生支持 spring-security, 详见 <a href="https://yidongnan.github.io/grpc-spring-boot-starter/zh-CN/server/security.html#%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83">security</a></p>
<h3 id="认证">认证</h3>
<p>服务端可以通过定义 <code>GrpcAuthenticationReader</code> 实现需要的身份认证, 框架提供了一些内置的实现:</p>
<ul>
<li><code>AnonymousAuthenticationReader</code> 匿名身份认证</li>
<li><code>BasicGrpcAuthenticationReader</code> 基础身份认证</li>
<li><code>BearerAuthenticationReader</code> 令牌协议的身份认证</li>
<li><code>SSLContextGrpcAuthenticationReader</code> 基于证书的身份认证</li>
<li><code>CompositeGrpcAuthenticationReader</code> 复合多个身份认证</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 基础认证 */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> GrpcAuthenticationReader <span class="title">authenticationReader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BasicGrpcAuthenticationReader();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其它用户配置同spring-security</span></span><br></pre></td></tr></table></figure>
<h3 id="授权">授权</h3>
<p>服务端可以配置 <code>GrpcSecurityMetadataSource</code> 为每个 gRPC 的方法添加安全条件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 配置权限 */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> GrpcSecurityMetadataSource <span class="title">security</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ManualGrpcSecurityMetadataSource source = <span class="keyword">new</span> ManualGrpcSecurityMetadataSource();</span><br><span class="line">    source.set(BizGrpc.getSearchMethod(), AccessPredicate.permitAll());</span><br><span class="line">    source.set(BizGrpc.getInsertMethod(), AccessPredicate.authenticated());</span><br><span class="line">    source.set(BizGrpc.getDeleteMethod(), AccessPredicate.hasRole(<span class="string">&quot;ROLE_ADMIN&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> source;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 也可以在grpc方法级别上直接使用spring-security注解</span></span><br></pre></td></tr></table></figure>
<h2 id="测试">测试</h2>
<p>测试基于 Junit5 框架, 详见 <a href="https://yidongnan.github.io/grpc-spring-boot-starter/zh-CN/server/testing.html">testing</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 示例: Maven配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.grpc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-testing<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="单元测试">单元测试</h3>
<p>在单元测试中, 直接在 gRPC 服务端的 Bean 实例上调用方法, 可以使用 <a href="https://site.mockito.org/">Mockito</a> 等模拟库限制依赖树的深度, 从而简化测试的流程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 单元测试 */</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BizTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BizImpl bizImpl;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StreamRecorder&lt;Identification&gt; recorder = StreamRecorder.create();</span><br><span class="line">        bizImpl.insert(Entity.newBuilder().setId(<span class="number">1</span>).setName(<span class="string">&quot;&quot;</span>).build(), recorder);</span><br><span class="line">        <span class="comment">// 断言</span></span><br><span class="line">        Assertions.assertTrue(recorder.awaitCompletion(<span class="number">5</span>, TimeUnit.SECONDS));</span><br><span class="line">        Assertions.assertNull(recorder.getError(), recorder.getError().getMessage());</span><br><span class="line">        Assertions.assertEquals(<span class="number">1</span>, recorder.firstValue().get().getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="集成测试">集成测试</h3>
<p>在集成测试中, 配置启用 <code>InProcessServer</code> 服务, 可以在不打开端口的情况下调用 gRPC 服务, 从而以节省网络开销的方式来测试整个调用栈, 详见 <a href="https://yidongnan.github.io/grpc-spring-boot-starter/zh-CN/server/configuration.html#%E5%90%AF%E7%94%A8-inprocessserver">in-process-server</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 集成测试 */</span></span><br><span class="line"><span class="meta">@SpringBootTest(properties = &#123;</span></span><br><span class="line"><span class="meta">    &quot;grpc.server.inProcessName=test&quot;,</span></span><br><span class="line"><span class="meta">    &quot;grpc.server.port=-1&quot;,</span></span><br><span class="line"><span class="meta">    &quot;grpc.client.inProcess.address=in-process:test&quot;</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">@DirtiesContext</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BizTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GrpcClient(&quot;inProcess&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> BizGrpc.BizBlockingStub bizStub;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Identification identification = bizStub.insert(Entity.newBuilder().setId(<span class="number">1</span>).setName(<span class="string">&quot;&quot;</span>).build());</span><br><span class="line">        <span class="comment">// 断言</span></span><br><span class="line">        Assertions.assertNotNull(identification);</span><br><span class="line">        Assertions.assertEquals(<span class="number">1</span>, identification.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开发</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>gRPC</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins 简介</title>
    <url>/2020/02/11/jenkins%20001/</url>
    <content><![CDATA[<h1 id="简介">简介</h1>
<h2 id="jenkins">Jenkins</h2>
<p><strong>Jenkins</strong> 是一款使用 Java 语言开发的开源的自动化服务器, 通过界面或 Jenkinsfile 告诉它执行什么任务, 何时执行, 理论上, 可以让它执行任何任务, 但是通常只应用于持续集成和持续交付</p>
<p><strong>Jenkinsfile</strong> 是一个文本文件, 也就是部署流水线概念在 Jenkins 中的表现形式, 所有部署流水线的逻辑都写在 Jenkinsfile 中</p>
<h3 id="安装">安装</h3>
<p><a href="https://www.jenkins.io/download/">Jenkins</a> 官网提供了 war 文件, 安装程序和 Docker 镜像的下载链接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载</span></span><br><span class="line">curl -O http://mirrors.jenkins.io/war-stable/latest/jenkins.war</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动</span></span><br><span class="line">java -jar jenkins.war</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装为windows服务启动</span></span><br><span class="line">jenkins.exe install</span><br><span class="line"><span class="meta">#</span><span class="bash"> 卸载服务</span></span><br><span class="line">jenkins.exe uninstall</span><br></pre></td></tr></table></figure>
<h3 id="镜像">镜像</h3>
<p>配置国内加速镜像 <a href="https://jenkins-zh.cn/wechat/articles/2019/11/2019-11-11-update-center-mirror-announcement/">参考</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 提示需要密钥的话, 手动下载密钥到本地证书文件夹</span></span><br><span class="line">cd $JENKINS_HOME/war/WEB-INF/update-center-rootCAs/</span><br><span class="line">curl -O https://raw.githubusercontent.com/jenkins-zh/mirror-adapter/master/rootCA/mirror-adapter.crt</span><br></pre></td></tr></table></figure>
<h2 id="pipeline">Pipeline</h2>
<p>部署流水线(Deployment <strong>pipeline</strong>) 是指从软件版本控制库到用户手中这一过程的自动化表现形式</p>
<blockquote>
<p>Jenkins 1.x 只能通过界面手动操作来描述部署流水线, Jenkins 2.x 支持 <code>pipeline as code</code>, 可以通过代码来描述部署流水线</p>
</blockquote>
<h3 id="pipeline-语法">pipeline 语法</h3>
<ul>
<li><p>脚本式(Scripted)</p>
<p>Groovy 语言被选择作为基础来实现 pipeline, 所以在写脚本式 pipeline, 其实就是在写 Groovy 代码, 这样为用户提供了巨大的灵活性和可扩展性</p></li>
<li><p>声明式(Declarative)</p>
<p>Groovy 语言的学习成本对于不使用 Groovy 的开发团队来说通常是不必要的, 所以 Jenkins 提供了更简单, 更结构化的声明式语法</p></li>
</ul>
<h3 id="pipeline-项目">Pipeline 项目</h3>
<p>要创建 pipeline, 首先要安装 pipeline 插件, 在 Jenkins 中新建一个 <code>pipeline</code> 项目</p>
<h4 id="pipeline-script">pipeline script</h4>
<p>在 pipeline 节点下选择 <code>Pipeline script</code>, 脚本中填入示例代码</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例代码: Hello World */</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">   agent any</span><br><span class="line"></span><br><span class="line">   stages &#123;</span><br><span class="line">      stage(<span class="string">&#x27;build&#x27;</span>) &#123;</span><br><span class="line">         steps &#123;</span><br><span class="line">            echo <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 执行结果</span></span><br><span class="line">Started by user janz</span><br><span class="line">Running in Durability level: MAX_SURVIVABILITY</span><br><span class="line">[Pipeline] Start of Pipeline</span><br><span class="line">[Pipeline] node</span><br><span class="line">Running on Jenkins in $&#123;JENKINS_HOME&#125;\workspace\HELLO_WORLD</span><br><span class="line">[Pipeline] &#123;</span><br><span class="line">[Pipeline] stage</span><br><span class="line">[Pipeline] &#123; (build)</span><br><span class="line">[Pipeline] echo</span><br><span class="line">Hello World</span><br><span class="line">[Pipeline] &#125;</span><br><span class="line">[Pipeline] // stage</span><br><span class="line">[Pipeline] &#125;</span><br><span class="line">[Pipeline] // node</span><br><span class="line">[Pipeline] End of Pipeline</span><br><span class="line">Finished: SUCCESS</span><br></pre></td></tr></table></figure>
<blockquote>
<p>直接在 Jenkins 界面上填入 pipeline 脚本内容, 在试验时可以这么做, 但是不推荐, 因为这样无法做到 pipeline 的版本化</p>
</blockquote>
<h4 id="pipeline-script-from-scm">pipeline script from SCM</h4>
<p>从代码仓库拉取 pipeline 并执行, 在 pipeline 节点下选择 <code>Pipeline script from SCM</code>, 并在 SCM 中选择对应的仓库类型, 项目结构新建 <code>Jenkinsfile</code> 文件, 示例代码和执行结果同上</p>
<h3 id="multibranch-pipeline-项目">Multibranch Pipeline 项目</h3>
<p>实际项目中, 往往需要多分支同时进行开发, 如果为每个分支都分别创建 Jenkins 项目有些多余, Jenkins 支持多分支 pipeline, 创建此类项目时, 需要选择 <code>Multibranch Pipeline</code></p>
<p>分支扫描根据一定的策略去代码仓库扫描分支, 如果有新分支就创建一个以分支命名的任务, 如果分支被删除了, 就删除相应的任务</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 多分支pipeline */</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;master&#x27;</span>) &#123;</span><br><span class="line">            when &#123;</span><br><span class="line">                branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&quot;master build&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;release&#x27;</span>) &#123;</span><br><span class="line">            when &#123;</span><br><span class="line">                tag(<span class="attr">pattern:</span> <span class="string">&#x27;release-*&#x27;</span>, <span class="attr">comparator:</span> <span class="string">&#x27;GLOB&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&quot;release build&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="maven-构建">Maven 构建</h2>
<p>Maven 是非常流行的一个 Java 应用构建工具, Jenkins 默认支持 Maven</p>
<p>首先需要在 Jenkins 上安装 JDK 和 Maven, 可以登录 Jenkins 服务器手动安装, 也可以让 Jenkins 自动安装</p>
<p>进入 <code>Manage Jenkins / Global Tool Configuration / Maven</code> 页配置自动安装的 Maven</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: Jenkinsfile文件代码 */</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    tools &#123;</span><br><span class="line">        maven <span class="string">&#x27;mvn-3.6.3&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;build&#x27;</span>) &#123;</span><br><span class="line">            sh <span class="string">&quot;mvn clean package spring-boot:repackage&quot;</span></span><br><span class="line">            sh <span class="string">&quot;printenv&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tools命令用于自动安装指定的构建工具并将其路径放到PATH变量中, 参数&#x27;mvn-3.6.3&#x27;需要与Maven节点下配置的自动安装的Name一致</span></span><br><span class="line"><span class="comment">// 通过命令sh &quot;printenv&quot;将环境变量打印到控制台中, 可以看到MAVEN_HOME放到了当前任务的环境变量中</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins Pipeline</title>
    <url>/2020/02/11/jenkins%20002/</url>
    <content><![CDATA[<h1 id="pipeline">Pipeline</h1>
<h2 id="结构">结构</h2>
<p>Jenkins pipeline 是基于 Groovy 语言实现的一种 DSL(领域特定语言), 用于描述整条流水线是如何进行的, 流水线的内容包括执行编译, 打包, 测试, 输出测试报告等步骤</p>
<p>Jenkins 对这个过程进行抽象, 设计出一个基本的 <code>pipeline</code> 结构</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* pipeline最简结构 */</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;build&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&quot;hello world&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pipeline  代表整条流水线, 包含整条流水线的逻辑</span></span><br><span class="line"><span class="comment">// stages    流水线中多个stage的容器, 至少包含一个stage</span></span><br><span class="line"><span class="comment">// stage     代表流水线的阶段, 每个阶段都必须有名称, 示例名称为build</span></span><br><span class="line"><span class="comment">// agent     指定流水线的执行位置, 流水线中的每个阶段都必须在某个地方(物理机, 虚拟机或Docker容器)执行</span></span><br></pre></td></tr></table></figure>
<h2 id="指令">指令</h2>
<p>基本结构满足不了现实多变的需求, 所以 Jenkins pipeline 通过各种指令来丰富自己, 指令可以被理解为对 Jenkins pipeline 基本结构的补充</p>
<p><strong>Jenkins pipeline 支持的指令</strong></p>
<table>
<thead>
<tr class="header">
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>post</code></td>
<td>在执行完成后一些附加的步骤</td>
</tr>
<tr class="even">
<td><code>environment</code></td>
<td>用于设置环境变量</td>
</tr>
<tr class="odd">
<td><code>tools</code></td>
<td>自动下载并安装指定的工具, 并将其加入 PATH 变量</td>
</tr>
<tr class="even">
<td><code>input</code></td>
<td>暂停 pipeline, 提示输入内容</td>
</tr>
<tr class="odd">
<td><code>options</code></td>
<td>用于配置 Jenkins pipeline 本身的选项</td>
</tr>
<tr class="even">
<td><code>parallel</code></td>
<td>并行执行多个 step</td>
</tr>
<tr class="odd">
<td><code>parameters</code></td>
<td>执行 pipeline 前传入一些参数</td>
</tr>
<tr class="even">
<td><code>triggers</code></td>
<td>用于定义执行 pipeline 的触发器</td>
</tr>
<tr class="odd">
<td><code>when</code></td>
<td>根据给定的条件, 决定是否执行阶段内的步骤</td>
</tr>
</tbody>
</table>
<blockquote>
<p>在使用指令时, 需要注意的是每个指令都有自己的作用域, 如果指令使用的位置不正确, Jenkins 将会报错</p>
</blockquote>
<h3 id="post">post</h3>
<p><code>post</code> 指令用于 <code>pipeline</code> 或 <code>stage</code> 完成后执行一些附加的步骤, 根据完成的状态, <code>post</code> 部分分成多种条件块, 并且可以同时包含多种条件块</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: post */</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;build&#x27;</span>) &#123;</span><br><span class="line">            echo <span class="string">&quot;build stage&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        post &#123;</span><br><span class="line">            always &#123;</span><br><span class="line">                echo <span class="string">&quot;stage post always&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    post &#123;</span><br><span class="line">        changed &#123;</span><br><span class="line">            echo <span class="string">&quot;pipeline post changed&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        success &#123;</span><br><span class="line">            echo <span class="string">&quot;pipeline post success&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        failure &#123;</span><br><span class="line">            mail <span class="attr">to:</span> <span class="string">&#x27;team@example.com&#x27;</span>, <span class="attr">subject:</span> <span class="string">&#x27;the pipeline failed.&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 可选条件</span></span><br><span class="line"><span class="comment">always      不论当前完成状态是什么都执行</span></span><br><span class="line"><span class="comment">changed     只要当前完成状态与上一次完成状态不同就执行</span></span><br><span class="line"><span class="comment">fixed       上一次完成状态为失败或不稳定, 当前完成状态为成功时执行</span></span><br><span class="line"><span class="comment">regression  上一次完成状态为成功, 当前完成状态为失败, 不稳当或中止时执行</span></span><br><span class="line"><span class="comment">aborted     当前执行结果是中止状态时执行</span></span><br><span class="line"><span class="comment">failure     当前完成状态为失败时执行</span></span><br><span class="line"><span class="comment">success     当前完成状态为成功时执行</span></span><br><span class="line"><span class="comment">unstable    当前完成状态为不稳定时执行</span></span><br><span class="line"><span class="comment">cleanup     清理条件块, 不论当前完成状态是什么, 在其他所有条件块执行完成后都执行</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="options">options</h3>
<p><code>options</code> 指令用于配置整个 Jenkins pipeline 本身的选项</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: options */</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;build&#x27;</span>) &#123;</span><br><span class="line">            echo <span class="string">&quot;build stage&quot;</span></span><br><span class="line">            error(<span class="string">&quot;emmm...&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    options &#123;</span><br><span class="line">        retry(<span class="number">3</span>)</span><br><span class="line">        timeout(<span class="attr">time:</span> <span class="number">10</span>, <span class="attr">unit:</span> <span class="string">&#x27;MINUTES&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 常用选项</span></span><br><span class="line"><span class="comment">buildDiscarder           保存最近历史构建记录的数量</span></span><br><span class="line"><span class="comment">checkoutToSubdirectory   从版本控制库拉取源码时, 指定检出到工作空间的子目录</span></span><br><span class="line"><span class="comment">disableConcurrentBuilds  禁止pipeline并行执行</span></span><br><span class="line"><span class="comment">newContainerPerStage     当agent为docker或dockerfile时, 指定在同一个Jenkins节点上, 每个stage都分别运行在一个新的容器中</span></span><br><span class="line"><span class="comment">retry                    指定发生失败时进行重试的次数</span></span><br><span class="line"><span class="comment">timeout                  指定超时时间, 超出设置的时间将中止pipeline</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="when">when</h3>
<p><code>when</code> 指令允许 <code>pipeline</code> 根据给定的条件, 决定是否执行阶段内的步骤, 必须至少包含一个条件</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: when */</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;build&#x27;</span>) &#123;</span><br><span class="line">            echo <span class="string">&quot;build stage&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    when &#123;</span><br><span class="line">        branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 常用指令</span></span><br><span class="line"><span class="comment">branch       如果分支名称与给定值相同则执行</span></span><br><span class="line"><span class="comment">changelog    版本库的changelog符合正则表达式则执行</span></span><br><span class="line"><span class="comment">changeset    版本库的变更集合中包含一个或多个文件符合给定Ant风格路径表达式则执行</span></span><br><span class="line"><span class="comment">environment  环境变量的值与给定的值相同则执行</span></span><br><span class="line"><span class="comment">equals       期望值与给定的值相同则执行</span></span><br><span class="line"><span class="comment">expression   如果Groovy表达式返回的是true则执行</span></span><br><span class="line"><span class="comment">buildingTag  如果pipeline所执行的代码被打了tag则执行</span></span><br><span class="line"><span class="comment">tag          如果pipeline所执行的代码被打了tag且名称符合规则则执行</span></span><br><span class="line"><span class="comment">allOf        多条件, 所有条件都必须符合才执行</span></span><br><span class="line"><span class="comment">anyOf        多条件, 其中一个条件符合就执行</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="步骤">步骤</h2>
<p><code>pipeline</code> 结构决定的是 pipeline 整体流程, 但是真正做事的还是 <code>pipeline</code> 中的每一个步骤(step), 步骤是 <code>pipeline</code> 中不能再拆分的最小操作</p>
<h3 id="内置指令">内置指令</h3>
<h4 id="文件目录相关">文件目录相关</h4>
<ul>
<li><p><code>deleteDir</code> 删除当前目录</p></li>
<li><p><code>dir</code> 切换到目录</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dir(<span class="string">&quot;/var/logs&quot;</span>) &#123;</span><br><span class="line">    deleteDir()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>fileExists</code> 判断文件是否存在</p></li>
<li><p><code>isUnix</code> 判断是否为类 UNIX 系统</p></li>
<li><p><code>pwd</code> 确认当前目录</p></li>
<li><p><code>writeFile</code> 将内容写入指定文件中</p></li>
<li><p><code>readFile</code> 读取文件内容</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">script &#123;</span><br><span class="line">    writeFile(<span class="attr">file:</span> <span class="string">&quot;base64File&quot;</span>, <span class="attr">text:</span> <span class="string">&quot;amVua2lucyBib29r&quot;</span>, <span class="attr">encoding:</span> <span class="string">&quot;Base64&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> content = readFile(<span class="attr">file:</span> <span class="string">&quot;base64File&quot;</span>, <span class="attr">encoding:</span> <span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">    echo <span class="string">&quot;$&#123;content&#125;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="制品相关">制品相关</h4>
<ul>
<li><p><code>stash</code> 保存临时文件</p></li>
<li><p><code>unstash</code> 取出之前保存的文件</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">stages &#123;</span><br><span class="line">    stage(<span class="string">&#x27;stash&#x27;</span>) &#123;</span><br><span class="line">        agent &#123; label <span class="string">&quot;master&quot;</span> &#125;</span><br><span class="line">        steps &#123;</span><br><span class="line">            writeFile(<span class="attr">file:</span> <span class="string">&quot;a.txt&quot;</span>, <span class="attr">text:</span> <span class="string">&quot;$BUILD_NUMBER&quot;</span>)</span><br><span class="line">            stash(<span class="attr">name:</span> <span class="string">&quot;temp&quot;</span>, <span class="attr">includes:</span> <span class="string">&quot;a.txt&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stage(<span class="string">&#x27;unstage&#x27;</span>) &#123;</span><br><span class="line">        agent &#123; label <span class="string">&quot;node&quot;</span> &#125;</span><br><span class="line">        steps &#123;</span><br><span class="line">            script &#123;</span><br><span class="line">                unstash(<span class="string">&quot;temp&quot;</span>)</span><br><span class="line">                <span class="keyword">def</span> content = readFile(<span class="string">&quot;a.txt&quot;</span>)</span><br><span class="line">                echo <span class="string">&quot;$&#123;content&#125;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="命令相关">命令相关</h4>
<ul>
<li><code>sh</code> 执行 shell 命令</li>
<li><code>bat</code> 执行批处理命令</li>
<li><code>powershell</code> 执行 PowerShell 脚本</li>
</ul>
<h4 id="其他">其他</h4>
<ul>
<li><p><code>error</code> 主动报错, 中止当前 pipeline</p></li>
<li><p><code>tool</code> 使用预定义的工具</p></li>
<li><p><code>timeout</code> 代码块超时时间</p></li>
<li><p><code>waitUntil</code> 等待条件满足</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">timeout(<span class="number">50</span>) &#123;</span><br><span class="line">    waitUntil &#123;</span><br><span class="line">        script &#123;</span><br><span class="line">            <span class="keyword">def</span> r = sh <span class="attr">script:</span> <span class="string">&#x27;curl http://www.baidu.com&#x27;</span>, <span class="attr">returnStatus:</span> <span class="literal">true</span></span><br><span class="line">            <span class="keyword">return</span> (r == <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>entry</code> 重复执行块</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">retry(<span class="number">20</span>) &#123;</span><br><span class="line">    script &#123;</span><br><span class="line">        sh <span class="attr">script:</span> <span class="string">&#x27;curl http://www.baidu.com&#x27;</span>, <span class="attr">returnStatus:</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>sleep</code> 让 pipeline 休眠一段时间</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">sleep(<span class="attr">time:</span> <span class="string">&#x27;1&#x27;</span>, <span class="attr">unit:</span> <span class="string">&#x27;MINUTES&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="插件指令">插件指令</h3>
<p>步骤是可插拔的, 就像 Jenkins 的插件一样, 只需要对现有的插件进行一些修改, 就可以在 pipeline 中被当成一个步骤使用</p>
<p>pipeline plugin 的 GitHub 仓库给出了一个 <a href="https://github.com/jenkinsci/pipeline-plugin/blob/master/COMPATIBILITY.md">列表</a> 记录已经适配了 Jenkins pipeline 的插件</p>
<p>Jenkins 官方提供了 pipeline 步骤参考 <a href="https://jenkins.io/doc/pipeline/steps/">文档</a></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins 变量参数</title>
    <url>/2020/02/13/jenkins%20003/</url>
    <content><![CDATA[<h1 id="变量和参数">变量和参数</h1>
<h2 id="环境变量">环境变量</h2>
<p><strong>环境变量</strong> 可以看作是 pipeline 与 Jenkins 交互的媒介, 可以分为 <strong>Jenkins 内置变量</strong> 和 <strong>自定义变量</strong></p>
<h3 id="内置变量">内置变量</h3>
<p>在 <code>pipeline</code> 执行时, Jenkins 通过一个名为 <code>env</code> 的全局变量, 将 Jenkins 内置环境变量暴露出来</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 内置变量 */</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;example&#x27;</span>) &#123;</span><br><span class="line">            echo <span class="string">&quot;Running $&#123;env.BUILD_NUMBER&#125; on $&#123;env.JENKINS_URL&#125;&quot;</span></span><br><span class="line">            echo <span class="string">&quot;Running $env.BUILD_NUMBER on $env.JENKINS_URL&quot;</span></span><br><span class="line">            echo <span class="string">&quot;Running $&#123;BUILD_NUMBER&#125; on $&#123;JENKINS_URL&#125;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上方式都是合法的, 但是不推荐方法三, 因为出现变量冲突时非常难排查</span></span><br><span class="line"><span class="comment">/* 常用变量</span></span><br><span class="line"><span class="comment">BUILD_NUMBER  构建号, 累加的数字</span></span><br><span class="line"><span class="comment">BRANCH_NAME   分支名称, 多分支pipeline项目支持</span></span><br><span class="line"><span class="comment">BUILD_URL     当前构建的页面URL</span></span><br><span class="line"><span class="comment">GIT_BRANCH    分支名称, 通过Git拉取源码时支持</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在调试 <code>pipeline</code> 时, 可以在 <code>pipeline</code> 的开始阶段通过 <code>sh 'printenv'</code> 命令将 <code>env</code> 变量的属性值打印出来</p>
</blockquote>
<h3 id="自定义变量">自定义变量</h3>
<p>当 <code>pipeline</code> 变得复杂时, 就会有自定义的环境变量的需求, 声明式 pipeline 提供了 <code>environment</code> 指令, 方便自定义变量</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 自定义变量 */</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    <span class="comment">// 变量作用域为整个pipeline</span></span><br><span class="line">    environment &#123;</span><br><span class="line">        CC = <span class="string">&#x27;clang&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;example&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 变量作用域为当前阶段</span></span><br><span class="line">            environment &#123;</span><br><span class="line">                DEBUG_FLAGS = <span class="string">&#x27;-g&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">&quot;$&#123;CC&#125; $&#123;DEBUG_FLAGS&#125;&quot;</span></span><br><span class="line">                sh <span class="string">&#x27;printenv&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果在 <code>environment</code> 中定义的变量与 <code>env</code> 中的变量重名, 那么被重名的变量的值会被覆盖掉</p>
</blockquote>
<h3 id="全局变量">全局变量</h3>
<p>有时候, 需要定义一些全局的跨 pipeline 的自定义变量</p>
<p>进入 <code>Manage Jenkins / Configure System / Global properties</code> 节点, 添加全局环境变量, 自定义全局变量会被加入 <code>env</code> 属性列表中, 所以使用方法与 Jenkins 内置变量无异</p>
<h2 id="参数化">参数化</h2>
<p><strong>参数化</strong> 是指可以通过传参来决定 pipeline 的行为</p>
<h3 id="参数定义">参数定义</h3>
<p>在 Jenkins pipeline 中定义参数使用的是 <code>parameters</code> 指令, 被传入的参数会放到一个名为 <code>params</code> 的对象中, 在 <code>pipeline</code> 中可直接使用</p>
<blockquote>
<p>至少要手动执行一次, pipeline 才会被 Jenkins 加载生效, 生效后再执行项目时, 就可以设置参数值了</p>
</blockquote>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: parameters */</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    parameters &#123;</span><br><span class="line">        booleanParam(<span class="attr">name:</span> <span class="string">&#x27;flag&#x27;</span>, <span class="attr">description:</span> <span class="string">&#x27;&#x27;</span>, <span class="attr">defaultValue:</span> <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;build&#x27;</span>) &#123;</span><br><span class="line">            echo <span class="string">&quot;param value: $&#123;params.flag&#125;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 支持的参数类型</span></span><br><span class="line"><span class="comment">string        字符串类型</span></span><br><span class="line"><span class="comment">text          多行文本类型, 换行使用\n</span></span><br><span class="line"><span class="comment">booleanParam  布尔类型</span></span><br><span class="line"><span class="comment">choice        选择参数类型, 使用\n来分隔多个选项</span></span><br><span class="line"><span class="comment">file          文件类型</span></span><br><span class="line"><span class="comment">password      密码类型</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="参数传递">参数传递</h3>
<p>除了可以在执行项目时设置参数值外, 也可以通过 pipeline 调用另一个 pipeline 时传递参数值, 在 Jenkins pipeline 中使用 <code>build</code> 指令实现</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: build */</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;build&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                build (</span><br><span class="line">                    <span class="symbol">job:</span> <span class="string">&quot;pipeline_name&quot;</span>,</span><br><span class="line">                    <span class="symbol">parameters:</span> [</span><br><span class="line">                        booleanParam(<span class="attr">name:</span> <span class="string">&#x27;flag&#x27;</span>, <span class="attr">value:</span> <span class="literal">true</span>)</span><br><span class="line">                    ]</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 指令参数</span></span><br><span class="line"><span class="comment">job          目标pipeline任务的名称</span></span><br><span class="line"><span class="comment">parameters   可选, 数组类型, 传入目标pipeline的参数列表, 可选参数类型同定参方法</span></span><br><span class="line"><span class="comment">propagate    可选, 如果值为true(默认值), 则只有当下游任务的构建状态为SUCCESS时, 上游任务才算构建成功, 如果值为false, 则不论下游任务构建状态是什么, 上游任务都忽略</span></span><br><span class="line"><span class="comment">quietPeriod  可选, 整形类型, 触发下游任务后, 下游任务等待多久执行, 如果不设置此参数, 则等待时间由下游任务确定, 单位为秒</span></span><br><span class="line"><span class="comment">wait         可选, 是否等待下游任务执行完成, 默认值为true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果使用 <a href="https://plugins.jenkins.io/cloudbees-folder/">Folder</a> 插件, 可以像管理文件夹下的文件一样来管理 Jenkins 项目, 此时需要注意 <code>build</code> 指令的 <code>job</code> 参数的写法, 同一目录下时可以直接使用任务名称, 不同目录下时需要指定绝对路径</p>
</blockquote>
<h3 id="参数输入">参数输入</h3>
<p>执行 <code>input</code> 指令会暂停 pipeline, 直到用户输入参数, 这是一种特殊的参数化 pipeline 的方法</p>
<p><code>input</code> 指令的返回值类型取决于要返回的值的个数, 如果只返回一个值, 返回值类型就是这个值的类型, 如果有多个返回值, 则返回值类型就是 <code>Map</code> 类型</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: input */</span></span><br><span class="line">stages &#123;</span><br><span class="line">    stage(<span class="string">&#x27;build&#x27;</span>) &#123;</span><br><span class="line">        steps &#123;</span><br><span class="line">            timeout(<span class="attr">time:</span> <span class="number">1</span>, <span class="attr">unit:</span> <span class="string">&#x27;HOURS&#x27;</span>) &#123;</span><br><span class="line">                input(<span class="attr">message:</span> <span class="string">&#x27;发布或停止&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当pipeline执行到build阶段时就会暂停, 将鼠标指针移到虚线方块上, 会出现提示信息浮层, 默认按钮为Proceed(继续)或Abort(中止), 手动点击确认</span></span><br><span class="line"><span class="comment">// 与timeout指令同时使用可以实现超时自动中止pipeline, 防止无限等待</span></span><br></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: input */</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    environment &#123;</span><br><span class="line">        pm = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;params&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                pm = input(</span><br><span class="line">                    <span class="symbol">message:</span> <span class="string">&#x27;发布配置&#x27;</span>,</span><br><span class="line">                    <span class="symbol">ok:</span> <span class="string">&#x27;确定&#x27;</span>,</span><br><span class="line">                    <span class="symbol">parameters:</span> [</span><br><span class="line">                        choice(<span class="attr">choices:</span> <span class="string">&#x27;dev\ntest\nprod&#x27;</span>,</span><br><span class="line">                               <span class="symbol">description:</span> <span class="string">&#x27;环境&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;build_env&#x27;</span>),</span><br><span class="line">                        string(<span class="attr">defaultValue:</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                               <span class="symbol">description:</span> <span class="string">&#x27;域名&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;domain&#x27;</span>)</span><br><span class="line">                    ],</span><br><span class="line">                    <span class="symbol">submitter:</span> <span class="string">&#x27;admin&#x27;</span>,</span><br><span class="line">                    <span class="symbol">submitterParameter:</span> <span class="string">&#x27;APPROVER&#x27;</span></span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;build&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&quot;操作者: $&#123;pm[&#x27;APPROVER&#x27;]&#125;&quot;</span></span><br><span class="line">                echo <span class="string">&quot;发布环境: $&#123;pm[&#x27;build_env&#x27;]&#125;&quot;</span></span><br><span class="line">                echo <span class="string">&quot;发布域名: $&#123;pm[&#x27;domain&#x27;]&#125;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 指令参数</span></span><br><span class="line"><span class="comment">message             指令的提示消息</span></span><br><span class="line"><span class="comment">submitter           可选, 可以进行操作的用户名或用户组名, 使用逗号分隔</span></span><br><span class="line"><span class="comment">submitterParameter  可选, 保存input指令的实际操作者的用户名的变量名</span></span><br><span class="line"><span class="comment">ok                  可选, 自定义确定按钮的文本</span></span><br><span class="line"><span class="comment">parameters          自定义输入的参数列表, 可选参数类型同定参方法</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins 触发条件</title>
    <url>/2020/02/13/jenkins%20004/</url>
    <content><![CDATA[<h1 id="触发条件">触发条件</h1>
<p>可以配置 pipeline 按照一定的规则自动执行, 而这些规则被称为 pipeline <strong>触发条件</strong>, Jenkins pipeline 中使用 <code>trigger</code> 指令来定义触发条件</p>
<blockquote>
<p>需要手动触发一次任务, 让 Jenkins 加载 pipeline 后, <code>trigger</code> 指令才会生效</p>
</blockquote>
<h2 id="时间触发">时间触发</h2>
<p><strong>时间触发</strong> 是指定义一个时间, 时间到了就触发 pipeline 执行</p>
<h3 id="定时执行">定时执行</h3>
<p><strong>定时执行</strong> 的使用场景通常是执行一些周期性的工作</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: cron */</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    triggers &#123;</span><br><span class="line">        <span class="comment">// 每天0时0分执行</span></span><br><span class="line">        cron(<span class="string">&#x27;0 0 * * *&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Jenkins trigger cron 语法采用的是 UNIX cron 语法(有些细微区别)</span></span><br><span class="line"><span class="comment">/* Jenkins teigger cron 设计了一些人性化的别名</span></span><br><span class="line"><span class="comment">@yearly</span></span><br><span class="line"><span class="comment">@annually</span></span><br><span class="line"><span class="comment">@monthly</span></span><br><span class="line"><span class="comment">@weekly</span></span><br><span class="line"><span class="comment">@daily</span></span><br><span class="line"><span class="comment">@midnight</span></span><br><span class="line"><span class="comment">@hourly</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>在一些大型组织中, 会同时存在大量的同一时刻执行的定时任务, 在 Jenkins trigger cron 语法中使用 <code>H(hash)</code> 字符来解决这一问题</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: H */</span></span><br><span class="line">triggers &#123;</span><br><span class="line">    <span class="comment">// 代表在0时0分至0时59分之间任何一个时间点执行</span></span><br><span class="line">    cron(<span class="string">&#x27;H 0 * * *&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需注意的是, <code>H</code> 应用在某一天的字段时会有不准确的情况, 因为有些月份有31天, 有些却是28天</p>
</blockquote>
<h3 id="轮询代码库">轮询代码库</h3>
<p><strong>轮询代码库</strong> 是指定期到代码仓库询问代码是否有变化, 如果有变化就执行</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: pollSCM */</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    triggers &#123;</span><br><span class="line">        <span class="comment">// 每分钟判断一次代码是否有变化</span></span><br><span class="line">        pollSCM(<span class="string">&#x27;H/1 * * * *&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="事件触发">事件触发</h2>
<p><strong>事件触发</strong> 是指发生了某个事件就触发 pipeline 执行</p>
<h3 id="上游任务">上游任务</h3>
<p>当 B 任务的执行依赖 A 任务的执行结果时, A 就被称为 B 的上游任务</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: upstream */</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    triggers &#123;</span><br><span class="line">        upstream(<span class="attr">upstreamProjects:</span> <span class="string">&#x27;A&#x27;</span>, <span class="attr">threshold:</span> hudson.model.Result.SUCCESS)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// upstreamProjects 指定上游任务, 接收多个任务时, 使用逗号分隔</span></span><br><span class="line"><span class="comment">/* threshold 指定上游任务的执行结果，枚举值包括</span></span><br><span class="line"><span class="comment">ABORTED 中止</span></span><br><span class="line"><span class="comment">FAILURE 失败</span></span><br><span class="line"><span class="comment">SUCCESS 成功</span></span><br><span class="line"><span class="comment">UNSTABLE 不稳定</span></span><br><span class="line"><span class="comment">NOT_BUILD 多阶段构建时无法执行</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="gitlab-通知">GitLab 通知</h3>
<p><strong>GitLab 通知</strong> 是指当 GitLab 发现源代码有变化时, 触发 Jenkins 执行构建</p>
<h4 id="人工配置">人工配置</h4>
<p>Jenkins 安装 <a href="https://plugins.jenkins.io/gitlab-plugin/">GitLab 插件</a> 和 <a href="https://plugins.jenkins.io/git/">Git 插件</a>, 创建 pipeline 项目时在 <code>Build Triggers</code> 节点下勾选 <code>Build when a change is pushed to GitLab</code>, 配置会暴露一个 <code>GitLab webhook URL</code>, 点击 <code>Generate</code> 按钮生成 <code>Secret token</code></p>
<p>GitLab 在配置页 <code>Settings / Integrations</code> 节点下输入 <code>GitLab webhook URL</code> 和 <code>Secret token</code>, 添加好后可以在表单下方通过 <code>Test</code> 按钮选择 <code>Push events</code> 进行测试</p>
<h4 id="插件配置">插件配置</h4>
<p>Jenkins 的 <a href="https://plugins.jenkins.io/gitlab-plugin/">GitLab 插件</a> 实现了基于 GitLab 的 <code>trigger</code>, 通过配置 pipeline 就能实现通知触发</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: gitlab */</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    triggers &#123;</span><br><span class="line">        gitlab(</span><br><span class="line">            <span class="symbol">triggerOnPush:</span> <span class="literal">true</span>,</span><br><span class="line">            <span class="symbol">triggerOnMergeRequest:</span> <span class="literal">true</span>,</span><br><span class="line">            <span class="symbol">branchFilterType:</span> <span class="string">&#x27;All&#x27;</span>,</span><br><span class="line">            <span class="symbol">secretToken:</span> <span class="string">&#x27;84b630bb7e2e6eaf307a5981927c33bc&#x27;</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">triggerOnPush          当GitLab触发push事件时, 是否执行构建</span></span><br><span class="line"><span class="comment">triggerOnMergeRequest  当GitLab触发mergeRequest事件时, 是否执行构建</span></span><br><span class="line"><span class="comment">branchFilterType       只有符合条件的分支才会被触发, 可以设置的值有NameBasedFilter(基于分支名进行过滤), RegexBasedFilter(基于正则表达式对分支名进行过滤), All(所有分支都会触发)</span></span><br><span class="line"><span class="comment">includeBranchesSpec    基于branchFilterType值, 输入期望包括的分支的规则</span></span><br><span class="line"><span class="comment">excludeBranchesSpec    基于branchFilterType值, 输入期望排除的分支的规则</span></span><br><span class="line"><span class="comment">secretToken            对应人工配置的secretToken, 使用随机字符串生成即可</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="推送配置">推送配置</h4>
<p>当 Jenkins 执行完构建后, 可以将构建结果推送到 GitLab 的相应 <code>commit</code> 记录上, 这样就将构建状态与提交记录关联起来</p>
<p>进入 Jenkins 的 <code>Manager Jenkins / Configure System / GitLab</code> 节点下, 添加 GitLab 地址及认证等信息, 编辑 pipeline</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 推送配置 */</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    post &#123;</span><br><span class="line">        failure &#123;</span><br><span class="line">            updateGitlabCommitStatus(<span class="attr">name:</span> <span class="string">&#x27;build&#x27;</span>, <span class="attr">state:</span> <span class="string">&#x27;failed&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        success &#123;</span><br><span class="line">            updateGitlabCommitStatus(<span class="attr">name:</span> <span class="string">&#x27;build&#x27;</span>, <span class="attr">state:</span> <span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    options &#123;</span><br><span class="line">        <span class="comment">// 参数值需要同GitLab节点下配置的GitLab的Connection Name一致</span></span><br><span class="line">        gitLabConnection(<span class="string">&#x27;gitlab&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插件触发">插件触发</h2>
<p>其他系统想触发 Jenkins 项目执行, 只需要安装 <a href="https://plugins.jenkins.io/generic-webhook-trigger/">Generic Webhook Trigger</a> 插件, Jenkins 会暴露一个 API 接口 <code>&#123;JENKINS_DOMAIN&#125;/generic-webhook-trigger/invoke</code> 由插件来处理, 当 Jenkins 接收到接口的请求时, 会将请求代理给 GWT 插件处理, 触发逻辑由 GWT 插件提供, 大体上可以分为五个部分：</p>
<ol type="1">
<li>从请求中提取参数值;</li>
<li>根据标识的 <code>token</code> 判断是否触发;</li>
<li>根据请求的参数值判断是否触发;</li>
<li>日志打印控制;</li>
<li>响应控制</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: GenericTrigger */</span></span><br><span class="line">triggers &#123;</span><br><span class="line">    GenericTrigger(</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1.从请求中提取参数值 */</span></span><br><span class="line">        <span class="symbol">genericVariables:</span> [</span><br><span class="line">            [<span class="attr">key:</span> <span class="string">&#x27;refValue&#x27;</span>,</span><br><span class="line">             <span class="symbol">value:</span> <span class="string">&#x27;$.ref&#x27;</span>,</span><br><span class="line">             <span class="symbol">expressionType:</span> <span class="string">&#x27;JSONPath&#x27;</span>,</span><br><span class="line">             <span class="symbol">regexpFilter:</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">             <span class="symbol">defaultValue:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">            ]</span><br><span class="line">        ]，</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">genericVariables         从POST body中提取值</span></span><br><span class="line"><span class="comment">genericRequestVariables  从URL参数中提取值</span></span><br><span class="line"><span class="comment">genericHeaderVariables   从HTTP header中提取值</span></span><br><span class="line"><span class="comment">key             提取出的值的新变量名, 可用于pipeline其他步骤</span></span><br><span class="line"><span class="comment">value           JSONPath表示式或XPath表达式, 用于从提交的参数中提取值</span></span><br><span class="line"><span class="comment">expressionType  指定表达式类型, 可选, 默认为JSONPath</span></span><br><span class="line"><span class="comment">defaultValue    提取不到值时, 作为返回值, 可选</span></span><br><span class="line"><span class="comment">regexpFilter    过滤表达式, 对提取的值进行过滤, 可选</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2.根据标识的token判断是否触发 */</span></span><br><span class="line">        <span class="symbol">token:</span> <span class="string">&#x27;pipeline_token&#x27;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">token  用于配置pipeline的标识, 与请求时的token的值一致则触发执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3.根据请求的参数值判断是否触发 */</span></span><br><span class="line">        <span class="symbol">regexpFilterText:</span> <span class="string">&#x27;$refValue&#x27;</span>,</span><br><span class="line">        <span class="symbol">regexFilterExpression:</span> <span class="string">&#x27;refs/heads/(master|dev)&#x27;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">regexpFilterText       需要进行匹配的变量</span></span><br><span class="line"><span class="comment">regexFilterExpression  正则表达式, 变量的值符合时触发执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4.控制打印 */</span></span><br><span class="line">        <span class="symbol">printPostContent:</span> <span class="literal">true</span></span><br><span class="line">        <span class="symbol">printContributedVariables:</span> <span class="literal">true</span></span><br><span class="line">        <span class="symbol">causeString:</span> <span class="string">&#x27;Triggered on $refValue&#x27;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">printPostContent           将请求信息打印到日志上</span></span><br><span class="line"><span class="comment">printContributedVariables  将提取后的变量名及变量值打印到日志上</span></span><br><span class="line"><span class="comment">causeString                触发原因</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 5.响应控制 */</span></span><br><span class="line">        <span class="symbol">silentResponse:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">silentResponse  请求成功后, GWT插件会返回HTTP 200状态码和触发结果, 当参数设置为true时不返回触发结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins 认证凭证</title>
    <url>/2020/02/17/jenkins%20005/</url>
    <content><![CDATA[<h1 id="认证和凭证">认证和凭证</h1>
<h2 id="认证">认证</h2>
<p>Jenkins 默认启用安全检查, 支持两种认证方式:</p>
<ol type="1">
<li>Delegate to servlet container</li>
<li>Jenkins' own user database</li>
</ol>
<p>在 <code>Manager Jenkins ／ Configure Global Security ／ Security Realm</code> 节点下可以配置</p>
<blockquote>
<p>如果安装了 <a href="https://plugins.jenkins.io/ldap/">LDAP</a> 插件, 则可以使用 LDAP 认证</p>
</blockquote>
<h3 id="授权">授权</h3>
<p>Jenkins 默认的授权方式无法满足现实复杂的场景, 有三款插件分别支持不同维度的授权方式:</p>
<ol type="1">
<li>Matrix Authorization Strategy 基于矩阵的安全策略</li>
<li>Project-based Matrix Authorization Strategy 基于项目的矩阵授权策略</li>
<li>Role-based Authorization Strategy 基于角色的安全策略</li>
</ol>
<p>安装插件后, 在 <code>Manager Jenkins ／ Configure Global Security / Authorization</code> 节点下可以配置</p>
<h3 id="role-based-authorization-strategy">Role-based Authorization Strategy</h3>
<p>安装插件 <a href="https://plugins.jenkins.io/role-strategy/">Role-based Authorization Strategy</a> 后, 在 <code>Manager Jenkins</code> 菜单下增加了 <code>Manager and Assign Roles</code> 菜单项</p>
<p>进入 <code>Manager Jenkins / Manager and Assign Roles / Manager Roles</code> 页面, 可以分别设置三类角色:</p>
<ul>
<li>全局角色(Global roles)</li>
<li>项目角色(Project roles)</li>
<li>节点角色(Node roles)</li>
</ul>
<p>进入 <code>Manager Jenkins / Manager and Assign Roles / Assign Roles</code> 页面将角色分配给用户</p>
<h2 id="凭证">凭证</h2>
<p><strong>凭证(cridential)</strong> 是 Jenkins 进行受限操作时的凭据, 这些凭据不可能以明文写在 Jenkinsfile 中, Jenkins 凭证管理指的就是对这些凭证进行管理</p>
<p>进入 Jenkins 的 <code>Credentials / System / Global credentials</code> 节点下, 点击 <code>Add Credentials</code> 添加凭证, Jenkins 默认支持以下凭证类型:</p>
<ul>
<li>Secret text</li>
<li>Username with password</li>
<li>Secret file</li>
<li>SSH Username with private key</li>
<li>Certificate(PKCS #12)</li>
<li>Docker Host Certificate Authentication credentials</li>
</ul>
<p>添加凭证后, 安装 <a href="https://plugins.jenkins.io/credentials-binding/">Credentials Binding Plugin</a> 插件, 通过其提供的 <code>withCredentials</code> 指令就可以在 pipeline 中使用凭证了</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: Secret text */</span></span><br><span class="line">withCredentials([string(<span class="attr">credentialsId:</span> <span class="string">&#x27;secretText&#x27;</span>, <span class="attr">variable:</span> <span class="string">&#x27;st&#x27;</span>)]) &#123;</span><br><span class="line">    echo <span class="string">&quot;secret: $&#123;st&#125;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 示例: Username with password */</span></span><br><span class="line">withCredentials([usernamePassword(<span class="attr">credentialsId:</span> <span class="string">&#x27;userPwd&#x27;</span>,</span><br><span class="line">                                  <span class="symbol">usernameVariable:</span> <span class="string">&#x27;username&#x27;</span>,</span><br><span class="line">                                  <span class="symbol">passwordVariable:</span> <span class="string">&#x27;password&#x27;</span></span><br><span class="line">                                 )]) &#123;</span><br><span class="line">    echo <span class="string">&quot;username: $&#123;username&#125;“</span></span><br><span class="line"><span class="string">    echo &quot;</span><span class="attr">password:</span> $&#123;password&#125;<span class="string">&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// credentialsId需要同已配置的凭证的ID一致, 根据凭证类型不同会有不同的参数名称可以配置</span></span><br></pre></td></tr></table></figure>
<p>插件的 <code>withCredentials</code> 指令使用过于复杂, 所以声明式 pipeline 提供了 <code>credentials</code> 指令来简化凭证的使用, 但是只能在 <code>environment</code> 指令中使用</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: Secret text */</span></span><br><span class="line">environment &#123;</span><br><span class="line">    SECRET_TEXT = credentials(<span class="string">&#x27;secretText&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">stages &#123;</span><br><span class="line">    stage(<span class="string">&#x27;build&#x27;</span>) &#123;</span><br><span class="line">        echo <span class="string">&quot;secret: $&#123;SECRET_TEXT&#125;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: Username with password */</span></span><br><span class="line">environment &#123;</span><br><span class="line">    UP_CREDS = credentials(<span class="string">&#x27;userPwd&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">stages &#123;</span><br><span class="line">    stage(<span class="string">&#x27;build&#x27;</span>) &#123;</span><br><span class="line">        echo <span class="string">&quot;up: $&#123;UP_CREDS&#125;&quot;</span></span><br><span class="line">        echo <span class="string">&quot;username: $&#123;UP_CREDS_USR&#125;&quot;</span></span><br><span class="line">        echo <span class="string">&quot;password: $&#123;UP_CREDS_PSW&#125;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// $&#123;UP_CREDS&#125;的值的格式为&lt;username&gt;:&lt;password&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过 <code>credentials</code> 指令可以像使用环境变量一样使用凭证, 但是该指令只支持 <code>Secret Text</code>, <code>Username with passwrod</code>, <code>Secret file</code> 三种凭证</p>
</blockquote>
<h3 id="hashicorp-valut">HashiCorp Valut</h3>
<p><a href="https://plugins.jenkins.io/hashicorp-vault-plugin/">HashiCorp Valut</a> 是一款对敏感信息进行存储, 并进行访问控制的工具, 它不仅可以存储敏感信息, 还具有滚动更新, 审计等功能</p>
<p><a href="https://github.com/jenkinsci/hashicorp-vault-pipeline-plugin">Hashicorp Vault Pipeline</a> 插件提供了用于 pipeline 使用的指令 <code>valut</code></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: valut */</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    environment &#123;</span><br><span class="line">        SECRET = vault(<span class="attr">path:</span> <span class="string">&#x27;secret/hello&#x27;</span>, <span class="attr">key:</span> <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;build&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&quot;value: $&#123;SECRET&#125;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 指令参数</span></span><br><span class="line"><span class="comment">path           存储键值对的路径</span></span><br><span class="line"><span class="comment">key            存储内容的键</span></span><br><span class="line"><span class="comment">vaultUrl       可选, vault服务地址, 默认使用系统级别的配置</span></span><br><span class="line"><span class="comment">credentialsId  可选, vault服务认证的凭证</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins 扩展插件</title>
    <url>/2020/03/30/jenkins%20006/</url>
    <content><![CDATA[<h1 id="扩展插件">扩展插件</h1>
<h2 id="扩展">扩展</h2>
<p>在大量使用 pipeline 后会发现 Jenkins 内置的功能并不能照顾到所有的需求, 这时就需要扩展 pipeline</p>
<h3 id="函数">函数</h3>
<p>pipeline 本质是一个 Groovy 脚本, 所以可以在 pipeline 中定义函数, 并使用 Groovy 语言自带的特性</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 定义函数 */</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;build&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&quot;$&#123;createVersion(BUILD_NUMBER)&#125;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">def</span> createVersion(String BUILD_NUMBER) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date().format(<span class="string">&#x27;yyMM&#x27;</span>) + <span class="string">&quot;-$&#123;BUILD_NUMBER&#125;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="共享库">共享库</h3>
<p>Jenkins pipeline 提供了 <strong>共享库(Shared library)</strong> 技术, 可以将重复代码定义在一个独立的代码控制仓库中, 其他的 Jenkins pipeline 加载使用它</p>
<p>创建共享库项目并推送到 SCM, 在 <code>Manager Jenkins / Configure System / Global Pipeline Libraries</code> 节点下配置全局共享库</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 共享库结构 */</span></span><br><span class="line">├─src</span><br><span class="line">│  └─codes</span><br><span class="line">│     └─showme</span><br><span class="line">│        └─Utils.groovy</span><br><span class="line">└─vars</span><br><span class="line">   └─sayHello.groovy</span><br><span class="line"></span><br><span class="line"><span class="comment">// src目录是一个标准的Java源码结构, 目录中的类被称为库类</span></span><br><span class="line"><span class="comment">// vars目录是可以在pipeline中直接调用的全局变量, 变量的文件名即调用的函数名</span></span><br></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 文件: src/codes/showme/Utils.groovy */</span></span><br><span class="line"><span class="keyword">package</span> codes.showme</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Utils</span> <span class="keyword">implements</span> <span class="title">Serializable</span> &#123;</span></span><br><span class="line">    <span class="keyword">def</span> getVersion(String BUILD_NUMBER, String GIT_COMMIT) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Date().format(<span class="string">&#x27;yyMM&#x27;</span>) + <span class="string">&quot;-$&#123;BUILD_NUMBER&#125;&quot;</span> + <span class="string">&quot;-$&#123;GIT_COMMIT&#125;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 库类可以使用@Grab注解使用第三方依赖</span></span><br></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 文件: vars/sayHello.groovy */</span></span><br><span class="line"><span class="keyword">def</span> call(String name) &#123;</span><br><span class="line">    echo <span class="string">&quot;hello $&#123;name&#125;.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 全局变量实际调用的是文件中的call函数, 函数中可以直接调用pipeline的步骤, 函数参数还支持接收闭包</span></span><br></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 共享库 */</span></span><br><span class="line"><span class="meta">@Library</span>(<span class="string">&#x27;global-shared-library&#x27;</span>) <span class="comment">// 使用@Library指定共享库, 需要与全局共享库配置的Name一致</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;build&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sayHello(<span class="string">&#x27;world&#x27;</span>) <span class="comment">// 使用共享库vars目录中定义的全局变量</span></span><br><span class="line">                script &#123; <span class="comment">// 使用src目录中的类时, 需要使用全包名, 同时因为写的是Groovy代码, 所以需要使用script指令</span></span><br><span class="line">                    <span class="keyword">def</span> util = <span class="keyword">new</span> codes.showme.Utils()</span><br><span class="line">                    <span class="keyword">def</span> v = util.getVersion(<span class="string">&quot;$&#123;BUILD_NUMBER&#125;&quot;</span>, <span class="string">&quot;$&#123;GIT_COMMIT&#125;&quot;</span>)</span><br><span class="line">                    echo <span class="string">&quot;$&#123;v&#125;&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @Library语法</span></span><br><span class="line"><span class="meta">@Library</span>(<span class="string">&#x27;Name@version&#x27;</span>)</span><br><span class="line"><span class="comment">// Jenkins支持添加多个共享库, 所以@Library注解允许同时引入多个共享库, 出现同名函数时的处理方式是先定义者生效</span></span><br><span class="line"><span class="meta">@Library</span>([<span class="string">&#x27;Name@version&#x27;</span>, <span class="string">&#x27;Name2@version2&#x27;</span>])</span><br></pre></td></tr></table></figure>
<h3 id="共享库模板">共享库模板</h3>
<p>声明式 pipeline 在 <code>1.2</code> 版本后, 可以在共享库中定义 <code>pipeline</code>, 通过此特性, 可以定义 pipeline 的模板, 如果大多数项目的结构都是标准化的, 那么利用 pipeline 模板技术可以大大降低维护 pipeline 的成本</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 共享库代码 */</span></span><br><span class="line"><span class="comment">/* vars/generatePipeline.groovy */</span></span><br><span class="line"><span class="keyword">def</span> call(String lang) &#123;</span><br><span class="line">    <span class="keyword">if</span>(lang == <span class="string">&#x27;go&#x27;</span>) &#123;</span><br><span class="line">        pipeline &#123;</span><br><span class="line">            <span class="comment">// 代码同pipeline定义</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(lang == <span class="string">&#x27;java&#x27;</span>) &#123;</span><br><span class="line">        pipeline &#123;</span><br><span class="line">            <span class="comment">// 代码同pipeline定义</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 使用模板 */</span></span><br><span class="line"><span class="meta">@Library</span>(<span class="string">&#x27;global-shared-library&#x27;</span>)</span><br><span class="line">generatePipeline(<span class="string">&#x27;go&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="插件">插件</h2>
<p>Jenkins 插件开发文档 <a href="https://wiki.jenkins.io/display/JENKINS/Plugin+tutorial">TUTORIAL</a>, 使用 Maven 的 <code>archetype</code> 插件生成代码骨架, 非常简单</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 使用mvn命令生成项目</span></span><br><span class="line">mvn archetype:generate -Dfilter=io.jenkins.archetypes:hello-world-plugin</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成的代码骨架</span></span><br><span class="line">├───pom.xml</span><br><span class="line">└───src</span><br><span class="line">    ├───main</span><br><span class="line">    │   ├───java</span><br><span class="line">    │   │   └───io</span><br><span class="line">    │   │       └───jenkins</span><br><span class="line">    │   │           └───plugins</span><br><span class="line">    │   │               └───sample</span><br><span class="line">    │   │                   └───HelloWorldBuilder.java</span><br><span class="line">    │   └───resources</span><br><span class="line">    │       ├───index.jelly</span><br><span class="line">    │       └───(省略i18n文件)</span><br><span class="line">    └───test</span><br><span class="line">        └───java</span><br><span class="line">            └───io</span><br><span class="line">                └───jenkins</span><br><span class="line">                    └───plugins</span><br><span class="line">                        └───sample</span><br><span class="line">                            └───HelloWorldBuilderTest.java</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> pom.xml的&lt;name&gt;标签     定义插件的名称</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> HelloWorldBuilder.java  步骤具体实现类</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> index.jelly             插件管理页面显示的HTML内容</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 文件: HelloWorldBuilder.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> <span class="keyword">implements</span> <span class="title">SimpleBuildStep</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> useFrench;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @DataBoundConstructor注解标识插件类的构造函数, name属性为插件默认属性, 也是调用插件时的必要参数</span></span><br><span class="line">    <span class="meta">@DataBoundConstructor</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloWorldBuilder</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUseFrench</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> useFrench;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @DataBoundSetter注解标识插件属性的setter方法</span></span><br><span class="line">    <span class="meta">@DataBoundSetter</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUseFrench</span><span class="params">(<span class="keyword">boolean</span> useFrench)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.useFrench = useFrench;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">perform</span><span class="params">(Run&lt;?, ?&gt; run, FilePath workspace, Launcher launcher, TaskListener listener)</span> <span class="keyword">throws</span> InterruptedException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 插件的执行逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (useFrench) &#123;</span><br><span class="line">            listener.getLogger().println(<span class="string">&quot;Bonjour, &quot;</span> + name + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            listener.getLogger().println(<span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩展点唯一标识, 被定义在扩展点上, 可以理解为在pipeline中使用插件时所引用的函数名, 本例的扩展点标识为greet</span></span><br><span class="line">    <span class="meta">@Symbol(&quot;greet&quot;)</span></span><br><span class="line">    <span class="comment">// 扩展点注解, 通过此注解自动发现扩展点, 并将扩展点加入扩展点列表中</span></span><br><span class="line">    <span class="meta">@Extension</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DescriptorImpl</span> <span class="keyword">extends</span> <span class="title">BuildStepDescriptor</span>&lt;<span class="title">Builder</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> FormValidation <span class="title">doCheckName</span><span class="params">(<span class="meta">@QueryParameter</span> String value, <span class="meta">@QueryParameter</span> <span class="keyword">boolean</span> useFrench)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (value.length() == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> FormValidation.error(Messages.HelloWorldBuilder_DescriptorImpl_errors_missingName());</span><br><span class="line">            <span class="keyword">if</span> (value.length() &lt; <span class="number">4</span>)</span><br><span class="line">                <span class="keyword">return</span> FormValidation.warning(Messages.HelloWorldBuilder_DescriptorImpl_warnings_tooShort());</span><br><span class="line">            <span class="keyword">if</span> (!useFrench &amp;&amp; value.matches(<span class="string">&quot;.*[éáàç].*&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> FormValidation.warning(Messages.HelloWorldBuilder_DescriptorImpl_warnings_reallyFrench());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> FormValidation.ok();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isApplicable</span><span class="params">(Class&lt;? extends AbstractProject&gt; aClass)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getDisplayName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Messages.HelloWorldBuilder_DescriptorImpl_DisplayName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Jenkins 插件开发的代码骨架中, <code>pom.xml</code> 文件默认添加了用于插件开发的 Maven 插件 <code>maven-hpi-plugin</code>, 通过该插件, 只需要实现插件代码, 然后执行 <code>mvn hpi:run</code> 就可以启动一个安装了插件的 Jenkins 实例, 在浏览器中打开 <code>http://localhost:8080/jenkins</code> 即可访问</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 在Jenkinsfile中使用插件 */</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;build&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                greet(<span class="attr">name:</span> <span class="string">&#x27;build&#x27;</span>, <span class="attr">useFrench:</span> <span class="literal">false</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// greet是通过@Symbol定义的插件扩展点名称, 可以将这个名称理解为一个函数名, @DataBoundConstructor和@DataBoundSetter注解的方法可以理解为这个函数的参数</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins 架构</title>
    <url>/2020/07/09/jenkins%20007/</url>
    <content><![CDATA[<h1 id="架构">架构</h1>
<p>Jenkins 项目都是在 executor 上执行的, 假如单机足够强大, 让更多项目同时执行的方法就是增加 executor, 但单机的容量总会遇到上限, 而且还会有单节点问题, 解决办法就是将 Jenkins 项目分配到多台机器上执行</p>
<h2 id="节点">节点</h2>
<p>Jenkins 采用的是 <code>master/agent</code> 架构, Jenkins master 负责提供界面, 处理 HTTP 请求及管理构建环境, 构建的执行则由 Jenkins agent 负责</p>
<p>基于这样的架构, 只需要增加 agent 就可以轻松支持更多的项目同时执行, 这种方式称为 Jenkins agent 的 <strong>横向扩容</strong></p>
<pre class="mermaid">graph LR
title[图 Jenkins 架构示意图]
title --> B
style title fill:#FFF,stroke:#FFF
linkStyle 0 stroke:#FFF,stroke-width:0;
A(用户)
B(Jenkins master)
C1(Jenkins agent1)
C2(Jenkins agent2)
A --http--> B
B --> C1
B --> C2</pre>
<p>实现分布式构建最常用, 最基本的方式就是增加 agent, Jenkins agent 作为一个负责执行任务的程序, 它需要与 Jenkins master 建立双向连接, 连接方式有多种, 这也代表有多种增加 agent 的方式</p>
<h3 id="agent">agent</h3>
<p>进入 <code>Manage Jenkins / Manage Nodes and Clouds</code> 节点下, 点击左侧 <code>New Node</code> 创建 agent 节点, 填写节点相关信息, 默认启动方式 <code>Launch method</code> 有以下可选:</p>
<ul>
<li><code>Launch agent agents via SSH</code> 通过 master 以 ssh 连接方式启用代理节点;</li>
<li><code>Launch agent by connecting it to the master</code> 代理节点就绪时连接 master;</li>
<li><code>Launch agent via execution of command on the master</code> 通过 master 执行命令来启用代理节点;</li>
<li><code>Let Jenkins control this Windows slave as a Windows service</code> 通过 master 启用 Windows 代理节点</li>
</ul>
<blockquote>
<p>当使用第 2 种方式创建代理节点时, 需要在代理主机上运行下载的 <code>agent.jar</code>, 运行成功后该节点通过 Java Web Start (JWS) 方式连接 master, 因此需要配置 Jenkins 的代理协议</p>
</blockquote>
<p>进入 <code>Manage Jenkins / Configure Global Security / Agents</code> 节点下, 选择开放固定端口或随机开放端口来提供 TCP 通信服务, 代理协议 <code>Agent protocols</code> 勾选与 JWS 相关的协议</p>
<blockquote>
<p>当使用除第 2 种以外的方式创建代理节点时, 需要 master 主机能够通过 IP 地址访问到代理主机</p>
</blockquote>
<h3 id="swarm">swarm</h3>
<p><a href="https://plugins.jenkins.io/swarm/">Swarm</a> 插件可以不需要在 Jenkins 界面上手动操作的方式增加代理节点, 安装好插件后, 只需要在代理主机上启动 Swarm 客户端, 指定 Jenkins master 地址和认证信息, 就可以自动建立 agent 与 master 的连接</p>
<h3 id="标签">标签</h3>
<p>当节点数量变多时, 可以通过 <strong>标签(label)</strong> 将多个 agent 分配到同一个逻辑组中, 同一个 agent 可以拥有多个标签, 在标签名中不能包含空格和特殊字符</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: label */</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent &#123;</span><br><span class="line">        label <span class="string">&#x27;windows &amp;&amp; jdk8&#x27;</span> <span class="comment">// 构建任务指定在同时具有windows和jdk8标签的agent中执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">agent       定义执行任务时所在的agent</span></span><br><span class="line"><span class="comment">agent any   任何可用的agent都可以执行</span></span><br><span class="line"><span class="comment">agent none  不分配任何agent, 此方式适用于每个构建阶段都运行在指定agent中</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: node */</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent &#123;</span><br><span class="line">        node &#123; <span class="comment">// 完整结构, 可以简写成前一示例</span></span><br><span class="line">            label <span class="string">&#x27;windows &amp;&amp; jdk8&#x27;</span></span><br><span class="line">            customWorkspace <span class="string">&#x27;/var/lib/custom&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* node指令参数</span></span><br><span class="line"><span class="comment">label            指定节点的标签</span></span><br><span class="line"><span class="comment">customWorkspace  自定义工作目录</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>在默认情况下, 阶段内所有的代码都将在指定的 Jenkins agent 上执行, <code>when</code> 指令提供了 <code>beforeAgent</code> 选项, 用于只有符合条件时才会进入该 agent, 这样就可以避免没有必要的工作空间的分配</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: beforeAgent */</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">	agent none</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;build&#x27;</span>) &#123;</span><br><span class="line">            agent <span class="string">&#x27;jdk8&#x27;</span></span><br><span class="line">            when &#123; <span class="comment">// 只有分支为production时, 才会进入该节点执行构建</span></span><br><span class="line">                beforeAgent <span class="literal">true</span></span><br><span class="line">                branch <span class="string">&#x27;production&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&quot;deploying&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Jenkins master 要将构建任务分配给 Docker, 就必须在 Jenkins agent 上安装 Docker, 需要注意, 要将 Jenkins agent 的用户加入 Docker 用户组中, 这样 Jenkins agent 不需要加 <code>sudo</code> 就能执行 <code>docker</code> 命令</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: docker */</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent &#123;</span><br><span class="line">        docker &#123;</span><br><span class="line">            <span class="symbol">label:</span> <span class="string">&#x27;docker&#x27;</span></span><br><span class="line">            <span class="symbol">image:</span> <span class="string">&#x27;maven:3&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;build&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">&#x27;mvn clean compile&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* docker指令参数</span></span><br><span class="line"><span class="comment">label       指定节点的标签</span></span><br><span class="line"><span class="comment">image       字符串类型, 指定构建时使用的Docker镜像</span></span><br><span class="line"><span class="comment">args        字符串类型, 执行docker run命令时所带的参数</span></span><br><span class="line"><span class="comment">alwaysPull  布尔类型, 强制每次执行docker pull命令时都重新拉取镜像</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>Docker 拉取镜像时, 默认是从 Docker 官方中心仓库拉取的, Jenkins 提供了 Docker 私有仓库的配置, 进入 <code>Manage Jenkins / Configure System / Declarative Pipeline (Docker)</code> 节点下, 填写私服相关信息和认证凭据</p>
<h2 id="并行">并行</h2>
<p>对于按环境构建或测试的情况, 按顺序执行的方式显得太慢了, 因此声明式语法提供了 <code>parallel</code> 指令</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 并行阶段 */</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent none</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;test&#x27;</span>) &#123;</span><br><span class="line">            failFast <span class="literal">true</span> <span class="comment">// 并行阶段中的某个阶段失败后, 就让其他正在执行的阶段都中止</span></span><br><span class="line">            parallel &#123;</span><br><span class="line">                stage(<span class="string">&#x27;firefox&#x27;</span>) &#123;</span><br><span class="line">                    agent &#123; label <span class="string">&#x27;firefox&#x27;</span> &#125;</span><br><span class="line">                    steps &#123; echo <span class="string">&quot;test on firefox&quot;</span> &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                stage(<span class="string">&#x27;chrome&#x27;</span>) &#123;</span><br><span class="line">                    agent &#123; label <span class="string">&#x27;chrome&#x27;</span> &#125;</span><br><span class="line">                    steps &#123; echo <span class="string">&quot;test on chrome&quot;</span> &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并行阶段运行在不同的 executor 上</span></span><br></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 并发步骤 */</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent &#123; label <span class="string">&#x27;jdk&#x27;</span> &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;build&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                parallel(</span><br><span class="line">                    <span class="symbol">jdk8:</span> &#123;</span><br><span class="line">                        echo <span class="string">&quot;build on jdk8&quot;</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="symbol">jdk14:</span> &#123;</span><br><span class="line">                        echo <span class="string">&quot;build on jdk14&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并发步骤运行在同一个 executor 上</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins 代码质量</title>
    <url>/2020/05/26/jenkins%20008/</url>
    <content><![CDATA[<h1 id="代码质量">代码质量</h1>
<h2 id="静态代码分析">静态代码分析</h2>
<p><strong>静态代码分析</strong> 是指在不运行程序的前提下, 对源代码进行分析或检查, 范围包括代码风格, 可能出现的空指针, 代码块大小, 重复的代码等</p>
<p><a href="https://pmd.github.io/">PMD</a> 是一款可扩展的静态代码分析器, 它不仅可以对代码风格进行检查, 还可以检查设计, 多线程, 性能等方面的问题</p>
<p>安装 Jenkins 的 <a href="https://plugins.jenkins.io/pmd/">PMD</a> 插件可以将 PMD 报告呈现在任务详情页中</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: pmd */</span></span><br><span class="line">stages &#123;</span><br><span class="line">    stage(<span class="string">&#x27;pmd&#x27;</span>) &#123;</span><br><span class="line">        steps &#123;</span><br><span class="line">            sh <span class="string">&quot;mvn pmd:pmd&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">post &#123;</span><br><span class="line">    always &#123;</span><br><span class="line">        pmd(<span class="attr">canRunOnFailed:</span> <span class="literal">true</span>, <span class="attr">pattern:</span> <span class="string">&#x27;**/target/pmd.xml&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单元测试">单元测试</h2>
<p><a href="https://junit.org/junit4/">Junit</a> 是一个 Java 语言的单元测试框架, 可以根据执行的单元测试生成测试报告</p>
<p>安装 Jenkins 的 <a href="https://plugins.jenkins.io/junit/">Junit</a> 插件可以将 Junit 的报告呈现在任务详情页中</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: junit */</span></span><br><span class="line">stages &#123;</span><br><span class="line">    stage(<span class="string">&#x27;junit&#x27;</span>) &#123;</span><br><span class="line">        sh <span class="string">&quot;mvn test&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">post &#123;</span><br><span class="line">    always &#123;</span><br><span class="line">        junit(<span class="attr">testResults:</span> <span class="string">&#x27;**/target/surefire-reports/*.xml&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码覆盖率">代码覆盖率</h2>
<p><a href="https://www.jacoco.org/jacoco/">JaCoCo</a> 是一个免费的 Java 代码覆盖率的库, 可以检测出代码覆盖率, 并生成覆盖率报告, JaCoCo 提供了以下几个维度的覆盖率分析:</p>
<ul>
<li>指令覆盖率 (Instruction Coverage)</li>
<li>分支覆盖率 (Branch Coverage)</li>
<li>圈复杂度覆盖率 (Cyclomatic Complexity Coverage)</li>
<li>行覆盖率 (Line Coverage)</li>
<li>方法覆盖率 (Method Coverage)</li>
<li>类覆盖率 (Class Coverage)</li>
</ul>
<p>安装 Jenkins 的 <a href="https://plugins.jenkins.io/jacoco/">JaCoCo</a> 插件可以将 JaCoCo 生成的代码覆盖率呈现在任务详情页中</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: jacoco */</span></span><br><span class="line">stage(<span class="string">&#x27;jacoco&#x27;</span>) &#123;</span><br><span class="line">    steps &#123;</span><br><span class="line">        sh <span class="string">&quot;mvn jacoco:report&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">post &#123;</span><br><span class="line">    always &#123;</span><br><span class="line">        jacoco (</span><br><span class="line">            <span class="comment">// 代码覆盖率统计文件位置</span></span><br><span class="line">            <span class="symbol">execPattern:</span> <span class="string">&#x27;target/**/*.exec&#x27;</span>,</span><br><span class="line">            <span class="comment">// classes文件位置</span></span><br><span class="line">            <span class="symbol">classPattern:</span> <span class="string">&#x27;target/classes&#x27;</span>,</span><br><span class="line">            <span class="comment">// 源码文件位置</span></span><br><span class="line">            <span class="symbol">sourcePattern:</span> <span class="string">&#x27;src/main/java&#x27;</span>,</span><br><span class="line">            <span class="comment">// 排除分析的位置</span></span><br><span class="line">            <span class="symbol">exclusionPattern:</span> <span class="string">&#x27;src/test*&#x27;</span>,</span><br><span class="line">            <span class="comment">// 是否禁用每行覆盖率的源文件显示</span></span><br><span class="line">            <span class="symbol">skinCopyOfSrcFiles:</span> <span class="literal">false</span>,</span><br><span class="line">            <span class="comment">// 如果为true, 则对各维度的覆盖率进行比较, 如果任何一个维度的当前覆盖率小于最小覆盖率阈值, 则构建状态为失败, 如果当前覆盖率在最大阈值和最小阈值之间, 则当前构建状态为不稳定, 如果当前覆盖率大于最大阈值, 则构建成功</span></span><br><span class="line">            <span class="symbol">changeBuildStatus:</span> <span class="literal">true</span>,</span><br><span class="line">            <span class="comment">// 字节码指令覆盖率</span></span><br><span class="line">            <span class="symbol">minimumInstructionCoverage:</span> <span class="string">&#x27;30&#x27;</span>, <span class="attr">maximumInstructionCoverage:</span> <span class="string">&#x27;70&#x27;</span>,</span><br><span class="line">            <span class="comment">// 行覆盖率</span></span><br><span class="line">            <span class="symbol">minimumLineCoverage:</span> <span class="string">&#x27;30&#x27;</span>, <span class="attr">maximumLineCoverage:</span> <span class="string">&#x27;70&#x27;</span>,</span><br><span class="line">            <span class="comment">// 圈复杂度覆盖率</span></span><br><span class="line">            <span class="symbol">minimumComplexityCoverage:</span> <span class="string">&#x27;30&#x27;</span>, <span class="attr">maximumComplexityCoverage:</span> <span class="string">&#x27;70&#x27;</span>,</span><br><span class="line">            <span class="comment">// 方法覆盖率</span></span><br><span class="line">            <span class="symbol">minimumMethodCoverage:</span> <span class="string">&#x27;30&#x27;</span>, <span class="attr">maximumMethodCoverage:</span> <span class="string">&#x27;70&#x27;</span>,</span><br><span class="line">            <span class="comment">// 类覆盖率</span></span><br><span class="line">            <span class="symbol">minimumClassCoverage:</span> <span class="string">&#x27;30&#x27;</span>, <span class="attr">maximumClassCoverage:</span> <span class="string">&#x27;70&#x27;</span>,</span><br><span class="line">            <span class="comment">// 分支覆盖率</span></span><br><span class="line">            <span class="symbol">minimumBranchCoverage:</span> <span class="string">&#x27;30&#x27;</span>, <span class="attr">maximumBranchCoverage:</span> <span class="string">&#x27;70&#x27;</span>,</span><br><span class="line">            <span class="comment">// 如果为true, 则只有所有维度的覆盖率变化量的绝对值小于相应的变化量阈值时, 构建结果才为成功</span></span><br><span class="line">            <span class="symbol">buildOverBuild:</span> <span class="literal">true</span>,</span><br><span class="line">            <span class="comment">// 各个维度覆盖率的变化量阈值</span></span><br><span class="line">            <span class="symbol">deltaInstructionCoverage:</span> <span class="string">&#x27;80&#x27;</span>,</span><br><span class="line">            <span class="symbol">deltaLineCoverage:</span> <span class="string">&#x27;80&#x27;</span>,</span><br><span class="line">            <span class="symbol">deltaMethodCoverage:</span> <span class="string">&#x27;80&#x27;</span>,</span><br><span class="line">            <span class="symbol">deltaClassCoverage:</span> <span class="string">&#x27;80&#x27;</span>,</span><br><span class="line">            <span class="symbol">deltaComplexityCoverage:</span> <span class="string">&#x27;80&#x27;</span>,</span><br><span class="line">            <span class="symbol">deltaBranchCoverage:</span> <span class="string">&#x27;80&#x27;</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="性能测试">性能测试</h2>
<p><a href="">Taurus</a> 是一个开源的自动化框架, 用于运行各种开源负载测试工具和功能测试工具, 其支持最流行的开源负载测试工具 Apache JMeter, Selenium, Gatling, The Grinder 等</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins 管理</title>
    <url>/2020/05/26/jenkins%20009/</url>
    <content><![CDATA[<h1 id="管理">管理</h1>
<h2 id="制品">制品</h2>
<p><strong>制品</strong> 是软件开发过程中产生的多种有形副产品之一, 狭义的制品可以简单地理解为二进制包, 广义的制品还包括用例, UML 图, 设计文档等</p>
<p>最简单的制品管理仓库就是将制品统一放在一个系统目录结构下, 但是更多的做法是使用现成的制品库, 目前现成的制品库有 <a href="https://www.sonatype.com/nexus-repository-oss">Nexus</a>, <a href="https://jfrog.com/artifactory/">Artifactory</a> 等</p>
<h3 id="maven-制品">Maven 制品</h3>
<p>Maven 团队提供的官方插件支持将打包后的制品发布到配置的仓库中</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: deploy */</span></span><br><span class="line">stages &#123;</span><br><span class="line">    stage(<span class="string">&#x27;deploy&#x27;</span>) &#123;</span><br><span class="line">        sh <span class="string">&quot;mvn deploy&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Nexus 提供了 <a href="https://plugins.jenkins.io/nexus-jenkins-plugin/">Nexus Platform</a> 插件发布 Maven 制品, 安装好插件后, 在 <code>Manage Jenkins / Configure System / Sonatype Nexus</code> 节点下配置 Nexus 服务器地址</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: nexusPublisher */</span></span><br><span class="line">stages &#123;</span><br><span class="line">    stage(<span class="string">&#x27;deploy&#x27;</span>) &#123;</span><br><span class="line">        nexusPublisher(</span><br><span class="line">            <span class="comment">// 需要与配置的Nexus的ServerId一致</span></span><br><span class="line">            <span class="symbol">nexusInstanceId:</span> <span class="string">&quot;Nexus3&quot;</span>,</span><br><span class="line">            <span class="comment">// 指定发布到Nexus服务器的仓库</span></span><br><span class="line">            <span class="symbol">nexusRepositoryId:</span> <span class="string">&quot;JENKINS_DEPLOY&quot;</span>,</span><br><span class="line">            <span class="symbol">packages:</span> [[</span><br><span class="line">                <span class="symbol">$class:</span> <span class="string">&quot;MavenPackage&quot;</span>,</span><br><span class="line">                <span class="comment">// 指定要发布的文件</span></span><br><span class="line">                <span class="symbol">mavenAssetList:</span> [[</span><br><span class="line">                    <span class="symbol">classifier:</span> <span class="string">&quot;&quot;</span>,</span><br><span class="line">                    <span class="symbol">extension:</span> <span class="string">&quot;&quot;</span>,</span><br><span class="line">                    <span class="symbol">filePath:</span> <span class="string">&quot;target/app.jar&quot;</span></span><br><span class="line">                ]],</span><br><span class="line">                <span class="comment">// Maven包的坐标</span></span><br><span class="line">                <span class="symbol">mavenCoordinate:</span> [</span><br><span class="line">                    <span class="symbol">groupId:</span> <span class="string">&quot;com.janz.jenkins&quot;</span>,</span><br><span class="line">                    <span class="symbol">artifactId:</span> <span class="string">&quot;project-nexus&quot;</span>,</span><br><span class="line">                    <span class="symbol">packaging:</span> <span class="string">&quot;jar&quot;</span>,</span><br><span class="line">                    <span class="symbol">version:</span> <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line">                ]</span><br><span class="line">            ]]</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pipeline-制品">Pipeline 制品</h3>
<p>可以使用 <code>archiveArtifacts</code> 指令对制品进行归档, 构建的结果页面提供了归档文件的下载链接</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: archiveArtifacts */</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;build&#x27;</span>) &#123;</span><br><span class="line">            sh <span class="string">&quot;mvn package&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    post &#123;</span><br><span class="line">        success &#123;</span><br><span class="line">            archiveArtifacts(<span class="attr">artifacts:</span> <span class="string">&quot;**/target/*.jar&quot;</span>, <span class="attr">fingerprint:</span> <span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* archiveArtifacts指令参数</span></span><br><span class="line"><span class="comment">artifacts         需要归档的文件路径</span></span><br><span class="line"><span class="comment">fingerprint       是否对归档的文件进行签名</span></span><br><span class="line"><span class="comment">excludes          需要排除的文件路径</span></span><br><span class="line"><span class="comment">caseSensitive     是否对路径大小写敏感</span></span><br><span class="line"><span class="comment">onlyIfSuccessful  是否只在构建成功时进行归档</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>在某些场景下, 需要在 pipeline 之间拷贝制品, 使用 <a href="https://plugins.jenkins.io/copyartifact/">Copy Artifact</a> 插件可以实现</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: copyArtifacts */</span></span><br><span class="line">steps &#123;</span><br><span class="line">    <span class="comment">// 从project项目中拿到最后一次归档的制品</span></span><br><span class="line">    copyArtifacts(</span><br><span class="line">        <span class="symbol">projectName:</span> <span class="string">&quot;project&quot;</span>,</span><br><span class="line">        <span class="symbol">selector:</span> lastSuccessful(<span class="literal">true</span>)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* copyArtifacts指令参数</span></span><br><span class="line"><span class="comment">projectName           归档制品的项目名称</span></span><br><span class="line"><span class="comment">selector              拷贝制品的选择器, 默认拷贝最后一个制品</span></span><br><span class="line"><span class="comment">parameters            使用逗号分隔的键值对字符串, 用于过滤从哪些构建中拷贝制品</span></span><br><span class="line"><span class="comment">filter                用于过滤需要拷贝的文件</span></span><br><span class="line"><span class="comment">excludes              用于排除不需要拷贝的文件</span></span><br><span class="line"><span class="comment">target                拷贝制品的目标路径, 默认为当前pipeline的工作目录</span></span><br><span class="line"><span class="comment">optional              如果为true则拷贝失败也不影响本次构建结果</span></span><br><span class="line"><span class="comment">fingerprintArtifacts  是否对制品进行签名, 默认值为true</span></span><br><span class="line"><span class="comment">resultVariableSuffix  用于获取制品的原构建序号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* 常用的选择器</span></span><br><span class="line"><span class="comment">lastSuccessful(boolean stable)  最后一次构建成功的制品, stable为true表示只取构建成功的制品, 为false表示只要构建结果比UNSTABLE好就行</span></span><br><span class="line"><span class="comment">specific(String number)         指定某一次构建的制品</span></span><br><span class="line"><span class="comment">lastCompleted()                 最后一次完成构建的制品, 不论构建的最终状态如何</span></span><br><span class="line"><span class="comment">latestSavedBuild()              最后一次被标记为keep forever的构建的制品</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>插件会将拷贝的制品的原构建序号放到环境变量 <code>COPYARTIFACT_BUILD_NUMBER_(resultVariableSuffix)</code> 中, 在当前 pipeline 中可以通过此变量拿到原构建序号</p>
</blockquote>
<h2 id="版本号">版本号</h2>
<p><strong>版本号</strong> 的制定并没有所谓的行业标准, GitHub 提出了一种具有指导意义, 统一的版本号表示规则, 称为 Semantic Versioning(语义化版本表示), 先行版本号及版本编译元数据可以加到后面作为延伸</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 语义化版本格式</span></span><br><span class="line">主版本号.次版本号.修订号</span><br><span class="line"><span class="meta">#</span><span class="bash"> 常用修饰词</span></span><br><span class="line">alpha  内部版本</span><br><span class="line">beta   测试版本</span><br><span class="line">rc     即将作为正式版本发布</span><br><span class="line">lts    长期维护</span><br></pre></td></tr></table></figure>
<p>Jenkins 的插件 <a href="https://plugins.jenkins.io/versionnumber/">Version Number</a> 是一款用于生成版本号的插件, 提供了 <code>VersionNumber</code> 指令</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: VersionNumber */</span></span><br><span class="line">script &#123;</span><br><span class="line">    <span class="keyword">def</span> version = VersionNumber(</span><br><span class="line">        <span class="symbol">versionPrefix:</span> <span class="string">&quot;$&#123;JOB_NAME&#125;-&quot;</span>,</span><br><span class="line">        <span class="symbol">versionNumberString:</span> <span class="string">&#x27;v1.1.1.$&#123;BUILDS_ALL_TIME&#125;&#x27;</span></span><br><span class="line">    )</span><br><span class="line">    echo <span class="string">&quot;$&#123;version&#125;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 指令参数</span></span><br><span class="line"><span class="comment">versionNumberString      字符串类型, 版本号格式, 用于生成版本号, 只能使用单引号, 以防格式中的占位符被转义, 版本号格式支持多种占位符</span></span><br><span class="line"><span class="comment">versionPrefix            字符串类型, 版本号前缀</span></span><br><span class="line"><span class="comment">projectStartDate         字符串类型, 项目开始时间, 格式为yyyy-MM-dd, 用于计算项目开始后的月数和年数</span></span><br><span class="line"><span class="comment">worstResultForIncrement  字符串类型, 如果本次构建状态比上一次构建状态更糟糕, 则占位符的值不会增加, 可以设置的值有SUCCESS, UNSTABLE, FAILURE, ABORTED, NOT_BUILT(默认值)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* 常用的占位符</span></span><br><span class="line"><span class="comment">BUILD_DATE_FORMATTED  格式化的构建日期, 支持参数化, 如$&#123;BUILD_DATE_FORMATTED, &quot;yyyy-MM&quot;&#125;</span></span><br><span class="line"><span class="comment">BUILD_DAY             构建日期, 支持X和XX参数, 如$&#123;BUILD_DAY, XX&#125;</span></span><br><span class="line"><span class="comment">BUILD_WEEK            今年构建的星期数, 支持X和XX参数</span></span><br><span class="line"><span class="comment">BUILD_MONTH           今年构建的月数, 支持X和XX参数</span></span><br><span class="line"><span class="comment">BUILD_YEAR            今年构建的年份</span></span><br><span class="line"><span class="comment">BUILDS_TODAY          当天完成的构建数</span></span><br><span class="line"><span class="comment">BUILDS_THIS_WEEK      本星期完成的构建数</span></span><br><span class="line"><span class="comment">BUILDS_THIS_MONTH     本月完成的构建数</span></span><br><span class="line"><span class="comment">BUILDS_THIS_YEAR      本年完成的构建数</span></span><br><span class="line"><span class="comment">BUILDS_ALL_TIME       自从项目开始后完成的总构建数</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="通知">通知</h2>
<p>实时知道构建的状态很重要, 最好的方式就是构建系统本身知道出现情况时发起通知</p>
<h3 id="邮件通知">邮件通知</h3>
<p><strong>邮件通知</strong> 是最常用的通知方式, Jenkins 默认支持</p>
<p>进入 <code>Manage Jenkins / Configure System / Jenkins Location</code> 页面, 设置管理员邮箱, 并配置 <code>Email Notification</code> 节点的信息</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: mail */</span></span><br><span class="line">post &#123;</span><br><span class="line">    failure &#123;</span><br><span class="line">        mail(<span class="attr">body:</span> <span class="string">&#x27;failure body&#x27;</span>, <span class="attr">subject:</span> <span class="string">&#x27;build status&#x27;</span>, <span class="attr">from:</span> <span class="string">&#x27;&#x27;</span>, <span class="attr">to:</span> <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 指令参数</span></span><br><span class="line"><span class="comment">subject  邮件主题</span></span><br><span class="line"><span class="comment">body     邮件内容</span></span><br><span class="line"><span class="comment">from     发件地址</span></span><br><span class="line"><span class="comment">to       收件地址</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><a href="https://plugins.jenkins.io/email-ext/">Email Extension</a> 插件对邮件通知的功能进行了扩展, 支持更多的特性</p>
<p>进入 <code>Manage Jenkins / Configure System / Extended Email Notification</code> 页面配置信息</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: emailext */</span></span><br><span class="line">post &#123;</span><br><span class="line">    failure &#123;</span><br><span class="line">        emailext(<span class="attr">body:</span> <span class="string">&#x27;&#x27;</span>, <span class="attr">subject:</span> <span class="string">&#x27;&#x27;</span>, <span class="attr">to:</span> <span class="string">&#x27;&#x27;</span>, <span class="attr">attachLog:</span> <span class="literal">true</span>, <span class="attr">compressLog:</span> <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 指令参数</span></span><br><span class="line"><span class="comment">subject             邮件主题</span></span><br><span class="line"><span class="comment">body                邮件内容</span></span><br><span class="line"><span class="comment">attachLog           可选, 是否将构建日志以附件形式发送</span></span><br><span class="line"><span class="comment">attachmentsPattern  可选, String类型, 需要发送的附件的路径</span></span><br><span class="line"><span class="comment">compressLog         可选, 是否压缩日志</span></span><br><span class="line"><span class="comment">from                可选, 收件人邮件</span></span><br><span class="line"><span class="comment">to                  可选, 发件人邮件</span></span><br><span class="line"><span class="comment">recipientProviders  可选, List类型, 收件人列表类型</span></span><br><span class="line"><span class="comment">replyTo             可选, 回复邮箱</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="http-请求通知">HTTP 请求通知</h3>
<p><a href="https://plugins.jenkins.io/http_request/">HTTP Request</a> 插件能在 Jenkins pipeline 中发送 HTTP 请求给第三方系统</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: httpRequest */</span></span><br><span class="line">steps &#123;</span><br><span class="line">    script &#123;</span><br><span class="line">        <span class="keyword">def</span> response = httpRequest(</span><br><span class="line">            <span class="symbol">url:</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            <span class="symbol">acceptType:</span> <span class="string">&#x27;APPLICATION_JSON&#x27;</span>,</span><br><span class="line">            <span class="symbol">contentType:</span> <span class="string">&#x27;APPLICATION_JSON&#x27;</span>,</span><br><span class="line">            <span class="symbol">httpMethod:</span> <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">            <span class="symbol">authentication:</span> <span class="string">&#x27;http_request&#x27;</span>,</span><br><span class="line">            <span class="symbol">requestBody:</span> <span class="string">&quot;&#123;&#x27;buildNumber&#x27;:&#x27;$&#123;env.BUILD_NUMBER&#125;&#x27;&#125;&quot;</span>,</span><br><span class="line">            <span class="symbol">timeout:</span> <span class="number">5</span>,</span><br><span class="line">            <span class="symbol">vaildResponseCodes:</span> <span class="string">&quot;200:302&quot;</span></span><br><span class="line">        )</span><br><span class="line">        echo <span class="string">&quot;$&#123;response.status&#125;&quot;</span></span><br><span class="line">        echo <span class="string">&quot;$&#123;response.content&#125;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 指令参数</span></span><br><span class="line"><span class="comment">url                     字符串类型, 请求URL</span></span><br><span class="line"><span class="comment">acceptType              枚举类型, HTTP请求Header的Accept的值</span></span><br><span class="line"><span class="comment">contentType             枚举类型, HTTP请求Header的ContentType的值</span></span><br><span class="line"><span class="comment">httpMethod              枚举类型, HTTP方法</span></span><br><span class="line"><span class="comment">authentication          字符串类型, HTTP Basic认证方式</span></span><br><span class="line"><span class="comment">consoleLogResponseBody  布尔类型, 是否将请求的响应打印出来</span></span><br><span class="line"><span class="comment">customHeaders           对象数组, HTTP请求Header部分的内容</span></span><br><span class="line"><span class="comment">httpProxy               字符串类型, HTTP代理地址</span></span><br><span class="line"><span class="comment">ignoreSslErrors         布尔类型, 是否忽略SSL错误</span></span><br><span class="line"><span class="comment">requestBody             字符串类型, 请求体的内容</span></span><br><span class="line"><span class="comment">timeout                 整形, 超时时间, 单位为秒, 默认值为0代表不设置超时时间</span></span><br><span class="line"><span class="comment">validResponseCodes      字符串类型, 代表HTTP请求成功的状态码, 多值用逗号分隔, 范围用冒号分隔</span></span><br><span class="line"><span class="comment">validResponseContent    字符串类型, 代表HTTP请求成功的响应体</span></span><br><span class="line"><span class="comment">quiet                   布尔类型, 是否关闭所有的日志打印, 默认值为false</span></span><br><span class="line"><span class="comment">responseHandle          枚举类型, 获取HTTP响应内容的方式</span></span><br><span class="line"><span class="comment">outputFile              字符串类型, 请求响应内容的输出路径</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="视图">视图</h2>
<p><a href="https://plugins.jenkins.io/greenballs/">Green Balls</a> 插件的作用让构建成功的状态图标变成绿色的</p>
<p><a href="https://plugins.jenkins.io/build-monitor-plugin/">Build Monitor View</a> 插件可以将 Jenkins 项目以一块看板的形式呈现</p>
<h2 id="监控">监控</h2>
<p><a href="https://prometheus.io/">Prometheus</a> 是一款开源的监控和告警系统, 服务器端主动从客户端拉取指标数据, Jenkins 的 <a href="https://plugins.jenkins.io/prometheus/">Prometheus</a> 插件的目的就是为了暴露一个数据接口, 这样 Prometheus 就可以拉取到指标数据了</p>
<p>Prometheus 本身提供的界面过于简陋, 所以一般会使用 <a href="https://grafana.com/">Grafana</a> 对指标进行展示</p>
<pre class="mermaid">graph LR
A(Jenkins master)
B(Prometheus)
C(Grafana)
B --pull--> A
C --query--> B</pre>
<h2 id="备份">备份</h2>
<p>Jenkins 的所有数据都是存放在文件中的, 所以 Jenkins 备份其实就是备份 <code>JENKINS_HOME</code> 目录</p>
<blockquote>
<p>如果启动 Jenkins 时没有指定 <code>JENKINS_HOME</code> 环境变量, 那么 Jenkins 将在当前用户目录下创建一个 <code>.jenkins</code> 目录作为 <code>JENKINS_HOME</code> 目录</p>
</blockquote>
<p>Jenkins 本身并不提供备份功能, 而是交给插件来完成, 安装 <a href="https://plugins.jenkins.io/periodicbackup/">Periodic Backup</a> 插件后, 在 <code>Manage Jenkins / Periodic Backup Manager</code> 节点下管理备份功能</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins CLI</title>
    <url>/2020/07/23/jenkins%20010/</url>
    <content><![CDATA[<h1 id="jenkins-cli">Jenkins CLI</h1>
<p>虽然流水线脚本和传统的 Web 页面是大多数人使用 Jenkins 的主要接口, 但 Jenkins 同时还提供了命令行接口 (CLI) 以及应用程序接口 (REST API), 这些接口所能做的事情是有限的, 但是它们可以用于一些基本操作</p>
<h2 id="cli">CLI</h2>
<p>Jenkins 的命令行接口可以通过两种方法访问:</p>
<ul>
<li>通过 <code>ssh</code> 命令;</li>
<li>通过 <code>jenkins-cli.jar</code> 客户端</li>
</ul>
<p>Jenkins 默认的 SSH 服务是被禁用的, 需要进入 <code>Jenkins / Configure Global Security/ SSH Server</code> 节点下, 指定固定端口或者随机端口来启用 SSH 服务, 可以进入 <code>Jenkins / &#123;User&#125; / SSH Public Keys</code> 节点下配置用户的公钥</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: ssh方式获取可用命令的完整列表</span></span><br><span class="line">ssh -l username -p password localhost help</span><br></pre></td></tr></table></figure>
<p>使用命令行接口的另一个选择是 Jenkins 自带的 CLI 客户端, 这个客户端支持几种不同的协议, 包括 HTTP 和 SSH, 可以通过链接下载该文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 下载CLI客户端</span></span><br><span class="line">curl -O https://JENKINS_URL/jnlpJars/jenkins-cli.jar</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: CLI语法</span></span><br><span class="line">java -jar jenkins-cli.jar [-s JENKINS_URL] [global options...] command [command options...] [arguments...]</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 常用选项</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -s     指定Jenkins的URL, 如果没有指定, Jenkins会默认使用JENKINS_URL环境变量指定的值</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -http  使用HTTP协议, 这是默认的模式</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -ssh   使用SSH协议</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -auth  认证方式, 不推荐明文密码, 可以通过从文件中读取</span></span><br></pre></td></tr></table></figure>
<p>CLI 客户端更多详细用法见官方文档 <a href="https://www.jenkins.io/zh/doc/book/managing/cli/#%E4%BD%BF%E7%94%A8-cli-%E5%AE%A2%E6%88%B7%E7%AB%AF">CLI</a></p>
<h2 id="rest-api">REST API</h2>
<p>使用 REST API 调用获取数据支持 3 种格式: XML, JSON 和 Python, 添加其中的一个限定符到 URL 末尾就会提供对应格式的数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 获取JOB_NAME的json数据</span></span><br><span class="line">https://JENKINS_URL/job/JOB_NAME/api/json</span><br></pre></td></tr></table></figure>
<p>如果已经开启了跨站请求伪造保护功能, 要从 Jenkins 中获得一个 <code>crumb</code> 以便在请求中使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 获取crumb的链接</span></span><br><span class="line">https://JENKINS_URL/crumbIssuer/api/xml</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 使用crumb调用执行构建</span></span><br><span class="line">curl -I -X POST https://JENKINS_URL/job/JOB_NAME/build -H &quot;&lt;crumb value&gt;&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -H  传递crumb参数, 也可以通过JENKINS_CRUMB环境变量设置</span></span><br></pre></td></tr></table></figure>
<h2 id="jcli">JCLI</h2>
<p><a href="https://github.com/jenkins-zh/jenkins-cli">JCLI</a> 项目提供了通过命令行操作 Jenkins 的更多指令, 其支持以下特性:</p>
<ul>
<li>支持多 Jenkins 实例管理;</li>
<li>插件管理 (查看列表, 搜索, 安装, 上传);</li>
<li>任务管理 (搜索, 构建触发, 日志查看);</li>
<li>支持配置即管理;</li>
<li>在浏览器中打开你的 Jenkins;</li>
<li>重启你的 Jenkins;</li>
<li>支持通过代理连接</li>
</ul>
<p>Jenkins 进入 <code>Jenkins / &#123;User&#125; /API Token</code> 节点下, 添加一个新的 Token</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 生成配置文件</span></span><br><span class="line">jcli config generate</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认会在用户目录 ~/ 下生成配置文件.jenkins-cli.yaml</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件: .jenkins-cli.yaml</span></span><br><span class="line"><span class="attr">current:</span> <span class="string">JENKINS_NAME</span>    <span class="comment"># 当前使用的Jenkins服务端</span></span><br><span class="line"><span class="attr">jenkins_servers:</span>         <span class="comment"># 可配置多个Jenkins服务器</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">JENKINS_NAME</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">http://localhost</span>  <span class="comment"># 指定Jenkins的URL</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">username</span>     <span class="comment"># 指定访问的用户名</span></span><br><span class="line">  <span class="attr">token:</span> <span class="string">token</span>           <span class="comment"># 指定访问的令牌, 需要同Jenkins用户添加的Token一致</span></span><br><span class="line">  <span class="attr">insecureSkipVerify:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">mirrors:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">http://mirrors.jenkins.io/</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tsinghua</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/jenkins/</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">huawei</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">https://mirrors.huaweicloud.com/jenkins/</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tencent</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">https://mirrors.cloud.tencent.com/jenkins/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 常用命令</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取帮助</span></span><br><span class="line">jcli -h</span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索项目</span></span><br><span class="line">jcli job search [flags]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行构建</span></span><br><span class="line">jcli job build &lt;jobName&gt; [flags]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看队列</span></span><br><span class="line">jcli queue list</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启</span></span><br><span class="line">jcli restart</span><br><span class="line"><span class="meta">#</span><span class="bash"> 浏览器访问</span></span><br><span class="line">jcli open</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>Loki 入门</title>
    <url>/2021/08/18/loki-001/</url>
    <content><![CDATA[<h1 id="入门">入门</h1>
<p><a href="https://grafana.com/oss/loki/">Loki</a> 是一个功能齐全的日志聚合系统的核心, 专为高效保存日志消息而优化, 与其它日志系统不同, Loki 不索引原始日志消息, 而是基于标签构建索引</p>
<p>Loki 的组件在内部称为模块 (module), 单体模式部署时, 每个组件都运行在同一进程中, 通过 Loki 配置的 gRPC 端口在本地网络中连接, 以进行组件之间的相互通信, Loki 主要由 5 个组件构成:</p>
<ul>
<li><strong>Distributor</strong> 负责处理客户端传入的流, 这是日志数据写入路径中的第一站, 分发器将验证每个流的正确性, 确保其在配置的租户 (或全局) 限制内, 然后将有效的数据块分批, 并行发送到匹配的 Ingester</li>
<li><strong>Ingester</strong> 负责接收数据块, 当数据达到一定数量或期限时, 将数据块刷新到数据库中, 其对数据块和索引分别使用单独的数据库, 因为它们的数据类型不同</li>
<li><strong>Querier</strong> 基于 LogQL 查询语言, 以检索存储库和 Ingester 中尚未刷新的数据的索引, 并返回匹配的日志查询结果</li>
<li><strong>Query Frontend</strong> 负责提供查询的 API 端点, 传入的查询请求保存在内部的队列中, 以便 Querier 提取执行</li>
<li><strong>Ruler</strong> 分为记录规则和告警规则, 用于预计算表达式和触发告警事件</li>
</ul>
<figure>
<img data-src="https://cdn.jsdelivr.net/gh/grafana/loki@46eff3c12cc0170c21905b783c90e8a1653a4b83/docs/sources/architecture/loki_architecture_components.svg" alt="Loki 架构图" /><figcaption aria-hidden="true">Loki 架构图</figcaption>
</figure>
<h2 id="安装">安装</h2>
<p>Loki 提供了多种安装方式, 详见 <a href="https://grafana.com/docs/loki/latest/installation/">installation</a>, 支持使用容器方式部署 <a href="https://hub.docker.com/r/grafana/loki">grafana/loki</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: docker部署</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -d</span></span><br><span class="line">  -v $(pwd):/mnt/config</span><br><span class="line">  -p 3100:3100</span><br><span class="line">  grafana/loki</span><br><span class="line">  -config.file=/mnt/config/loki-docker-config.yaml</span><br></pre></td></tr></table></figure>
<h3 id="配置">配置</h3>
<p>Loki 通过 YAML 文件来配置, 详见 <a href="https://grafana.com/docs/loki/latest/configuration/">configuration</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件: loki-docker-config.yaml</span></span><br><span class="line"><span class="attr">target:</span> <span class="string">all</span></span><br><span class="line"><span class="attr">auth_enabled:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">http_listen_port:</span> <span class="number">3100</span></span><br><span class="line"></span><br><span class="line"><span class="attr">ingester:</span></span><br><span class="line">  <span class="attr">lifecycler:</span></span><br><span class="line">    <span class="attr">address:</span> <span class="number">172.17</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">ring:</span></span><br><span class="line">      <span class="attr">kvstore:</span></span><br><span class="line">        <span class="attr">store:</span> <span class="string">inmemory</span></span><br><span class="line">      <span class="attr">replication_factor:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">final_sleep:</span> <span class="string">0s</span></span><br><span class="line">  <span class="attr">chunk_idle_period:</span> <span class="string">1h</span>       <span class="comment"># Any chunk not receiving new logs in this time will be flushed</span></span><br><span class="line">  <span class="attr">max_chunk_age:</span> <span class="string">1h</span>           <span class="comment"># All chunks will be flushed when they hit this age, default is 1h</span></span><br><span class="line">  <span class="attr">chunk_target_size:</span> <span class="number">1048576</span>  <span class="comment"># Loki will attempt to build chunks up to 1.5MB, flushing first if chunk_idle_period or max_chunk_age is reached first</span></span><br><span class="line">  <span class="attr">chunk_retain_period:</span> <span class="string">30s</span>    <span class="comment"># Must be greater than index read cache TTL if using an index cache (Default index read cache TTL is 5m)</span></span><br><span class="line">  <span class="attr">max_transfer_retries:</span> <span class="number">0</span>     <span class="comment"># Chunk transfers disabled</span></span><br><span class="line"></span><br><span class="line"><span class="attr">schema_config:</span></span><br><span class="line">  <span class="attr">configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">from:</span> <span class="number">2020-10-24</span></span><br><span class="line">      <span class="attr">store:</span> <span class="string">boltdb-shipper</span></span><br><span class="line">      <span class="attr">object_store:</span> <span class="string">filesystem</span></span><br><span class="line">      <span class="attr">schema:</span> <span class="string">v11</span></span><br><span class="line">      <span class="attr">index:</span></span><br><span class="line">        <span class="attr">prefix:</span> <span class="string">index_</span></span><br><span class="line">        <span class="attr">period:</span> <span class="string">24h</span></span><br><span class="line"></span><br><span class="line"><span class="attr">storage_config:</span></span><br><span class="line">  <span class="attr">boltdb_shipper:</span></span><br><span class="line">    <span class="attr">active_index_directory:</span> <span class="string">/loki/boltdb-shipper-active</span></span><br><span class="line">    <span class="attr">cache_location:</span> <span class="string">/loki/boltdb-shipper-cache</span></span><br><span class="line">    <span class="attr">cache_ttl:</span> <span class="string">24h</span>         <span class="comment"># Can be increased for faster performance over longer query periods, uses more disk space</span></span><br><span class="line">    <span class="attr">shared_store:</span> <span class="string">filesystem</span></span><br><span class="line">  <span class="attr">filesystem:</span></span><br><span class="line">    <span class="attr">directory:</span> <span class="string">/loki/chunks</span></span><br><span class="line"></span><br><span class="line"><span class="attr">compactor:</span></span><br><span class="line">  <span class="attr">working_directory:</span> <span class="string">/loki/boltdb-shipper-compactor</span></span><br><span class="line">  <span class="attr">shared_store:</span> <span class="string">filesystem</span></span><br><span class="line"></span><br><span class="line"><span class="attr">limits_config:</span></span><br><span class="line">  <span class="attr">reject_old_samples:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">reject_old_samples_max_age:</span> <span class="string">168h</span></span><br><span class="line"></span><br><span class="line"><span class="attr">chunk_store_config:</span></span><br><span class="line">  <span class="attr">max_look_back_period:</span> <span class="string">0s</span></span><br><span class="line"></span><br><span class="line"><span class="attr">table_manager:</span></span><br><span class="line">  <span class="attr">retention_deletes_enabled:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">retention_period:</span> <span class="string">0s</span></span><br><span class="line"></span><br><span class="line"><span class="attr">ruler:</span></span><br><span class="line">  <span class="attr">storage:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">local</span></span><br><span class="line">    <span class="attr">local:</span></span><br><span class="line">      <span class="attr">directory:</span> <span class="string">/loki/rules</span></span><br><span class="line">  <span class="attr">rule_path:</span> <span class="string">/loki/rules-temp</span></span><br><span class="line">  <span class="attr">alertmanager_url:</span> <span class="string">http://172.17.0.1:9093</span></span><br><span class="line">  <span class="attr">ring:</span></span><br><span class="line">    <span class="attr">kvstore:</span></span><br><span class="line">      <span class="attr">store:</span> <span class="string">inmemory</span></span><br><span class="line">  <span class="attr">enable_api:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Loki 不附带任何内置的身份认证层, 如需对外暴露端口的方式部署, 需要在服务前置运行身份认证的反向代理, 例如使用 basic auth 或 OAuth2 代理的 Nginx 服务</p>
</blockquote>
<h3 id="启动">启动</h3>
<p>通过运行二进制文件 <a href="https://github.com/grafana/loki/releases/">release</a> 启动服务, 详见 <a href="https://grafana.com/docs/loki/latest/installation/local/">local</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 启动服务</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> loki-linux-amd64 -config.file=loki-local-config.yaml</span></span><br></pre></td></tr></table></figure>
<p>Loki 提供了一组管理 API, 以促进自动化和集成, 详见 <a href="https://grafana.com/docs/loki/latest/api/">management-api</a></p>
<ul>
<li><code>GET /ready</code> 当服务准备好时, 该端点返回 <code>200</code> 状态码</li>
<li><code>POST /flush</code> 该端点用于触发 ingester 组件刷新内存块到存储区, 主要用于本地测试</li>
<li><code>POST /ingester/flush_shutdown</code> 该端点用于触发 ingester 组件刷新内存块到存储区并关闭</li>
<li><code>GET /config</code> 该端点用于获取当前服务的配置</li>
<li><code>GET /loki/api/v1/status/buildinfo</code> 该端点用于获取当前服务的构建信息, 包括版本, 修订, 分支, 构建日期, 构建用户和使用的 Go 版本</li>
</ul>
<h3 id="模式">模式</h3>
<p>Loki 的组件默认运行在同一进程, 称为单进程 (single process) 或单体模式 (monolithic mode), 详见 <a href="https://grafana.com/docs/loki/latest/architecture/#modes-of-operation">mode</a></p>
<p>Loki 设计支持扩展部署, 每个组件都可以分解为单独的流程, 并且配置允许组件的单独扩展, 称为横向扩展 (horizontally scalable) 或微服务模式 (microservices mode), 详见 <a href="https://grafana.com/docs/loki/latest/operations/scalability/">scalability</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件: loki-docker-config.yaml</span></span><br><span class="line"><span class="attr">target:</span> <span class="string">all</span>  <span class="comment"># 默认为单体模式</span></span><br><span class="line"><span class="comment"># 可选的值</span></span><br><span class="line"><span class="comment"># all, compactor, distributor, ingester, querier, query-frontend, table-manager.</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在扩展 Loki 时, 应考虑按组件划分多个 Loki 实例, 而不是按 Loki 单体进程, <a href="https://github.com/grafana/loki/tree/main/production/ksonnet/loki">libsonnet</a> 提供了文件演示划分组件以及根据资源使用情况扩展的配置</p>
</blockquote>
<h2 id="存储">存储</h2>
<p>与其它日志记录系统不同, Loki 的构建理念是只为日志的标签生成索引, 日志数据本身被压缩并以块的形式存储在对象存储区中, 这显著降低了日志记录的成本, 详见 <a href="https://grafana.com/docs/loki/latest/storage/">storage</a></p>
<p>Loki 支持的索引存储实现, 参考 <a href="https://grafana.com/docs/loki/latest/storage/#implementations---index">index</a></p>
<p>Loki 支持的块存储实现, 参考 <a href="https://grafana.com/docs/loki/latest/storage/#implementations---chunks">chunks</a></p>
<h2 id="多租户">多租户</h2>
<p>Loki 是一个多租户系统, 不同租户的数据是完全隔离的, 通过在端点的请求头 <code>X-Scope-OrgID</code> 传递租户 ID 来标识不同的租户, 详见 <a href="https://grafana.com/docs/loki/latest/operations/multi-tenancy/">multi-tenancy</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件: loki-docker-config.yaml</span></span><br><span class="line"><span class="attr">auth_enabled:</span> <span class="literal">true</span>  <span class="comment"># 启用多租户模式</span></span><br></pre></td></tr></table></figure>
<h2 id="客户端">客户端</h2>
<p>Loki 支持多种收集日志的客户端, 详见 <a href="https://grafana.com/docs/loki/latest/clients/">clients</a>, 第三方的客户端, 详见 <a href="https://grafana.com/docs/loki/latest/clients/#unofficial-clients">unofficial</a></p>
<h3 id="promtail">Promtail</h3>
<p><a href="https://grafana.com/docs/loki/latest/clients/promtail/">promtail</a> 是一个客户端代理, 负责将本地日志的内容附加标签, 并发送到指定的 Loki 实例, 通常将其部署到需要收集日志的应用所在的服务器上</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: docker部署</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -d</span></span><br><span class="line">  -v $(pwd):/mnt/config</span><br><span class="line">  -v /var/log:/var/log</span><br><span class="line">  grafana/promtail</span><br><span class="line">  -config.file=/mnt/config/promtail-docker-config.yaml</span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件: promtail-docker-config.yaml</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">http_listen_port:</span> <span class="number">9080</span></span><br><span class="line">  <span class="attr">grpc_listen_port:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">positions:</span></span><br><span class="line">  <span class="attr">filename:</span> <span class="string">/tmp/positions.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">clients:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">url:</span> <span class="string">&#x27;http://172.17.0.1:3100/loki/api/v1/push&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">system</span></span><br><span class="line">  <span class="attr">static_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">targets:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">job:</span> <span class="string">varlogs</span></span><br><span class="line">      <span class="attr">__path__:</span> <span class="string">/var/log/*log</span>  <span class="comment"># 收集匹配的日志文件</span></span><br></pre></td></tr></table></figure>
<h3 id="dockerdriver">DockerDriver</h3>
<p><a href="https://grafana.com/docs/loki/latest/clients/docker-driver/">docker-driver</a> 是官方提供的 Docker 插件, 该插件支持从 Docker 容器读取日志并发送到 Loki 实例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: docker安装插件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker plugin install</span></span><br><span class="line">  grafana/loki-docker-driver:latest</span><br><span class="line">  --alias loki</span><br><span class="line">  --grant-all-permissions</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 应用部署时配置日志选项</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -d</span></span><br><span class="line">  --log-driver=loki</span><br><span class="line">  --log-opt loki-url=&quot;http://172.17.0.1:3100/loki/api/v1/push&quot;</span><br><span class="line">  --log-opt loki-retries=5</span><br><span class="line">  --log-opt loki-batch-size=400</span><br><span class="line">  docker/getting-started</span><br></pre></td></tr></table></figure>
<blockquote>
<p>docker-for-windows 尚不支持 Docker 插件, 详情参考 <a href="https://docs.docker.com/engine/extend/">docker-engine</a></p>
</blockquote>
<h3 id="loki4j">Loki4j</h3>
<p><a href="https://loki4j.github.io/loki-logback-appender/">Loki4j</a> 是基于 Java 应用程序的 <a href="http://logback.qos.ch/">Logback</a> 日志框架, 通过配置 <code>Loki4jAppender</code> 将应用日志发送到 Loki 的第三方工具</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 示例: Maven配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.loki4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>loki-logback-appender<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 文件: logback.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;LOKI&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.github.loki4j.logback.Loki4jAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">http</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://127.0.0.1:3100/loki/api/v1/push<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">http</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">format</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>app=my-app,host=$&#123;HOSTNAME&#125;,level=%level<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">message</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>l=%level h=$&#123;HOSTNAME&#125; c=%logger&#123;20&#125; t=%thread | %msg %ex<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sortByTime</span>&gt;</span>true<span class="tag">&lt;/<span class="name">sortByTime</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">format</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;LOKI&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="集成">集成</h2>
<p>Loki 原生支持大多数现代框架的技术集成</p>
<h3 id="prometheus">Prometheus</h3>
<p>Loki 服务提供公开的 Prometheus 度量的指标端点 <a href="http://127.0.0.1:3001/metrics">/metrics</a>, 以方便集成到 Prometheus 系统的实时监控</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例: prometheus.yml配置</span></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">loki</span></span><br><span class="line">    <span class="attr">metrics_path:</span> <span class="string">/metrics</span></span><br><span class="line">    <span class="attr">scheme:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;127.0.0.1:3001&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>Loki 时序指标列表, 参考 <a href="https://grafana.com/docs/loki/latest/operations/observability/">observability</a></p>
<h3 id="grafana">Grafana</h3>
<p>Grafana 提供完整的 Loki 可视化集成, 可以通过网页手动配置, 参考 <a href="https://grafana.com/docs/grafana/latest/datasources/loki/">datasources/loki</a></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Loki</tag>
      </tags>
  </entry>
  <entry>
    <title>Micrometer</title>
    <url>/2021/07/15/micrometer-001/</url>
    <content><![CDATA[<h1 id="micrometer">Micrometer</h1>
<p><a href="https://micrometer.io/">Micrometer</a> 是基于 JVM 应用的度量监控库, 它提供了应用内统一的指标采集接口和实现, 允许开发人员选择不同的数据规范对接方式, 从而最大限度的提高了对接不同监控系统的可移植性</p>
<p>由于不同的监控系统对数据规范的特征支持不一, Micrometer 按 3 个特征对已支持的监控系统做了划分, 详见 <a href="https://micrometer.io/docs/concepts#_supported_monitoring_systems">monitoring-systems</a></p>
<ul>
<li>维度(dimensional) 对于支持维度的监控系统, 维度信息将以键值对的标签形式返回, 对于不支持维度的监控系统, 维度信息将会展平添加到指标名称中</li>
<li>速率聚合(rate aggregation) 对于不支持速率聚合的监控系统, 增量采样的数据可以进行速率聚合再返回新样本, 对于支持速率聚合的监控系统, 直接返回增量数据</li>
<li>发布(publishing) 支持不同的监控系统对采样数据的推模式和拉模式</li>
</ul>
<h2 id="注册表">注册表</h2>
<p>Micrometer 为不同的监控系统提供了称为 <strong>注册表(registry)</strong> 的实现模块和测试套件, 注册表接口 <code>MeterRegistry</code> 定义了创建和保存应用要采集的指标元数据的方法, 每个支持的监控系统都有一个该接口的具体实现, 详见 <a href="https://micrometer.io/docs/concepts#_registry">registry</a></p>
<p>Micrometer 默认提供 <code>SimpleMeterRegistry</code> 的简单实现类, 在开发者没有首选的监控系统前, 可以通过该实现类编写采样的代码, 该实现类将采样数据保存在内存中, 并且不会提供对外暴露对接数据的方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: registry */</span></span><br><span class="line">SimpleMeterRegistry registry = <span class="keyword">new</span> SimpleMeterRegistry();  <span class="comment">// 创建一个简单的注册表</span></span><br><span class="line">Meter metrics = registry.counter(<span class="string">&quot;biz.metrics&quot;</span>);           <span class="comment">// 创建一个counter类型的指标</span></span><br></pre></td></tr></table></figure>
<h2 id="过滤器">过滤器</h2>
<p>注册表可以通过配置指标过滤器, 控制指标的注册方式和其采样数据, 详见 <a href="https://micrometer.io/docs/concepts#_meter_filters">meter-filters</a></p>
<p>过滤器有三个基本功能:</p>
<ol type="1">
<li><p>禁用已注册的指标</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例 */</span></span><br><span class="line">registry.config()</span><br><span class="line">    .meterFilter(MeterFilter.ignoreTags(<span class="string">&quot;jvm&quot;</span>))</span><br><span class="line">    .meterFilter(MeterFilter.denyNameStartsWith(<span class="string">&quot;jvm&quot;</span>));</span><br></pre></td></tr></table></figure></li>
<li><p>转换指标的 <code>Id</code> 对象, 其包含指标名称和标签集</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例 */</span></span><br><span class="line">registry.config()</span><br><span class="line">    .meterFilter(<span class="keyword">new</span> MeterFilter() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Meter.<span class="function">Id <span class="title">map</span><span class="params">(Meter.Id id)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(id.getName().startsWith(<span class="string">&quot;test&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> id.withName(<span class="string">&quot;extra.&quot;</span> + id.getName()).withTag(Tag.of(<span class="string">&quot;extra.tag&quot;</span>, <span class="string">&quot;value&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>为指定类型的指标配置分布统计</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例 */</span></span><br><span class="line">registry.config()</span><br><span class="line">    .meterFilter(<span class="keyword">new</span> MeterFilter() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> DistributionStatisticConfig <span class="title">configure</span><span class="params">(Meter.Id id, DistributionStatisticConfig config)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (id.getName().startsWith(<span class="string">&quot;prefix&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> DistributionStatisticConfig.builder()</span><br><span class="line">                    .serviceLevelObjectives(<span class="number">0.9</span>, <span class="number">0.95</span>)</span><br><span class="line">                    .build()</span><br><span class="line">                    .merge(config);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> config;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="指标">指标</h2>
<p>Micrometer 定义了可以采集的指标接口 <code>Meter</code>, 并提供了以下原生的指标类型, 详见 <a href="https://micrometer.io/docs/concepts#_meters">meter</a></p>
<ul>
<li><code>Counter</code> <code>FunctionCounter</code> 单调递增且必须为正数的指标</li>
<li><code>Gauge</code> <code>TimeGauge</code> 实时变化的数值/时间的指标</li>
<li><code>DistributionSummary</code> 直方图和分位图的指标</li>
<li><code>Timer</code> <code>FunctionTimer</code> 短时间任务的总次数和总时间的指标</li>
<li><code>LongTaskTimer</code> 长时间任务的当前次数和已用时的指标</li>
</ul>
<p>Micrometer 为了一致性和可移植性的原因, 指标名称的生成方案与 Prometheus 不完全一致, 如果希望使用 Prometheus 标准的指标名称, 可以通过配置重命名过滤器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 配置过滤器 */</span></span><br><span class="line">registry.config()</span><br><span class="line">    .meterFilter(<span class="keyword">new</span> PrometheusRenameFilter());</span><br></pre></td></tr></table></figure>
<h3 id="counter">Counter</h3>
<p>计数指标通常可以通过速率聚合的运算得到在一段时间内的使用率, 需要注意当应用重启时, 使用内存保存数据的计数指标会重置从零开始递增, 这可能会导致速率运算的结果错误, 以致于表达式配置的告警在很长时间内发出异常行为, 详见 <a href="https://micrometer.io/docs/concepts#_counters">counter</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 实例 */</span></span><br><span class="line">Counter counter = Counter.builder(<span class="string">&quot;biz.counter&quot;</span>)</span><br><span class="line">    .tag(<span class="string">&quot;event&quot;</span>, <span class="string">&quot;login&quot;</span>)           <span class="comment">// 标签</span></span><br><span class="line">    .description(<span class="string">&quot;Counter of biz.&quot;</span>)  <span class="comment">// 描述</span></span><br><span class="line">    .register(registry);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递增值</span></span><br><span class="line">counter.increment();</span><br><span class="line">counter.increment(<span class="keyword">double</span> amount);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当使用 Prometheus 做速率运算时, 速率函数会自动检测计数指标的数据是否重置计数, 从而避免速率运算的结果错误, 因此在执行速率聚合的表达式时, 都应该先执行速率后执行聚合, 如 <code>sum(rate())</code></p>
</blockquote>
<h3 id="gauge">Gauge</h3>
<p>测量指标可以用于跟踪任何可设置的 <code>java.lang.Number</code> 子类型对象, 与其它类型的指标不同, 测量型指标不直接对指标的引用进行操作, 而是通过赋值待测量的对象数值即可, 详见 <a href="https://micrometer.io/docs/concepts#_gauges">gauge</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 实例 */</span></span><br><span class="line">AtomicInteger number = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">Gauge gauge = Gauge.builder(<span class="string">&quot;biz.gauge&quot;</span>, <span class="keyword">this</span>::getNumber)</span><br><span class="line">    .description(<span class="string">&quot;Gauge of biz.&quot;</span>)</span><br><span class="line">    .register(registry);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测量值</span></span><br><span class="line">number.set(<span class="keyword">int</span> newValue);</span><br></pre></td></tr></table></figure>
<h3 id="distributionsummary">DistributionSummary</h3>
<p>分布摘要指标用于跟踪事件的分布, 可通过配置用于直方图和分位图, 详见 <a href="https://micrometer.io/docs/concepts#_distribution_summaries">distribution-summary</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 实例 */</span></span><br><span class="line">DistributionSummary histogram = DistributionSummary.builder(<span class="string">&quot;biz.histogram&quot;</span>)</span><br><span class="line">    .description(<span class="string">&quot;Histogram of biz.&quot;</span>)</span><br><span class="line">    .serviceLevelObjectives(<span class="number">25</span>, <span class="number">50</span>, <span class="number">90</span>)  <span class="comment">// 直方图的上边界</span></span><br><span class="line">    .minimumExpectedValue(<span class="number">1d</span>)            <span class="comment">// 预期最小采样</span></span><br><span class="line">    .maximumExpectedValue(<span class="number">100d</span>)          <span class="comment">// 预期最大采样</span></span><br><span class="line">    .register(registry);</span><br><span class="line">DistributionSummary summary = DistributionSummary.builder(<span class="string">&quot;biz.summary&quot;</span>)</span><br><span class="line">    .description(<span class="string">&quot;Summary of biz.&quot;</span>)</span><br><span class="line">    .publishPercentiles(<span class="number">0.25</span>, <span class="number">0.5</span>, <span class="number">0.95</span>)  <span class="comment">// 分布图的分位数</span></span><br><span class="line">    .minimumExpectedValue(<span class="number">1d</span>)</span><br><span class="line">    .maximumExpectedValue(<span class="number">100d</span>)</span><br><span class="line">    .register(registry);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录采样值</span></span><br><span class="line">histogram.record(<span class="keyword">double</span> amount);</span><br><span class="line">summary.record(<span class="keyword">double</span> amount);</span><br></pre></td></tr></table></figure>
<h3 id="timer">Timer</h3>
<p>计时指标用于测量短任务的总执行时间和执行频率, 计时统计的总时间的最大值为 <code>Long.MAX_VALUE</code> (约 292.3 年), 计时的基本单位因记录时的度量而异, 详见 <a href="https://micrometer.io/docs/concepts#_timers">timer</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 实例 */</span></span><br><span class="line">Timer timer = Timer.builder(<span class="string">&quot;biz.timer&quot;</span>)</span><br><span class="line">    .description(<span class="string">&quot;Timer of biz.&quot;</span>)</span><br><span class="line">    .register(registry);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录指定时间</span></span><br><span class="line">timer.record(Duration duration);</span><br><span class="line"><span class="comment">// 通过执行记录时间</span></span><br><span class="line">Timer.Sample = Timer.start();</span><br><span class="line">sample.stop(timer);</span><br></pre></td></tr></table></figure>
<h3 id="longtasktimer">LongTaskTimer</h3>
<p>长任务计时指标用于测量仍在运行中的任务的已执行时间和次数, 当任务执行完成后, 样本不会再计入统计的指标, 详见 <a href="https://micrometer.io/docs/concepts#_long_task_timers">long-task-timer</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 实例 */</span></span><br><span class="line">LongTaskTimer longTaskTimer = LongTaskTimer.builder(<span class="string">&quot;biz.longTaskTimer&quot;</span>)</span><br><span class="line">    .description(<span class="string">&quot;LongTaskTimer of biz.&quot;</span>)</span><br><span class="line">    .register(meterRegistry);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录任务时间</span></span><br><span class="line">LongTaskTimer.Sample sample = longTaskTimer.start();</span><br><span class="line">sample.stop();</span><br></pre></td></tr></table></figure>
<h2 id="示例">示例</h2>
<p>SpringBoot 2.x 版本的 <code>spring-boot-actuator</code> 引入了 Micrometer 作为默认的监控系统实现方案, 详见 <a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#actuator.metrics">actuator-metrics</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 示例: 依赖配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  <span class="comment">&lt;!-- 此处使用prometheus作为监控系统 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.micrometer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>micrometer-registry-prometheus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  <span class="comment">&lt;!-- 可选扩展 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.mweirauch<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>micrometer-jvm-extras<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件: application.yml</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">tags:</span>  <span class="comment"># 为采集的指标都添加的标签集</span></span><br><span class="line">      <span class="attr">application:</span> <span class="string">$&#123;spring.application.name&#125;</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">simple:</span>  <span class="comment"># 禁用默认的简单注册表实例</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">prometheus:</span>  <span class="comment"># 启用Prometheus的注册表实例</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="注解">注解</h3>
<p>Micrometer 提供了注解的方式, 为特定类型的方法添加时序监控的支持, 默认 SpringBoot 的自动配置中, 注解只对特定的方法 (比如 <code>controller</code> 的请求映射函数等) 有效, 可以通过配置切面实现注解对所有方法的支持, 详见 <a href="https://micrometer.io/docs/concepts#_the_timed_annotation">annotation</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 配置 */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimedConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>  <span class="comment">// 配置此切面实例, 则时序监控的注解对所有方法都可用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TimedAspect <span class="title">timedAspect</span><span class="params">(MeterRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TimedAspect(registry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 注解 */</span></span><br><span class="line"><span class="meta">@Timed(value = &quot;biz.request&quot;)</span>  <span class="comment">// 统计请求的时序</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Counted(value = &quot;biz.task.failure&quot;, recordFailuresOnly = true)</span>  <span class="comment">// 统计任务失败的时序</span></span><br><span class="line"><span class="meta">@Timed(value = &quot;biz.task&quot;, longTask = true)</span>                      <span class="comment">// 统计任务执行的时序</span></span><br><span class="line"><span class="meta">@Scheduled(fixedDelay = 60000L)</span>  <span class="comment">// 每隔60s定时执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">task</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">5000L</span>);  <span class="comment">// 模拟任务执行5s的用时</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="业务">业务</h3>
<p>Micrometer 监控业务指标主要涉及业务层, 可能需要根据业务流程中的中间数据作为指标的标签集或者采样依据, 为了避免硬编码导致业务代码复杂化, 通常可以通过切面或监听器等外部配置来描述业务指标的采集逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: AOP配置采集业务指标 */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BizAspect</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MeterRegistry registry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Counter bizOrder;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DistributionSummary bizOrderTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;execution(* com.janz.micrometer.OrderBiz.save(..))&quot;, returning = &quot;order&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(OrderDO order)</span> </span>&#123;</span><br><span class="line">        bizOrder.increment();</span><br><span class="line">        bizOrderTime.record(Calendar.getInstance().get(Calendar.HOUR_OF_DAY));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 统计下单的总数</span></span><br><span class="line">        bizOrder = Counter.builder(<span class="string">&quot;biz.order&quot;</span>)</span><br><span class="line">            .description(<span class="string">&quot;Total number of orders.&quot;</span>)</span><br><span class="line">            .register(registry);</span><br><span class="line">        <span class="comment">// 统计按时段下单的分布</span></span><br><span class="line">        bizOrderTime = DistributionSummary.builder(<span class="string">&quot;biz.order.time&quot;</span>)</span><br><span class="line">            .description(<span class="string">&quot;Time distribution of orders.&quot;</span>)</span><br><span class="line">            .serviceLevelObjectives(<span class="number">6d</span>, <span class="number">12d</span>, <span class="number">15d</span>, <span class="number">20d</span>, <span class="number">24d</span>)</span><br><span class="line">            .publishPercentiles(<span class="number">0.5d</span>, <span class="number">0.95d</span>)</span><br><span class="line">            .minimumExpectedValue(<span class="number">0.1d</span>)</span><br><span class="line">            .maximumExpectedValue(<span class="number">24d</span>)</span><br><span class="line">            .register(registry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="样本">样本</h3>
<p>通过 SpringBoot 样本采集的端点 <a href="http://127.0.0.1:8080/actuator/prometheus">/actuator/prometheus</a> 可以查看获取样本的示例, 采集的数据包括 Micrometer 默认提供的应用信息 (如 JVM 等) 的指标样本, 也包括开发人员通过代码配置的业务指标所采集的样本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 获取样本</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl --location --request GET <span class="string">&#x27;http://127.0.0.1:8080/actuator/prometheus&#x27;</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此处示例仅截取返回的文本数据中的业务指标</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> HELP biz_request_seconds_max</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> TYPE biz_request_seconds_max gauge</span></span><br><span class="line">biz_request_seconds_max&#123;application=&quot;myapp&quot;,class=&quot;com.janz.micrometer.BizApi&quot;,exception=&quot;none&quot;,method=&quot;hello&quot;,&#125; 0.001108587</span><br><span class="line"><span class="meta">#</span><span class="bash"> HELP biz_request_seconds</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> TYPE biz_request_seconds summary</span></span><br><span class="line">biz_request_seconds_count&#123;application=&quot;myapp&quot;,class=&quot;com.janz.micrometer.BizApi&quot;,exception=&quot;none&quot;,method=&quot;hello&quot;,&#125; 1.0</span><br><span class="line">biz_request_seconds_sum&#123;application=&quot;myapp&quot;,class=&quot;com.janz.micrometer.BizApi&quot;,exception=&quot;none&quot;,method=&quot;hello&quot;,&#125; 0.001108587</span><br><span class="line"><span class="meta">#</span><span class="bash"> HELP biz_task_seconds_max</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> TYPE biz_task_seconds_max gauge</span></span><br><span class="line">biz_task_seconds_max&#123;application=&quot;myapp&quot;,class=&quot;com.janz.micrometer.App&quot;,method=&quot;task&quot;,&#125; 2.892344573</span><br><span class="line"><span class="meta">#</span><span class="bash"> HELP biz_task_seconds</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> TYPE biz_task_seconds summary</span></span><br><span class="line">biz_task_seconds_active_count&#123;application=&quot;myapp&quot;,class=&quot;com.janz.micrometer.App&quot;,method=&quot;task&quot;,&#125; 1.0</span><br><span class="line">biz_task_seconds_duration_sum&#123;application=&quot;myapp&quot;,class=&quot;com.janz.micrometer.App&quot;,method=&quot;task&quot;,&#125; 2.892319617</span><br><span class="line"><span class="meta">#</span><span class="bash"> HELP biz_order_time Time distribution of orders.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> TYPE biz_order_time histogram</span></span><br><span class="line">biz_order_time&#123;application=&quot;myapp&quot;,quantile=&quot;0.5&quot;,&#125; 0.0</span><br><span class="line">biz_order_time&#123;application=&quot;myapp&quot;,quantile=&quot;0.95&quot;,&#125; 0.0</span><br><span class="line">biz_order_time_bucket&#123;application=&quot;myapp&quot;,le=&quot;6.0&quot;,&#125; 0.0</span><br><span class="line">biz_order_time_bucket&#123;application=&quot;myapp&quot;,le=&quot;12.0&quot;,&#125; 0.0</span><br><span class="line">biz_order_time_bucket&#123;application=&quot;myapp&quot;,le=&quot;15.0&quot;,&#125; 0.0</span><br><span class="line">biz_order_time_bucket&#123;application=&quot;myapp&quot;,le=&quot;20.0&quot;,&#125; 0.0</span><br><span class="line">biz_order_time_bucket&#123;application=&quot;myapp&quot;,le=&quot;24.0&quot;,&#125; 0.0</span><br><span class="line">biz_order_time_bucket&#123;application=&quot;myapp&quot;,le=&quot;+Inf&quot;,&#125; 0.0</span><br><span class="line">biz_order_time_count&#123;application=&quot;myapp&quot;,&#125; 0.0</span><br><span class="line">biz_order_time_sum&#123;application=&quot;myapp&quot;,&#125; 0.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> HELP biz_order_time_max Time distribution of orders.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> TYPE biz_order_time_max gauge</span></span><br><span class="line">biz_order_time_max&#123;application=&quot;myapp&quot;,&#125; 0.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> HELP biz_order_total Total number of orders.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> TYPE biz_order_total counter</span></span><br><span class="line">biz_order_total&#123;application=&quot;myapp&quot;,&#125; 0.0</span><br></pre></td></tr></table></figure>
<h2 id="仪表盘">仪表盘</h2>
<p>Prometheus 通常使用 Grafana 作为可视化的仪表盘, Micrometer 提供了 Grafana 的现成模板, 参考 <a href="https://grafana.com/grafana/dashboards/4701">dashboards/4701</a></p>
<figure>
<img data-src="https://grafana.com/api/dashboards/4701/images/5594/image" alt="Micrometer 模板" /><figcaption aria-hidden="true">Micrometer 模板</figcaption>
</figure>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Prometheus</tag>
        <tag>SpringBoot</tag>
        <tag>Micrometer</tag>
      </tags>
  </entry>
  <entry>
    <title>Prometheus 入门</title>
    <url>/2021/06/21/prometheus-001/</url>
    <content><![CDATA[<h1 id="入门">入门</h1>
<p><a href="https://prometheus.io/">Prometheus</a> 主要用于提供近实时的, 基于动态云环境和容器的微服务, 服务和应用程序的内省监控, Prometheus 专注于现在正在发生的事情, 而不是追踪数周或数月前的数据, 它基于这样一个前提, 即大多数监控查询和警报都是从最近的数据中生成的</p>
<p>Prometheus 主要由 6 个核心模块构成:</p>
<ul>
<li><strong>Prometheus Server</strong> 是最核心的模块, 它主要包含抓取, 存储和查询这 3 个功能, 通过静态配置或服务发现监控的目标, 周期性的从 Prometheus Targets 或 Pushgateway 拉取监控指标数据, 数据通过一定的规则清理和数据整理后, 存储到新的时间序列中进行持久化, 之后客户端就可以通过 PromQL 语句对数据进行查询</li>
<li><strong>Service Discovery</strong> 支持通过文件配置静态地址或服务发现的目标, 相对于直接使用文件配置, 在云环境以及容器环境下更多的监控对象都是动态的, 实际场景下, Prometheus 更适合云以及容器环境下的监控需求</li>
<li><strong>Prometheus Targets</strong> 是 Prometheus 监控的对象, 对于长时间执行的 Job, 可以使用 Exporter 集成进行监控, Exporter 的机制是将第三方系统的监控数据按照 Prometheus 的格式暴露出来, Prometheus 是拉模式为主的监控系统</li>
<li><strong>Pushgateway</strong> 是用于支持临时性 Job 主动推送指标的中间网关, 它使用推模式收集数据, 本质上是用于解决 Prometheus 服务器和监控目标有网络隔离的场景</li>
<li><strong>Dashboard</strong> 除了内置的查询语言 PromQL 以外, Prometheus 还支持表达式浏览器和基于表达式浏览器的数据图形界面, 实际工作中使用 Grafana 等作为前端展示界面</li>
<li><strong>AlertManager</strong> 是独立于 Prometheus 的一个告警组件, 需要单独安装部署, AlertManager 通过接收 Prometheus 推送过来的告警, 用于管理, 整合和分发告警到不同的目的地, AlertManager 提供了多种内置的第三方告警通知方式, 同时还提供了对 Webhook 通知的支持</li>
</ul>
<figure>
<img data-src="https://cdn.jsdelivr.net/gh/prometheus/prometheus@428e1ad42c8f6477037e7baf313209a59ad4450a/documentation/images/architecture.svg" alt="Prometheus 架构图" /><figcaption aria-hidden="true">Prometheus 架构图</figcaption>
</figure>
<h2 id="安装">安装</h2>
<p>Prometheus 官网提供了预编译的二进制文件 <a href="https://github.com/prometheus/prometheus/releases">releases</a>, 也支持使用容器的方式部署 <a href="https://hub.docker.com/r/prom/prometheus">prom/prometheus</a>, 详见 <a href="https://prometheus.io/docs/prometheus/latest/installation/">installation</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: docekr部署</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -d</span></span><br><span class="line">  -p 9090:9090</span><br><span class="line">  -v prometheus.yml:/etc/prometheus/prometheus.yml</span><br><span class="line">  prom/prometheus</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 使用包管理器安装</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> scoop install prometheus  <span class="comment"># windows</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> brew  install prometheus  <span class="comment"># macos</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>除了单独安装外, 部署 Prometheus 的最佳方式在很大程度上取决于服务器的实际环境, 开发者可以使用配置文件来构建自己的部署并将 Prometheus 打包成服务</p>
</blockquote>
<p>集成好的监控套件, 以下是一些服务整合的配置</p>
<ul>
<li><a href="https://github.com/vegasbrianc/prometheus">vegasbrianc/prometheus</a></li>
<li><a href="https://github.com/danguita/prometheus-monitoring-stack">danguita/prometheus-monitoring-stack</a></li>
<li><a href="https://github.com/robinong79/docker-swarm-monitoring">robinong79/docker-swarm-monitoring</a></li>
</ul>
<p>管理工具配置的监控, 以下是一些管理工具的扩展</p>
<ul>
<li>Puppet <a href="https://forge.puppet.com/modules/puppet/prometheus">puppet/prometheus</a></li>
<li>Chef <a href="https://github.com/elijah/chef-prometheus">elijah/chef-prometheus</a></li>
<li>Ansible <a href="https://github.com/cloudalchemy/ansible-prometheus">cloudalchemy/ansible-prometheus</a></li>
<li>SaltStack <a href="https://github.com/saltstack-formulas/prometheus-formula">saltstack-formulas/prometheus-formula</a></li>
</ul>
<p>可以通过 Kubernetes 集群部署</p>
<ul>
<li><a href="https://github.com/kayrus/prometheus-kubernetes">kayrus/prometheus-kubernetes</a></li>
<li><a href="https://github.com/prometheus-operator/prometheus-operator">prometheus-operator/prometheus-operator</a></li>
</ul>
<h3 id="配置">配置</h3>
<p>Prometheus 通过 YAML 文件来配置, 初始的配置文件 <code>prometheus.yml</code> 位于执行文件的根目录, 详见 <a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/#configuration-file">configuration</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件: prometheus.yml</span></span><br><span class="line"><span class="attr">global:</span>  <span class="comment"># 全局配置</span></span><br><span class="line">  <span class="attr">scrape_interval:</span>     <span class="string">15s</span>  <span class="comment"># 指定应用程序或服务抓取数据的时间间隔, 默认1m</span></span><br><span class="line">  <span class="attr">evaluation_interval:</span> <span class="string">15s</span>  <span class="comment"># 指定评估规则的频率, 默认1m</span></span><br><span class="line"></span><br><span class="line"><span class="attr">alerting:</span>  <span class="comment"># 告警配置</span></span><br><span class="line">  <span class="attr">alertmanagers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">static_configs:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">targets:</span></span><br><span class="line">          <span class="comment"># - alertmanager:9093</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rule_files:</span>  <span class="comment"># 指定包含记录规则或警报规则的文件列表</span></span><br><span class="line"><span class="comment"># - &quot;first_rules.yml&quot;</span></span><br><span class="line"><span class="comment"># - &quot;second_rules.yml&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">scrape_configs:</span>  <span class="comment"># 指定抓取的所有目标</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;prometheus&#x27;</span>  <span class="comment"># 默认配置中定义了监控Prometheus服务自身的作业</span></span><br><span class="line">    <span class="comment"># metrics_path defaults to &#x27;/metrics&#x27;</span></span><br><span class="line">    <span class="comment"># scheme defaults to &#x27;http&#x27;</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;localhost:9090&#x27;</span>]  <span class="comment"># 通过静态方式配置抓取的端点, 每个地址对应一个目标</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Prometheus将它抓取的指标的数据源称为端点, 为了抓取这些端点的数据, Prometheus定义了目标, 这个目标里包含的信息是抓取数据所必需的, 比如用到的标签, 建立连接所需的身份验证, 或者其他定义数据抓取的信息, 若干目标构成的组称为作业, 作业里每个目标都有一个名为实例的标签, 用来唯一标识这个目标</span></span><br></pre></td></tr></table></figure>
<p>YAML 配置非常复杂, 建议通过 Prometheus 附带的代码校验工具 <code>promtool</code> 来验证 YAML 配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 验证配置文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> promtool check config prometheus.yml</span></span><br></pre></td></tr></table></figure>
<p>可以在控制台 <a href="http://localhost:9090/config">/config</a> 查看当前服务使用的配置信息</p>
<h3 id="认证">认证</h3>
<p>Prometheus 支持 basic 认证和 TLS, 通过 <code>--web.config.file</code> 指定配置文件, 详见 <a href="https://prometheus.io/docs/prometheus/latest/configuration/https/">authentication</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例: 认证配置</span></span><br><span class="line"><span class="attr">basic_auth_users:</span></span><br><span class="line">  <span class="attr">admin:</span> <span class="string">$2y$10$mDwo.lAisC94iLAyP81MCesa29IzH37oigHC/42V2pdJlUprsJPze</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>密码参考 <a href="https://github.com/prometheus/exporter-toolkit/blob/master/docs/web-configuration.md#about-bcrypt">bcrypt</a></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 验证认证配置</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> promtool check web-config web-config.yml</span></span><br></pre></td></tr></table></figure>
<p>使用 Nginx 反向代理 Prometheus 时, 配置 basic 认证和 TLS 的示例, 参考 <a href="https://prometheus.io/docs/guides/basic-auth/">basic</a> <a href="https://prometheus.io/docs/guides/tls-encryption/">tls</a></p>
<h3 id="启动">启动</h3>
<p>通过运行 <code>prometheus</code> 执行文件启动服务, 详见 <a href="https://prometheus.io/docs/prometheus/latest/getting_started/#starting-prometheus">starting</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 启动服务</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> prometheus</span></span><br><span class="line">  --config.file=&quot;./prometheus.yml&quot;      # 指定配置文件, 默认使用根目录中初始的配置文件</span><br><span class="line">  --web.config.file=&quot;./web-config.yml&quot;  # 指定认证配置</span><br><span class="line">  --web.enable-lifecycle                # 开启管理API的端点</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可通过-h选项查看帮助内容</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 通过端点关闭服务</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -X POST http://localhost:9090/-/quit</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 前提启动时指定选项--web.enable-lifecycle</span></span><br></pre></td></tr></table></figure>
<p>服务启动之后, 可以在控制台 <a href="http://localhost:9090/targets">/targets</a> 查看当前的监控目标列表</p>
<p>初始配置中只有一个作业 <code>prometheus</code> 的监控目标, 目标的监控数据从本地的 <code>9090</code> 端口返回指标, 可以通过配置的端点默认值 <a href="http://localhost:9090/metrics">/metrics</a> 查看抓取的指标数据</p>
<p>Prometheus 提供了一组管理 API, 以促进自动化和集成, 详见 <a href="https://prometheus.io/docs/prometheus/latest/management_api/">management-api</a></p>
<ul>
<li><code>GET /-/healthy</code> 该端点用于显示服务的健康状态</li>
<li><code>GET /-/ready</code> 当服务准备好时, 该端点返回 <code>200</code> 状态码</li>
<li><code>POST /-/reload</code> 该端点用于触发重新加载服务的配置和规则文件</li>
<li><code>POST /-/quit</code> 该端点用于触发服务正常关闭</li>
</ul>
<h2 id="作业">作业</h2>
<p>在 Prometheus 中可以获取的端点称为实例(instance), 通常对应于单个进程, 具有相同目的的实例集合称为作业(job), 详见 <a href="https://prometheus.io/docs/concepts/jobs_instances/">jobs</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例: 静态配置</span></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;jenkins&#x27;</span>         <span class="comment"># 配置作业名称</span></span><br><span class="line">    <span class="attr">metrics_path:</span> <span class="string">&#x27;prometheus&#x27;</span>  <span class="comment"># 配置获取指标的资源路径</span></span><br><span class="line">    <span class="attr">scheme:</span> <span class="string">http</span>                <span class="comment"># 配置请求使用的协议</span></span><br><span class="line">    <span class="attr">basic_auth:</span>                 <span class="comment"># 配置认证</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">&#x27;xxxxxx&#x27;</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">&#x27;xxxxxx&#x27;</span></span><br><span class="line">    <span class="attr">static_configs:</span>             <span class="comment"># 静态配置</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span>                <span class="comment"># 配置目标组</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;127.0.0.1:8080&#x27;</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#x27;127.0.0.1:8081&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="服务发现">服务发现</h3>
<p>在基于云的基础设施环境中, 应用可以随着定义的规则动态的创建或者销毁, 从而自适应访问规模的变化, 这种按需的资源使用方式对于监控系统而言就意味着没有一个固定的监控目标, Prometheus 的解决方案是引入服务发现(service discovery) 的模式</p>
<h4 id="基于文件">基于文件</h4>
<p>基于文件的服务发现不需要依赖其它的平台或第三方服务, 因此可以通过与自动化配置管理工具结合使用, 将监控目标的信息写入文件, Prometheus 就会定时从文件中读取最新的目标信息, 详见 <a href="https://prometheus.io/docs/guides/file-sd/">file-sd</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例: 基于文件的配置</span></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;file_ds&#x27;</span></span><br><span class="line">    <span class="attr">file_sd_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">refresh_interval:</span> <span class="string">5m</span>   <span class="comment"># 读取文件的频率, 默认5分钟</span></span><br><span class="line">        <span class="attr">files:</span> [<span class="string">targets.json</span>]  <span class="comment"># 包含目标信息的文件</span></span><br></pre></td></tr></table></figure>
<h4 id="基于-http">基于 http</h4>
<p>基于 http 协议的服务发现提供了更通用的方式获取目标信息, 它能够通过接口的端点获取目标信息, 详见 <a href="https://prometheus.io/docs/prometheus/latest/http_sd/">http-sd</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例: 基于HTTP的配置</span></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;http_ds&#x27;</span></span><br><span class="line">    <span class="attr">http_sd_config:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">url:</span> <span class="string">&#x27;http://example.com/prometheus&#x27;</span>  <span class="comment"># 用于获取目标信息的端点</span></span><br></pre></td></tr></table></figure>
<h4 id="基于服务中心">基于服务中心</h4>
<p>Prometheus 支持多种常用的服务发现组件, 如 Kubernetes, Zookeeper, Azure, Consul 等, 详见 <a href="https://prometheus.io/blog/2015/06/01/advanced-service-discovery/">service-discovery</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例: 基于consul的配置</span></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">service-y</span></span><br><span class="line">    <span class="attr">consul_sd_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">server:</span> <span class="string">&#x27;localhost:1234&#x27;</span></span><br><span class="line">        <span class="attr">token:</span> <span class="string">mysecret</span></span><br><span class="line">        <span class="attr">services:</span> [<span class="string">&#x27;nginx&#x27;</span>, <span class="string">&#x27;cache&#x27;</span>, <span class="string">&#x27;mysql&#x27;</span>]</span><br><span class="line">        <span class="attr">tags:</span> [<span class="string">&quot;canary&quot;</span>, <span class="string">&quot;v1&quot;</span>]</span><br><span class="line">        <span class="attr">node_meta:</span></span><br><span class="line">          <span class="attr">rack:</span> <span class="string">&quot;123&quot;</span></span><br><span class="line">        <span class="attr">allow_stale:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">scheme:</span> <span class="string">https</span></span><br><span class="line">        <span class="attr">tls_config:</span></span><br><span class="line">          <span class="attr">ca_file:</span> <span class="string">valid_ca_file</span></span><br><span class="line">          <span class="attr">cert_file:</span> <span class="string">valid_cert_file</span></span><br><span class="line">          <span class="attr">key_file:</span>  <span class="string">valid_key_file</span></span><br><span class="line">          <span class="attr">insecure_skip_verify:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="规则">规则</h2>
<p>Prometheus 中可以定期执行的两种规则为 <strong>记录规则(recording rules)</strong> 和 <strong>告警规则(alerting rules)</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 验证规则文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> promtool check rules rules/*.yml</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件: prometheus.yml</span></span><br><span class="line"><span class="attr">rule_files:</span>  <span class="comment"># 指定包含记录规则或警报规则的文件列表</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;rules/node.rules.yml&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;rules/instance.alerts.yml&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 重载配置和规则文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -X POST http://localhost:9090/-/reload</span></span><br></pre></td></tr></table></figure>
<p>可以在控制台 <a href="http://localhost:9090/rules">/rules</a> 查看配置的规则列表, 每一条规则都提供了一个可供参考的评估时间</p>
<h3 id="记录规则">记录规则</h3>
<p>记录规则可以预先计算经常需要或计算量大的表达式, 并将结果保存为一组新的时间序列, 由此实现对复杂查询语句的性能优化并提高查询效率, 查询预计算的结果通常在速率上比每次执行原始表达式要快得多, 这对于仪表板特别有用, 仪表板每次刷新时都需要重复查询相同的表达式, 详见 <a href="https://prometheus.io/docs/prometheus/latest/configuration/recording_rules/">recording-rules</a></p>
<p>记录规则在规则组中定义, 规则组中的规则是按顺序执行的, 可以根据规则创建指标, 并在后面的规则中重用这些指标, 这个特性仅在规则组内使用, 不适用于并行关系的规则组之间</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件: rules/node.rules.yml</span></span><br><span class="line"><span class="attr">groups:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">node_rules</span>  <span class="comment"># 规则组名称, 在服务器上必须是唯一的</span></span><br><span class="line">    <span class="attr">rules:</span></span><br><span class="line">      <span class="comment"># 记录每个实例的每个模式的CPU使用率</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">record:</span> <span class="string">instance_mode:node_cpu_seconds_total:rate5m</span>                   <span class="comment"># 规则的命名</span></span><br><span class="line">        <span class="attr">expr:</span> <span class="string">sum</span> <span class="string">without(cpu)(rate(node_cpu_seconds_total&#123;job=&quot;node&quot;&#125;[5m]))</span>  <span class="comment"># 生成新时间序列的查询</span></span><br><span class="line">      <span class="comment"># 记录所有实例的每个模式的CPU使用率</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">record:</span> <span class="string">mode:node_cpu_seconds_total:rate5m</span></span><br><span class="line">        <span class="attr">expr:</span> <span class="string">sum</span> <span class="string">without(instance)(instance_mode:node_cpu_seconds_total:rate5m)</span></span><br></pre></td></tr></table></figure>
<h3 id="告警规则">告警规则</h3>
<p>告警规则可以基于 PromQL 表达式定义告警条件, 并将有关触发告警的通知发送到外部服务器, 只要告警表达式在给定的时间点生成一个或多个矢量元素, 告警就被这些元素的标签集视为处于活动状态, 详见 <a href="https://prometheus.io/docs/prometheus/latest/configuration/alerting_rules/">alerting-rules</a></p>
<p>在告警中可以使用模板, 模板使用标准的 Go 语法, 详见 <a href="https://prometheus.io/docs/prometheus/latest/configuration/template_examples/">template</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件: rules/instance.alerts.yml</span></span><br><span class="line"><span class="attr">groups:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">instance_alerts</span></span><br><span class="line">    <span class="attr">rules:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">alert:</span> <span class="string">InstanceDown</span></span><br><span class="line">        <span class="attr">expr:</span> <span class="string">up</span> <span class="string">==</span> <span class="number">0</span></span><br><span class="line">        <span class="attr">for:</span> <span class="string">5m</span>       <span class="comment"># 控制在触发告警之前表达式必须满足的持续时间</span></span><br><span class="line">        <span class="attr">annotations:</span>  <span class="comment"># 指定信息标签, 可用于存储更长的附加信息, 例如告警描述等</span></span><br><span class="line">          <span class="attr">summary:</span> <span class="string">&quot;Instance <span class="template-variable">&#123;&#123; $labels.instance &#125;&#125;</span> down&quot;</span></span><br><span class="line">          <span class="attr">description:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; $labels.instance &#125;&#125;</span> of job <span class="template-variable">&#123;&#123; $labels.job &#125;&#125;</span> has been down for more than 5 minutes.&quot;</span></span><br></pre></td></tr></table></figure>
<p>可以在控制台 <a href="http://localhost:9090/alerts">/alerts</a> 查看监控中的告警列表, 告警规则有三种状态:</p>
<ul>
<li>非活动(Inactive) 没有触发阈值</li>
<li>挂起(Pending) 已触发阈值但未满足告警的持续时间</li>
<li>触发(Firing) 已触发阈值且满足告警的持续时间</li>
</ul>
<h2 id="存储">存储</h2>
<p>Prometheus 包括一个本地磁盘上的时间序列数据库, 但也可以选择与远程存储系统集成, 详见 <a href="https://prometheus.io/docs/prometheus/latest/storage/">storage</a></p>
<h3 id="本地存储">本地存储</h3>
<p>Prometheus 存储层使用 Prometheus TSDB 的本地存储, 详见 <a href="https://github.com/prometheus/prometheus/tree/main/tsdb">prometheus-tsdb</a></p>
<p>TSDB 工具已包含在 <code>promtool</code> 中, 可以用于分析和监测数据库中条目的流失(churn) 和基数(cardinality)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 帮助文档</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> promtool -h</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 截取输出tsdb相关的命令</span></span><br><span class="line">Commands:</span><br><span class="line">  tsdb bench write [&lt;flags&gt;] [&lt;file&gt;]</span><br><span class="line">    Run a write performance benchmark.</span><br><span class="line">  tsdb analyze [&lt;flags&gt;] [&lt;db path&gt;] [&lt;block id&gt;]</span><br><span class="line">    Analyze churn, label pair cardinality.</span><br><span class="line">  tsdb list [&lt;flags&gt;] [&lt;db path&gt;]</span><br><span class="line">    List tsdb blocks.</span><br><span class="line">  tsdb dump [&lt;flags&gt;] [&lt;db path&gt;]</span><br><span class="line">    Dump samples from a TSDB.</span><br><span class="line">  tsdb create-blocks-from openmetrics &lt;input file&gt; [&lt;output directory&gt;]</span><br><span class="line">    Import samples from OpenMetrics input and produce TSDB blocks. Please refer to the storage docs for more details.</span><br></pre></td></tr></table></figure>
<h4 id="结构">结构</h4>
<p>Prometheus 采集的数据默认保存在根目录的 <code>data</code> 文件夹中, 详见 <a href="https://github.com/prometheus/prometheus/blob/release-2.22/tsdb/docs/format/README.md">format</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 打印data结构</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tree ./data</span></span><br><span class="line">data</span><br><span class="line">├── 01F8YGFNET4KZSJ5AJGBWJVRMB  # 数据块</span><br><span class="line">│     ├── chunks               # 样本数据</span><br><span class="line">│     │     └── 000001</span><br><span class="line">│     ├── index                # 索引文件</span><br><span class="line">│     ├── meta.json            # 元数据文件</span><br><span class="line">│     └── tombstones           # 里程碑文件</span><br><span class="line">├── 01F8YKYX0S8QQWCKC0BAJYX8B2</span><br><span class="line">├── 01F8YTTPQH6FPXY4N68F2CG2JK</span><br><span class="line">├── 01F8Z1PE0BVDXM5YCFFYDY840P</span><br><span class="line">├── 01F8Z8J586KGS1WMNW7HCXB18P</span><br><span class="line">├── chunks_head</span><br><span class="line">├── lock</span><br><span class="line">├── queries.active</span><br><span class="line">└── wal                         # 预写日志</span><br><span class="line">       ├── 00000002</span><br><span class="line">       ├── 00000003</span><br><span class="line">       └── checkpoint.00000001  # 检查点</span><br></pre></td></tr></table></figure>
<ul>
<li><p>数据块(block)</p>
<p>TSDB 中默认每 2 小时为一个时间窗口, 产生的数据存储在一个数据块中, 数据块会定期压缩, 合并和清理, 每个数据块都拥有全局唯一的名称, 这是通过 <a href="https://github.com/ulid/spec">ULID</a> 原理生成的</p>
<ul>
<li><p>样本数据(chunks)</p>
<p>保存时序数据的目录, 按文件大小 <code>512MB</code> 存为多个文件, 通过数字编号命名</p></li>
<li><p>索引(index)</p>
<p>该文件是 TSDB 实现高效查询的基础, 可以通过指标名称(metrics name) 和标签(labels) 查找时序数据在样本数据中的位置</p></li>
<li><p>元数据(meta.json)</p>
<p>数据块的元数据, 该文件记录的信息用于数据块的合并和清理等操作</p></li>
<li><p>里程碑(tombstones)</p>
<p>该文件用于对数据进行软删除, TSDB 采用标记删除的策略来降低删除操作的成本</p></li>
</ul></li>
<li><p>预写日志(wal)</p>
<p>TSDB 的关键点是先写日志再写磁盘, 使用预写日志(write-ahead logging) 技术可以方便的进行回滚, 重试数据等操作, 保证数据可靠性, 日志按文件大小 <code>128MB</code> 分为多个文件段, 这些文件包括还没有被压缩的原始数据, 所以比常规的数据块文件大得多</p>
<ul>
<li><p>检查点(checkpoint)</p>
<p>该文件用于对日志数量进行控制, 它用于日志定期压缩和清理, 目的是减少宕机后恢复的时长, 降低磁盘占用率</p></li>
</ul></li>
</ul>
<h4 id="配置-1">配置</h4>
<p>Prometheus 将时间序列及其样本存储在磁盘上, 鉴于磁盘空间是有限的资源, Prometheus 提供了几个参数来修改本地存储的配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 可选配置</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> prometheus -h</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 截取输出storage.tsdb相关的命令</span></span><br><span class="line">Flags:</span><br><span class="line">      --storage.tsdb.path=&quot;data/&quot;  </span><br><span class="line">                                 Base path for metrics storage.</span><br><span class="line">      --storage.tsdb.retention=STORAGE.TSDB.RETENTION  </span><br><span class="line">                                 [DEPRECATED] How long to retain samples in storage. This flag has been deprecated, use</span><br><span class="line">                                 &quot;storage.tsdb.retention.time&quot; instead.</span><br><span class="line">      --storage.tsdb.retention.time=STORAGE.TSDB.RETENTION.TIME  </span><br><span class="line">                                 How long to retain samples in storage. When this flag is set it overrides</span><br><span class="line">                                 &quot;storage.tsdb.retention&quot;. If neither this flag nor &quot;storage.tsdb.retention&quot; nor</span><br><span class="line">                                 &quot;storage.tsdb.retention.size&quot; is set, the retention time defaults to 15d. Units Supported: y, w,</span><br><span class="line">                                 d, h, m, s, ms.</span><br><span class="line">      --storage.tsdb.retention.size=STORAGE.TSDB.RETENTION.SIZE  </span><br><span class="line">                                 [EXPERIMENTAL] Maximum number of bytes that can be stored for blocks. A unit is required,</span><br><span class="line">                                 supported units: B, KB, MB, GB, TB, PB, EB. Ex: &quot;512MB&quot;. This flag is experimental and can be</span><br><span class="line">                                 changed in future releases.</span><br><span class="line">      --storage.tsdb.no-lockfile  </span><br><span class="line">                                 Do not create lockfile in data directory.</span><br><span class="line">      --storage.tsdb.allow-overlapping-blocks  </span><br><span class="line">                                 [EXPERIMENTAL] Allow overlapping blocks, which in turn enables vertical compaction and vertical</span><br><span class="line">                                 query merge.</span><br><span class="line">      --storage.tsdb.wal-compression  </span><br><span class="line">                                 Compress the tsdb WAL.</span><br></pre></td></tr></table></figure>
<h3 id="远程存储">远程存储</h3>
<p>Prometheus 的远程写入 <a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/#remote_write">remote_write</a> 和远程读取 <a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/#remote_read">remote_read</a> 功能允许透明的发送和接收样本, 这主要用于长期存储, 用户可以在配置文件中指定远程的 URL 地址, Prometheus 将采集到的样本数据通过 HTTP 的形式发送给适配器(adaptor), 而适配器则实现对接外部的远程存储系统, 外部系统可以是真正的存储系统, 公有云的存储服务, 消息队列等任意形式, 详见 <a href="https://prometheus.io/docs/prometheus/latest/storage/#remote-storage-integrations">remote-storage</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例: 远程配置</span></span><br><span class="line"><span class="attr">remote_write:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">url:</span> <span class="string">http://remote1/push</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">drop_expensive</span></span><br><span class="line">    <span class="attr">write_relabel_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__name__</span>]</span><br><span class="line">        <span class="attr">regex:</span> <span class="string">expensive.*</span></span><br><span class="line">        <span class="attr">action:</span> <span class="string">drop</span></span><br><span class="line">    <span class="attr">oauth2:</span></span><br><span class="line">      <span class="attr">client_id:</span> <span class="string">&quot;123&quot;</span></span><br><span class="line">      <span class="attr">client_secret:</span> <span class="string">&quot;456&quot;</span></span><br><span class="line">      <span class="attr">token_url:</span> <span class="string">&quot;http://remote1/auth&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">url:</span> <span class="string">http://remote2/push</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">rw_tls</span></span><br><span class="line">    <span class="attr">tls_config:</span></span><br><span class="line">      <span class="attr">cert_file:</span> <span class="string">valid_cert_file</span></span><br><span class="line">      <span class="attr">key_file:</span> <span class="string">valid_key_file</span></span><br><span class="line">    <span class="attr">headers:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">value</span></span><br><span class="line"><span class="attr">remote_read:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">url:</span> <span class="string">http://remote1/read</span></span><br><span class="line">    <span class="attr">read_recent:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">default</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">url:</span> <span class="string">http://remote3/read</span></span><br><span class="line">    <span class="attr">read_recent:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">read_special</span></span><br><span class="line">    <span class="attr">required_matchers:</span></span><br><span class="line">      <span class="attr">job:</span> <span class="string">special</span></span><br><span class="line">    <span class="attr">tls_config:</span></span><br><span class="line">      <span class="attr">cert_file:</span> <span class="string">valid_cert_file</span></span><br><span class="line">      <span class="attr">key_file:</span> <span class="string">valid_key_file</span></span><br></pre></td></tr></table></figure>
<p>现有集成的远程存储系统, 详见 <a href="https://prometheus.io/docs/operating/integrations/#remote-endpoints-and-storage">remote-integrations</a></p>
<h2 id="集群">集群</h2>
<p>单体架构并不是高可用集群, 存在发生单点故障的可能性, 而且随着监控规模的扩展, 大量数据的读写也很容易让单体架构响应变慢, 过度消耗系统资源, 因此, 在企业实际生产中, 非常有必要构建 Prometheus 的高可用集群的架构, 详见 <a href="https://prometheus.io/docs/prometheus/latest/federation/#federation">federation</a></p>
<p>因为 Prometheus 是基于时间序列的存储及监控系统, 对系统时间的准确性要求很高, 所以在部署 Prometheus 集群之前, 必须对服务器的时间源做同步, 比如 <a href="http://www.cas.cn/tz/201809/t20180921_4664344.shtml">NTP</a> 网络授时服务</p>
<h3 id="联邦集群">联邦集群</h3>
<p>在每个数据中心部署单独的 Prometheus Server, 用于采集当前数据中心监控数据, 并由一个中心的 Prometheus Server 负责聚合多个数据中心的监控数据, 这一特性在 Prometheus 中称为联邦集群</p>
<p>联邦集群方案可以降低单个服务采集负载, 通过联邦节点汇聚核心数据, 降低单机存储压力, 避免单点故障时都体现出不错的优势</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例: 集群配置</span></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;federate&#x27;</span></span><br><span class="line">    <span class="attr">scrape_interval:</span> <span class="string">15s</span></span><br><span class="line">    <span class="attr">honor_labels:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">metrics_path:</span> <span class="string">&#x27;/federate&#x27;</span></span><br><span class="line">    <span class="attr">params:</span></span><br><span class="line">      <span class="string">&#x27;match[]&#x27;</span><span class="string">:</span>  <span class="comment"># 通过match[]参数指定过滤条件, 可以有效减少聚合不必要的时间序列</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&#x27;&#123;job=&quot;prometheus&quot;&#125;&#x27;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&#x27;&#123;__name__=~&quot;job:.*&quot;&#125;&#x27;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&#x27;&#123;__name__=~&quot;node.*&quot;&#125;&#x27;</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span>  <span class="comment"># 聚合三台节点服务器</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&#x27;source-prometheus-1:9090&#x27;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&#x27;source-prometheus-2:9090&#x27;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&#x27;source-prometheus-3:9090&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="功能分区">功能分区</h3>
<p>当单个采集任务的目标数量非常庞大时, 如果简单通过联邦集群无法有效处理, 可以考虑在实例级别进行功能分区, 可以按照任务的不同实例进行划分, 以支持规模的扩展</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例: 节点配置</span></span><br><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="attr">external_labels:</span></span><br><span class="line">    <span class="attr">slave:</span> <span class="number">1</span>  <span class="comment"># 添加额外标签</span></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;slave&#x27;</span></span><br><span class="line">    <span class="attr">relabel_configs:</span>  <span class="comment"># 只分配采集当前任务的一部分实例的监控指标</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__address__</span>]</span><br><span class="line">        <span class="attr">modulus:</span> <span class="number">4</span></span><br><span class="line">        <span class="attr">target_label:</span> <span class="string">__tmp_hash</span></span><br><span class="line">        <span class="attr">action:</span> <span class="string">hashmod</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__tmp_hash</span>]</span><br><span class="line">        <span class="attr">regex:</span> <span class="string">^1$</span></span><br><span class="line">        <span class="attr">action:</span> <span class="string">keep</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>Prometheus 数据模型</title>
    <url>/2021/06/25/prometheus-002/</url>
    <content><![CDATA[<h1 id="数据模型">数据模型</h1>
<p>每种监控系统都有自己对指标的一套定义和规范, 指标的数据格式将直接影响对数据的采集和存储, 所以定义指标时需要充分考虑通用性和扩展性, Prometheus 基本上以时间序列(time series) 的形式存储所有数据, 详见 <a href="https://prometheus.io/docs/concepts/data_model/">data-model</a></p>
<h2 id="时间序列">时间序列</h2>
<p>Prometheus 从监控目标的端点拉取采样的指标数据, 指标数据以文本形式组织, 每个指标都占用一行, 除了文本的最后一个空行, 其他空行都将被忽略</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: http://localhost:9090/metrics</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> HELP prometheus_http_requests_total Counter of HTTP requests.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> TYPE prometheus_http_requests_total counter</span></span><br><span class="line">prometheus_http_requests_total&#123;code=&quot;200&quot;,handler=&quot;/metrics&quot;&#125; 5357</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此处示例仅截取返回的文本数据中的单个指标</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> HELP 是指标的描述</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> TYPE 是指标的类型</span></span><br></pre></td></tr></table></figure>
<p>时间序列的组成:</p>
<ul>
<li>指标(metric)
<ul>
<li>指标名称(metric name) 用于反映指标的含义, 通常描述收集的时间序列的一般性质</li>
<li>标签集(labels) 通过键值对的形式提供多种特征维度</li>
</ul></li>
<li>样本(sample)
<ul>
<li>时间戳(timestamp) 样本的采集时间, 精确到毫秒</li>
<li>样本值(value) 类型为 <code>float64</code> 的数值, Prometheus 没有对样本值的单位进行定义, 需要使用者自己区分或者事先定义好样本数据的单位</li>
</ul></li>
</ul>
<p><span class="math display">\[
\overbrace{
\overbrace{
\texttt{prometheus_http_requests_total}
}^{\large\textsf{指标名称}}
\overbrace{
\texttt{\{code=&quot;200&quot;,handler=&quot;/metrics&quot;\}}
}^{\large\textsf{标签集}}
}^{\large\textsf{指标}}
\overbrace{
\overbrace{
\; \texttt{5357}
}^{\large\textsf{样本值}}
\overbrace{
\; \texttt{@1624636559.334}
}^{\large\textsf{时间戳}}
}^{\large\textsf{样本}} \\
\]</span></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 时间戳格式化</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> date -d @1624636559.334 +<span class="string">&quot;%F %T.%N&quot;</span></span></span><br><span class="line">2021-06-25 23:55:59.334000000</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 指标名称的存储方式</span></span><br><span class="line">&#123;__name__: &quot;prometheus_http_requests_total&quot;, code=&quot;200&quot;, handler=&quot;/metrics&quot;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>指标名称实际上以标签的形式保存在数据库中, <code>__name__</code> 是特定的标签(系统保留关键字), 用于表示指标名称, 这种方式是系统内部的表现形式, 官方推荐只能在系统内部使用</p>
</blockquote>
<h2 id="指标类型">指标类型</h2>
<p>Prometheus 指标分为 Counter(计数型), Gauge(测量型), Histogram(直方图) 和 Summary(摘要型) 这 4 种类型, 详见 <a href="https://prometheus.io/docs/concepts/metric_types/">metric-types</a></p>
<h3 id="counter">Counter</h3>
<p>Counter 计数型的特点是只增不减, 具有很好的不相关性, 不会因为机器重启而置零, 虽然它们是随着时间增加而不会减少的数字, 但有时可以将其重置为零并再次开始递增, 常见的监控指标如服务的请求数, 已完成的任务数, 错误发生的次数等</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> HELP prometheus_http_requests_total Counter of HTTP requests.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> TYPE prometheus_http_requests_total counter</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 由下表可知: 端点/metrics在时间戳1624639184.334时累计请求5579次, 以此类推</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{array}{l}
\hline
\rlap{
\large\textsf{示例: 查询最近}\normalsize\texttt{1}\large\textsf{分钟内请求端点}\normalsize\texttt{/metrics}\large\textsf{的时序}
} \hphantom{---------------------------------------------------} \\
\texttt{PromQL: prometheus_http_requests_total\{handler=&quot;/metrics&quot;\}[1m]} \\
\hline
\begin{split}
\texttt{prometheus_http_requests_total\{code=&quot;200&quot;, handler=&quot;/metrics&quot;\}} &amp;\qquad &amp; 5579\; @1624639184.334 \\
&amp; &amp; 5580\; @1624639199.334 \\
&amp; &amp; 5580\; @1624639214.334 \\
&amp; &amp; 5580\; @1624639229.334
\end{split} \\
\hline
\end{array}
\]</span></p>
<h3 id="gauge">Gauge</h3>
<p>Gauge 测量型的特点是实时变化, 本质上是特定度量的快照, 常见的监控指标如温度, 内存和磁盘的使用量等</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> HELP process_resident_memory_bytes Resident memory size <span class="keyword">in</span> bytes.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> TYPE process_resident_memory_bytes gauge</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 由下表可知: 常驻内存在时间戳1624640084.334时使用量为109850624(约105MB), 以此类推</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{array}{l}
\hline
\rlap{
\large\textsf{示例: 查询最近}\normalsize\texttt{1}\large\textsf{分钟内常驻内存的时序}
} \hphantom{---------------------------------------------------} \\
\texttt{PromQL: process_resident_memory_bytes[1m]} \\
\hline
\begin{split}
&amp;\texttt{process_resident_memory_bytes\{job=&quot;prometheus&quot;\}} &amp;\qquad &amp; 109850624\; @1624640084.334 \\
&amp; &amp; &amp; 109850624\; @1624640099.334 \\
&amp; &amp; &amp; 109850624\; @1624640114.334 \\
&amp; &amp; &amp; 110100480\; @1624640129.334
\end{split} \\
\hline
\end{array}
\]</span></p>
<h3 id="histogram">Histogram</h3>
<p>Histogram 直方图是对观察点进行采样的指标类型, 通过标签 <code>le</code> 指定上边界, 统计小于上边界的区间内的样本个数, 常用于应用性能等领域的分析观察</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> HELP prometheus_tsdb_compaction_chunk_samples Final number of samples on their first compaction</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> TYPE prometheus_tsdb_compaction_chunk_samples histogram</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 由下表可知: TSDB首次压缩样本的数量统计, 小于4的有663个, 小于6的有817个, 以此类推</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{array}{l}
\hline
\rlap{
\large\textsf{示例: 查询}\normalsize\texttt{TSDB}\large\textsf{首次压缩样本的时序}
} \hphantom{---------------------------------------------------} \\
\texttt{PromQL: prometheus_tsdb_compaction_chunk_samples_bucket} \\
\hline
\begin{split}
&amp;\texttt{prometheus_tsdb_compaction_chunk_samples_bucket\{le=&quot;4&quot;\}} &amp;\qquad &amp; 663 \\
&amp;\texttt{prometheus_tsdb_compaction_chunk_samples_bucket\{le=&quot;6&quot;\}} &amp; &amp; 817 \\
&amp;\texttt{prometheus_tsdb_compaction_chunk_samples_bucket\{le=&quot;9&quot;\}} &amp; &amp; 908 \\
&amp; ... \\
&amp;\texttt{prometheus_tsdb_compaction_chunk_samples_bucket\{le=&quot;230.66015625&quot;\}} &amp; &amp; 130448 \\
&amp;\texttt{prometheus_tsdb_compaction_chunk_samples_bucket\{le=&quot;345.990234375&quot;\}} &amp; &amp; 130455 \\
&amp;\texttt{prometheus_tsdb_compaction_chunk_samples_bucket\{le=&quot;+Inf&quot;\}} &amp; &amp; 130455
\end{split} \\
\hline
\end{array}
\]</span></p>
<h3 id="summary">Summary</h3>
<p>Summary 摘要型是采样点分位图统计, 用于得到数据的分布情况, 常用于分位数的分析观察</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> HELP prometheus_target_interval_length_seconds Actual intervals between scrapes.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> TYPE prometheus_target_interval_length_seconds summary</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 由下表可知: 抓取数据的实际时间间隔的分位数的统计, 1%分布小于14.998899642, 50%分布小于15.000017863(中位数), 以此类推</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{array}{l}
\hline
\rlap{
\large\textsf{示例: 查询抓取数据的实际时间间隔的时序}
} \hphantom{---------------------------------------------------} \\
\texttt{PromQL: prometheus_target_interval_length_seconds} \\
\hline
\begin{split}
&amp;\texttt{prometheus_target_interval_length_seconds\{quantile=&quot;0.01&quot;\}} &amp;\qquad &amp; 14.998899642 \\
&amp;\texttt{prometheus_target_interval_length_seconds\{quantile=&quot;0.05&quot;\}} &amp; &amp; 14.999198291 \\
&amp;\texttt{prometheus_target_interval_length_seconds\{quantile=&quot;0.5&quot;\}} &amp; &amp; 15.000017863 \\
&amp;\texttt{prometheus_target_interval_length_seconds\{quantile=&quot;0.9&quot;\}} &amp; &amp; 15.000658406 \\
&amp;\texttt{prometheus_target_interval_length_seconds\{quantile=&quot;0.99&quot;\}} &amp; &amp; 15.001612175
\end{split} \\
\hline
\end{array}
\]</span></p>
<h2 id="promql">PromQL</h2>
<p><a href="https://prometheus.io/docs/prometheus/latest/querying/basics/">PromQL</a>(Prometheus Query Language) 是 Prometheus 提供的表达式查询语言</p>
<p>PromQL 表达式或子表达式可以计算为 4 种类型之一, 详见 <a href="https://prometheus.io/docs/prometheus/latest/querying/basics/#expression-language-data-types">el-data-types</a></p>
<ul>
<li>瞬时向量(instant vector) 一组时间序列, 每个时间序列包含单个样本, 它们共享相同的时间戳</li>
<li>区间向量(range vector) 一组时间序列, 每个时间序列包含一段时间范围内的样本数据</li>
<li>标量(scalar) 浮点型的数据值, 没有时序</li>
<li>字符串(string) 简单的字符串值, 当前未使用</li>
</ul>
<h3 id="选择器">选择器</h3>
<p>PromQL 提供了选择器功能更改表达式的查询范围, 详见 <a href="https://prometheus.io/docs/prometheus/latest/querying/basics/#time-series-selectors">selectors</a></p>
<h4 id="匹配器">匹配器</h4>
<p>匹配器是作用于标签上的, 标签匹配器可以对时间序列进行过滤, PromQL 支持完全匹配和正则匹配两种模式:</p>
<ul>
<li><code>=</code> 用于选择与提供的字符串完全相同的标签</li>
<li><code>!=</code> 用于选择与提供的字符串不相同的标签</li>
<li><code>=~</code> 用于选择与提供的字符串进行正则运算后所得结果相匹配的标签</li>
<li><code>!~</code> 用于选择与提供的字符串进行正则运算后所得结果不匹配的标签</li>
</ul>
<p><span class="math display">\[
\begin{array}{l}
\hline
\rlap{
\large\textsf{示例: 查询请求的路由端点为}\normalsize\texttt{/api/}\large\textsf{的时序}
} \hphantom{---------------------------------------------------} \\
\texttt{PromQL: prometheus_http_requests_total\{handler=~&quot;/api/.*&quot;\}} \\
\hline
\begin{split}
&amp;\texttt{prometheus_http_requests_total\{handler=&quot;/api/v1/label/:name/values&quot;\}} &amp;\qquad &amp; 21 \\
&amp;\texttt{prometheus_http_requests_total\{handler=&quot;/api/v1/metadata&quot;\}} &amp; &amp; 17 \\
&amp;\texttt{prometheus_http_requests_total\{handler=&quot;/api/v1/query&quot;\}} &amp; &amp; 67 \\
&amp;\texttt{prometheus_http_requests_total\{handler=&quot;/api/v1/query_range&quot;\}} &amp; &amp; 69 \\
&amp;\texttt{prometheus_http_requests_total\{handler=&quot;/api/v1/series&quot;\}} &amp; &amp; 23
\end{split} \\
\hline
\end{array}
\]</span></p>
<blockquote>
<p>PromQL 的正则表达式使用 <a href="https://github.com/google/re2/wiki/Syntax">RE2</a> 语法, 注意其不支持向前匹配表达式</p>
</blockquote>
<h4 id="瞬时向量选择器">瞬时向量选择器</h4>
<p>瞬时向量选择器用于返回在指定时间戳之前查询到的最新样本的瞬时向量, 也就是包含零个或者多个时间序列的列表 <span class="math display">\[
\begin{array}{l}
\hline
\rlap{
\large\textsf{示例: 查询请求的响应码为}\normalsize\texttt{400}\large\textsf{的时序}
} \hphantom{---------------------------------------------------} \\
\texttt{PromQL: prometheus_http_requests_total\{code=&quot;400&quot;\}} \\
\hline
\begin{split}
&amp;\texttt{prometheus_http_requests_total\{code=&quot;400&quot;, handler=&quot;/api/v1/query&quot;\}} &amp;\qquad &amp; 7 \\
&amp;\texttt{prometheus_http_requests_total\{code=&quot;400&quot;, handler=&quot;/api/v1/query_range&quot;\}} &amp; &amp; 1
\end{split} \\
\hline
\end{array}
\]</span></p>
<h4 id="区间向量选择器">区间向量选择器</h4>
<p>区间向量选择器返回一组时间序列, 每个时间序列包含一段时间范围内的样本数据, 时间范围的单位如下:</p>
<ul>
<li><code>ms</code> 毫秒</li>
<li><code>s</code> 秒</li>
<li><code>m</code> 分钟</li>
<li><code>h</code> 小时</li>
<li><code>d</code> 天, 假设一天总是 24 小时</li>
<li><code>w</code> 周, 假设一周总是 7 天</li>
<li><code>y</code> 年, 假设一年总是 365 天</li>
</ul>
<p><span class="math display">\[
\begin{array}{l}
\hline
\rlap{
\large\textsf{示例: 查询最近}\normalsize\texttt{1}\large\textsf{分钟内端点}\normalsize\texttt{/metrics/}\large\textsf{的时序}
} \hphantom{---------------------------------------------------} \\
\texttt{PromQL: prometheus_http_requests_total\{handler=&quot;/metrics&quot;\}[1m]} \\
\hline
\begin{split}
\texttt{prometheus_http_requests_total\{handler=&quot;/metrics&quot;\}} &amp;\qquad &amp; 8580\; @1624684199.334 \\
&amp; &amp; 8581\; @1624684214.334 \\
&amp; &amp; 8582\; @1624684229.334 \\
&amp; &amp; 8583\; @1624684244.334 \\
\end{split} \\
\hline
\end{array}
\]</span></p>
<blockquote>
<p>时间范围必须用整数来表示, 比如 <code>0.5d</code> 是错误的, <code>12h</code> 是正确的</p>
</blockquote>
<h4 id="偏移量修改器">偏移量修改器</h4>
<p>偏移量修改器可以让瞬时向量选择器和区间向量选择器发生偏移, 它允许获取查询计算时间并在每个选择器的基础上将其向前推移 <span class="math display">\[
\begin{array}{l}
\hline
\rlap{
\large\textsf{示例: 查询}\normalsize\texttt{5}\large\textsf{分钟前}\normalsize\texttt{1}\large\textsf{分钟内端点}\normalsize\texttt{/metrics/}\large\textsf{的时序}
} \hphantom{---------------------------------------------------} \\
\texttt{PromQL: prometheus_http_requests_total\{handler=&quot;/metrics&quot;\}[1m] offset 5m} \\
\hline
\begin{split}
\texttt{prometheus_http_requests_total\{handler=&quot;/metrics&quot;\}} &amp;\qquad &amp; 10722\; @1624716329.334 \\
&amp; &amp; 10723\; @1624716344.334 \\
&amp; &amp; 10724\; @1624716359.334 \\
&amp; &amp; 10725\; @1624716374.334 \\
\end{split} \\
\hline
\end{array}
\]</span></p>
<h3 id="二元操作符">二元操作符</h3>
<p>二元操作符表示接受两个操作数的运算符, 可以对瞬时向量进行更复杂的运算, 详见 <a href="https://prometheus.io/docs/prometheus/latest/querying/operators/#binary-operators">binary-operators</a>, PromQL 的二元运算符分为 3 种类型</p>
<h4 id="算术运算符">算术运算符</h4>
<p>PromQL 支持 6 种二元算术运算符: <code>+</code> 加, <code>-</code> 减, <code>*</code> 乘, <code>/</code> 除, <code>%</code> 模, <code>^</code> 幂 <span class="math display">\[
\begin{array}{l}
\hline
\rlap{
\large\textsf{示例: 查询节点上内存的使用率的时序}
} \hphantom{---------------------------------------------------} \\
\texttt{PromQL: (node_memory_MemTotal_bytes - node_memory_MemFree_bytes) / node_memory_MemTotal_bytes} \\
\hline
\begin{split}
\texttt{\{job=&quot;node&quot;\}} &amp;\qquad &amp; 0.7951647542612791
\end{split} \\
\hline
\end{array}
\]</span></p>
<blockquote>
<p>算术运算符支持 标量/标量, 向量/标量, 向量/向量 之间的操作</p>
</blockquote>
<h4 id="集合运算符">集合运算符</h4>
<p>PromQL 支持 3 种集合运算符: <code>and</code> 并集, <code>or</code> 交集, <code>unless</code> 差集 <span class="math display">\[
\begin{array}{l}
\hline
\rlap{
\large\textsf{示例: 查询进程的平均}\normalsize\texttt{cpu}\large\textsf{使用率, 且排除使用少于}\normalsize\texttt{100MB}\large\textsf{常驻内存的进程的时序}
} \hphantom{---------------------------------------------------} \\
\texttt{PromQL: rate(process_cpu_seconds_total[5m]) unless process_resident_memory_bytes &lt; 100*1024*1024} \\
\hline
\begin{split}
&amp;\texttt{\{job=&quot;prometheus&quot;\}} &amp;\qquad &amp; 0.0038947368421053106 \\
&amp;\texttt{\{job=&quot;jenkins&quot;\}} &amp;\qquad &amp; 0.018350877192984113
\end{split} \\
\hline
\end{array}
\]</span></p>
<blockquote>
<p>集合运算符仅支持 瞬时向量 之间的操作</p>
</blockquote>
<h4 id="比较运算符">比较运算符</h4>
<p>PromQL 支持的比较运算符主要包括: <code>==</code> 相等, <code>!=</code> 不相等, <code>&gt;</code> 大于, <code>&lt;</code> 小于, <code>&gt;=</code> 不小于, <code>&lt;=</code> 不大于 <span class="math display">\[
\begin{array}{l}
\hline
\rlap{
\large\textsf{示例: 查询请求数量大于}\normalsize\texttt{50}\large\textsf{的时序}
} \hphantom{---------------------------------------------------} \\
\texttt{PromQL: prometheus_http_requests_total &gt; 50} \\
\hline
\begin{split}
&amp;\texttt{prometheus_http_requests_total\{handler=&quot;/api/v1/query&quot;\}} &amp;\qquad &amp; 93 \\
&amp;\texttt{prometheus_http_requests_total\{handler=&quot;/api/v1/query_range&quot;\}} &amp;\qquad &amp; 69 \\
&amp;\texttt{prometheus_http_requests_total\{handler=&quot;/metrics&quot;\}} &amp;\qquad &amp; 10820
\end{split} \\
\hline
\end{array}
\]</span></p>
<blockquote>
<p>比较运算符支持 标量/标量, 向量/标量, 向量/向量 之间的操作</p>
<p>在两个标量之间做比较运算必须使用 <code>bool</code> 修饰符</p>
</blockquote>
<p>默认情况下, 比较运算符对时间序列的样本值进行过滤, 如果样本值比较的结果为 <code>false</code> 时, 这个时间序列会被丢弃, 结果为 <code>true</code> 时, 则这个时间序列保留在结果中</p>
<p>可以通过在运算符后面使用 <code>bool</code> 修饰符来改变输出的结果, 布尔运算不会对时间序列进行过滤, 而是直接输出时间序列中样本值的比较结果, <code>0</code> 表示 <code>false</code>, <code>1</code> 表示 <code>true</code>, 如果使用了布尔修饰符, 指标名称将被删除 <span class="math display">\[
\begin{array}{l}
\hline
\rlap{
\large\textsf{示例: 查询请求数量大于}\normalsize\texttt{50}\large\textsf{的布尔结果的时序}
} \hphantom{---------------------------------------------------} \\
\texttt{PromQL: prometheus_http_requests_total &gt; bool 50} \\
\hline
\begin{split}
&amp;\texttt{\{handler=&quot;/api/v1/query&quot;\}} &amp;\qquad &amp; 1 \\
&amp;\texttt{\{handler=&quot;/api/v1/query_range&quot;\}} &amp;\qquad &amp; 1 \\
&amp;\texttt{\{handler=&quot;/metrics&quot;\}} &amp;\qquad &amp; 1 \\
&amp;\texttt{\{handler=&quot;/&quot;\}} &amp;\qquad &amp; 0 \\
&amp;... \\
&amp;\texttt{\{handler=&quot;/graph&quot;\}} &amp;\qquad &amp; 0
\end{split} \\
\hline
\end{array}
\]</span></p>
<h4 id="优先级">优先级</h4>
<p>在 PromQL 表达式中, 二元运算符的优先级从高到低的顺序为:</p>
<ol type="1">
<li><code>^</code></li>
<li><code>*</code> <code>/</code> <code>%</code></li>
<li><code>+</code> <code>-</code></li>
<li><code>==</code> <code>!=</code> <code>=</code> <code>&lt;=</code> <code>&lt;</code> <code>&gt;=</code> <code>&gt;</code></li>
<li><code>and</code> <code>unless</code></li>
<li><code>or</code></li>
</ol>
<p>具有相同优先级的运算符满足结合律(左结合), 运算符 <code>^</code> 例外(右结合), 详见 <a href="https://prometheus.io/docs/prometheus/latest/querying/operators/#binary-operator-precedence">precedence</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 优先级</span></span><br><span class="line">a or b * c + d 等价 a or ((b * c) + d)</span><br><span class="line">2 ^ 3 ^ 2 等价 2 ^ (3 ^ 2)</span><br></pre></td></tr></table></figure>
<h3 id="向量匹配">向量匹配</h3>
<p>PromQL 中向量之间的运算操作会基于默认的匹配规则, 依次找到与左边向量的指标匹配 (标签完全一致) 的右边向量的指标进行运算, 如果没有找到, 则直接丢弃指标, 详见 <a href="https://prometheus.io/docs/prometheus/latest/querying/operators/#vector-matching">vector-matching</a>, PromQL 中向量匹配有 2 种匹配模式</p>
<h4 id="一对一">一对一</h4>
<p>一对一匹配模式会从操作符两边表达式获取的瞬时向量依次比较 可以使用 <code>on</code> 或者 <code>ignoring</code> 修改标签的匹配行为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 语法: 匹配时限定在指定的标签列表内</span></span><br><span class="line">&lt;vector expr&gt; &lt;bin-op&gt; on(&lt;label list&gt;) &lt;vector expr&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 语法: 匹配时忽略指定的标签列表</span></span><br><span class="line">&lt;vector expr&gt; &lt;bin-op&gt; ignoring(&lt;label list&gt;) &lt;vector expr&gt;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{array}{l}
\hline
\rlap{
\large\textsf{示例: 查询请求的响应码为}\normalsize\texttt{200}\large\textsf{所占比例的时序}
} \hphantom{---------------------------------------------------} \\
\texttt{PromQL: prometheus_http_requests_total\{code=&quot;200&quot;\} / ignoring(code) (sum without(code)(prometheus_http_requests_total))} \\
\hline
\begin{split}
&amp;\texttt{\{handler=&quot;/api/v1/query&quot;\}} &amp;\qquad &amp; 0.8920863309352518 \\
&amp;\texttt{\{handler=&quot;/api/v1/query_range&quot;\}} &amp;\qquad &amp; 0.9857142857142858
\end{split} \\
\hline
\end{array}
\]</span></p>
<h4 id="一对多">一对多</h4>
<p>一对多匹配模式指的是一侧的每个指标可以与多侧的多个指标匹配, 必须使用 <code>group_(left/right)</code> 指定哪侧是更高的基数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 语法: 分组匹配</span></span><br><span class="line">&lt;vector expr&gt; &lt;bin-op&gt; ignoring(&lt;label list&gt;) group_left(&lt;label list&gt;) &lt;vector expr&gt;</span><br><span class="line">&lt;vector expr&gt; &lt;bin-op&gt; ignoring(&lt;label list&gt;) group_right(&lt;label list&gt;) &lt;vector expr&gt;</span><br><span class="line">&lt;vector expr&gt; &lt;bin-op&gt; on(&lt;label list&gt;) group_left(&lt;label list&gt;) &lt;vector expr&gt;</span><br><span class="line">&lt;vector expr&gt; &lt;bin-op&gt; on(&lt;label list&gt;) group_right(&lt;label list&gt;) &lt;vector expr&gt;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{array}{l}
\hline
\rlap{
\large\textsf{示例: 查询请求的不同响应码所占比例的时序}
} \hphantom{---------------------------------------------------} \\
\texttt{PromQL: prometheus_http_requests_total / ignoring(code) group_left() (sum without(code)(prometheus_http_requests_total))} \\
\hline
\begin{split}
&amp;\texttt{\{code=&quot;200&quot;, handler=&quot;/api/v1/query&quot;\}} &amp;\qquad &amp; 0.8920863309352518 \\
&amp;\texttt{\{code=&quot;200&quot;, handler=&quot;/api/v1/query_range&quot;\}} &amp;\qquad &amp; 0.9857142857142858 \\
&amp;\texttt{\{code=&quot;400&quot;, handler=&quot;/api/v1/query&quot;\}} &amp;\qquad &amp; 0.07534246575342465 \\
&amp;\texttt{\{code=&quot;400&quot;, handler=&quot;/api/v1/query_range&quot;\}} &amp;\qquad &amp; 0.014285714285714285 \\
&amp;\texttt{\{code=&quot;422&quot;, handler=&quot;/api/v1/query&quot;\}} &amp;\qquad &amp; 0.0684931506849315
\end{split} \\
\hline
\end{array}
\]</span></p>
<h3 id="聚合操作">聚合操作</h3>
<p>PromQL 提供聚合操作, 可用于聚合单个瞬时向量的时序, 形成一个具有较少样本值的新向量, 详见 <a href="https://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators">aggregation-operators</a>, PromQL 支持以下的聚合操作:</p>
<ul>
<li><code>sum</code> 求和</li>
<li><code>min</code> 最小值</li>
<li><code>max</code> 最大值</li>
<li><code>avg</code> 平均值</li>
<li><code>group</code> 分组</li>
<li><code>stddev</code> 标准差</li>
<li><code>stdvar</code> 标准方差</li>
<li><code>count</code> 计数</li>
<li><code>count_values</code> 对样本值计数</li>
<li><code>bottomk</code> 样本值最小的 k 个元素</li>
<li><code>topk</code> 样本值最大的 k 个元素</li>
<li><code>quantile</code> 分位数</li>
</ul>
<p>可以通过 <code>without</code>, <code>by</code> 从句来移除或保留不同的标签, 从句可以用在表达式之前或之后 <span class="math display">\[
\begin{array}{l}
\hline
\rlap{
\large\textsf{示例: 查询请求的不同响应码的请求数求和的时序}
} \hphantom{---------------------------------------------------} \\
\texttt{PromQL: sum(prometheus_http_requests_total) by(job, code)} \\
\hline
\begin{split}
&amp;\texttt{\{code=&quot;400&quot;, job=&quot;prometheus&quot;\}} &amp;\qquad &amp; 17 \\
&amp;\texttt{\{code=&quot;422&quot;, job=&quot;prometheus&quot;\}} &amp;\qquad &amp; 11 \\
&amp;\texttt{\{code=&quot;200&quot;, job=&quot;prometheus&quot;\}} &amp;\qquad &amp; 13344 \\
&amp;\texttt{\{code=&quot;302&quot;, job=&quot;prometheus&quot;\}} &amp;\qquad &amp; 5
\end{split} \\
\hline
\end{array}
\]</span></p>
<p><span class="math display">\[
\begin{array}{l}
\hline
\rlap{
\large\textsf{示例: 查询请求的响应码的个数的时序}
} \hphantom{---------------------------------------------------} \\
\texttt{PromQL: count(group(prometheus_http_requests_total) by(job, code)) by(job)} \\
\hline
\begin{split}
\texttt{\{job=&quot;prometheus&quot;\}} &amp;\qquad &amp; 4
\end{split} \\
\hline
\end{array}
\]</span></p>
<h3 id="内置函数">内置函数</h3>
<p>PromQL 提供了大量的内置函数, 以对向量进行丰富的处理, 详见 <a href="https://prometheus.io/docs/prometheus/latest/querying/functions/">functions</a></p>
<p>内置函数按功能的相关性可分类:</p>
<ol type="1">
<li><p>动态标签</p>
<ul>
<li><code>label_replace</code> 使用正则表达式为时间序列添加额外的标签</li>
<li><code>label_join</code> 将现有标签以连接符拼接写入新的标签</li>
</ul></li>
<li><p>数学运算</p>
<ul>
<li><code>abs</code> 计算样本值的绝对值</li>
<li><code>exp</code> 计算样本值的自然指数</li>
<li><code>ln</code> 计算样本值的自然对数</li>
<li><code>log2</code> <code>log10</code> 计算样本值以2/10为底的对数</li>
<li><code>sqrt</code> 计算样本值的平方根</li>
<li><code>ceil</code> <code>floor</code> 计算样本值四舍五入向上/下取整</li>
<li><code>round</code> 计算样本值四舍五入向给定数值的整数倍取整</li>
<li><code>clamp_max</code> <code>clamp_min</code> 样本值设置最大/小限</li>
</ul></li>
<li><p>类型转换</p>
<ul>
<li><code>vector</code> 标量转瞬时向量</li>
<li><code>scalar</code> 瞬时向量转标量</li>
</ul></li>
<li><p>时间日期</p>
<ul>
<li><code>time</code> 返回时间戳</li>
<li><code>minute</code> <code>hour</code> <code>month</code> <code>year</code> 返回时间的分/时/月/年</li>
<li><code>day_of_month</code> <code>day_of_week</code> 返回给定时间在月/周中的序号</li>
<li><code>days_in_month</code> 返回给定月的天数</li>
<li><code>timestamp</code> 返回时序的时间戳</li>
</ul></li>
<li><p>时间聚合</p>
<ul>
<li><code>avg_over_time</code> 计算区间向量中每个时序的平均值</li>
<li><code>min_over_time</code> <code>max_over_time</code> 计算区间向量中每个时序的最小/大值</li>
<li><code>sum_over_time</code> 计算区间向量中每个时序的求和</li>
<li><code>count_over_time</code> 计算区间向量中每个时序的个数</li>
<li><code>quantile_over_time</code> 计算区间向量中每个时序的分位数</li>
<li><code>stddev_over_time</code> <code>stdvar_over_time</code> 计算区间向量中每个时序的标准差/方差</li>
</ul></li>
<li><p>Counter</p>
<ul>
<li><code>rate</code> <code>irate</code> 计算区间向量中每个时序的平均增长速率</li>
<li><code>increase</code> 计算区间向量中每个时序的首尾样本值的增长量</li>
<li><code>resets</code> 返回区间向量中每个时序的计数器重置次数</li>
</ul></li>
<li><p>Gauge</p>
<ul>
<li><code>predict_linear</code> 基于简单线性回归预测给定时间后的样本值</li>
<li><code>deriv</code> 基于简单的线性回归计算区间向量中每个时序的导数</li>
<li><code>delta</code> 计算区间向量中每个时序的首尾样本值的差值</li>
<li><code>idelta</code> 计算区间向量中每个时序的最新两个样本值的差值</li>
<li><code>holt_winters</code> 基于双指数平滑算法生成时序的平滑值</li>
<li><code>changes</code> 计算区间向量中每个时序的样本值变化的次数</li>
</ul></li>
<li><p>Histogram</p>
<ul>
<li><code>histogram_quantile</code> 计算直方图的分位数</li>
</ul></li>
<li><p>其它</p>
<ul>
<li><code>absent</code> 取反</li>
<li><code>sort</code> <code>sort_desc</code> 排序</li>
</ul></li>
</ol>
<p><span class="math display">\[
\begin{array}{l}
\hline
\rlap{
\large\textsf{示例: 查询}\normalsize\texttt{cpu}\large\textsf{的使用率的时序} \normalsize\texttt{(12%)}
} \hphantom{---------------------------------------------------} \\
\texttt{PromQL: ceil((1 - avg(rate(node_cpu_seconds_total{mode=&quot;idle&quot;}[10m])) without(cpu, mode)) * 100)} \\
\hline
\begin{split}
\texttt{\{job=&quot;node&quot;\}} &amp;\qquad &amp; 12
\end{split} \\
\hline
\end{array}
\]</span></p>
<p><span class="math display">\[
\begin{array}{l}
\hline
\rlap{
\large\textsf{示例: 预测在}\normalsize\texttt{1}\large\textsf{小时后磁盘目录}\normalsize\texttt{/}\large\textsf{的容量的时序} \normalsize\texttt{(187GB)}
} \hphantom{---------------------------------------------------} \\
\texttt{PromQL: floor(predict_linear(node_filesystem_avail_bytes{mountpoint=&quot;/&quot;}[30m], 1*60*60) /1024/1024/1024)} \\
\hline
\begin{split}
\texttt{\{fstype=&quot;ext4&quot;, job=&quot;node&quot;, mountpoint=&quot;/&quot;\}} &amp;\qquad &amp; 187
\end{split} \\
\hline
\end{array}
\]</span></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>Prometheus API</title>
    <url>/2021/07/01/prometheus-003/</url>
    <content><![CDATA[<h1 id="api">API</h1>
<p>Prometheus 控制台的对象信息查询和表达式查询, 是通过服务端提供的基于 http 协议的 api 接口实现的, 当前稳定的接口可以在服务端的 <code>/api/v1/</code> 路由端点下访问, 详见 <a href="https://prometheus.io/docs/prometheus/latest/querying/api/">http-api</a></p>
<p>接口响应格式基于 Json 形式, 每个成功的请求都会返回一个 <code>2xx</code> 的状态码, 可能返回的其它状态码如下:</p>
<ul>
<li><code>400</code> 参数缺少或不正确时</li>
<li><code>422</code> 表达式不能被执行时</li>
<li><code>503</code> 服务超时或中止时</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 响应体样例</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;status&quot;</span>: <span class="string">&quot;success&quot;</span>|<span class="string">&quot;error&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: &lt;data&gt;,</span><br><span class="line">    <span class="comment">// 当status=error时返回错误信息</span></span><br><span class="line">    <span class="attr">&quot;errorType&quot;</span>: <span class="string">&quot;&lt;string&gt;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;error&quot;</span>: <span class="string">&quot;&lt;string&gt;&quot;</span>,</span><br><span class="line">    <span class="comment">// 如果存在不限制请求执行的错误时, 可能返回警告数组</span></span><br><span class="line">    <span class="attr">&quot;warnings&quot;</span>: [<span class="string">&quot;&lt;string&gt;&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="表达式">表达式</h2>
<p>表达式查询分为瞬时和区间 2 个接口, 详见 <a href="https://prometheus.io/docs/prometheus/latest/querying/api/#expression-queries">expression-queries</a></p>
<ol type="1">
<li><p>瞬时查询接口, 用于在单个时间点计算表达式的结果</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">GET/POST /api/v1/query</span><br><span class="line"><span class="comment"># 入参</span></span><br><span class="line"><span class="attr">query</span>   = &lt;string&gt;                  <span class="comment"># 查询的表达式</span></span><br><span class="line"><span class="attr">time</span>    = &lt;rfc3999|unix_timestamp&gt;  <span class="comment"># 可选, 查询的时间戳</span></span><br><span class="line"><span class="attr">timeout</span> = &lt;duration&gt;                <span class="comment"># 可选, 超时的时间</span></span><br><span class="line"><span class="comment"># 出参</span></span><br><span class="line"><span class="attr">resultType</span> = <span class="string">&quot;matrix&quot;</span>|<span class="string">&quot;vector&quot;</span>|<span class="string">&quot;scalar&quot;</span>|<span class="string">&quot;string&quot;</span></span><br><span class="line"><span class="attr">result</span>     = &lt;value&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>区间查询接口, 用于在一段时间内计算表达式的结果</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">GET/POST /api/v1/query_range</span><br><span class="line"><span class="comment"># 入参</span></span><br><span class="line"><span class="attr">query</span>   = &lt;string&gt;                  <span class="comment"># 查询的表达式</span></span><br><span class="line"><span class="attr">start</span>   = &lt;rfc3999|unix_timestamp&gt;  <span class="comment"># 起始时间戳</span></span><br><span class="line"><span class="attr">end</span>     = &lt;rfc3999|unix_timestamp&gt;  <span class="comment"># 结束时间戳</span></span><br><span class="line"><span class="attr">step</span>    = &lt;duration|float&gt;          <span class="comment"># 查询的步宽</span></span><br><span class="line"><span class="attr">timeout</span> = &lt;duration&gt;                <span class="comment"># 可选, 超时的时间</span></span><br><span class="line"><span class="comment"># 出参</span></span><br><span class="line"><span class="attr">resultType</span> = <span class="string">&quot;matrix&quot;</span></span><br><span class="line"><span class="attr">result</span>     = &lt;value&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>当表达式查询成功时, 对应 PromQL 计算结果的 4 种类型, 响应体中 <code>data</code> 字段的返回值如下:</p>
<ul>
<li><p>区间向量(range vectors)</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;resultType&quot;</span>: <span class="string">&quot;matrix&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;result&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;metric&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;&lt;label_name&gt;&quot;</span>: <span class="string">&quot;&lt;label_value&gt;&quot;</span>, ...</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;values&quot;</span>: [</span><br><span class="line">                [ [&lt;unix_time&gt;, <span class="string">&quot;&lt;sample_value&gt;&quot;</span>], ... ]</span><br><span class="line">            ]</span><br><span class="line">        &#125;, ...</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>瞬时向量(instant vectors)</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;resultType&quot;</span>: <span class="string">&quot;vector&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;result&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;metric&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;&lt;label_name&gt;&quot;</span>: <span class="string">&quot;&lt;label_value&gt;&quot;</span>, ...</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;values&quot;</span>: [</span><br><span class="line">                &lt;unix_time&gt;, <span class="string">&quot;&lt;sample_value&gt;&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;, ...</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>标量(scalars)</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;resultType&quot;</span>: <span class="string">&quot;scalar&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;result&quot;</span>: [ &lt;unix_time&gt;, <span class="string">&quot;&lt;scalar_value&gt;&quot;</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>字符串(strings)</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;resultType&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;result&quot;</span>: [ &lt;unix_time&gt;, <span class="string">&quot;&lt;string_value&gt;&quot;</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="指标">指标</h2>
<p>指标元数据查询接口, 用于查询指标的类型和描述信息, 详见 <a href="https://prometheus.io/docs/prometheus/latest/querying/api/#querying-metric-metadata">querying-metric-metadata</a></p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">GET /api/v1/metadata</span><br><span class="line"><span class="comment"># 入参</span></span><br><span class="line"><span class="attr">metric</span> = &lt;string&gt;  <span class="comment"># 指定指标的名称</span></span><br><span class="line"><span class="attr">limit</span>  = &lt;number&gt;  <span class="comment"># 返回指标列表的最大数量</span></span><br></pre></td></tr></table></figure>
<p>元数据查询有 3 个接口, 用于查询指标, 标签和标签值, 详见 <a href="https://prometheus.io/docs/prometheus/latest/querying/api/#querying-metadata">querying-metadata</a></p>
<ol type="1">
<li><p>查询指标, 用于查询指标的标签和标签值</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">GET/POST /api/v1/series</span><br><span class="line"><span class="comment"># 入参</span></span><br><span class="line">match<span class="section">[]</span> = &lt;series_selector&gt;  <span class="comment"># 标签选择器, 必须至少提供一个标签名称</span></span><br><span class="line"><span class="attr">start</span>   = &lt;rfc3999|unix_timestamp&gt;</span><br><span class="line"><span class="attr">end</span>     = &lt;rfc3999|unix_timestamp&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>查询标签</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">GET/POST /api/v1/labels</span><br><span class="line"><span class="comment"># 入参</span></span><br><span class="line">match<span class="section">[]</span> = &lt;series_selector&gt;</span><br><span class="line"><span class="attr">start</span>   = &lt;rfc3999|unix_timestamp&gt;</span><br><span class="line"><span class="attr">end</span>     = &lt;rfc3999|unix_timestamp&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>查询标签值</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">GET/POST /api/v1/label/&lt;label_name&gt;/values</span><br><span class="line"><span class="comment"># 入参</span></span><br><span class="line">match<span class="section">[]</span> = &lt;series_selector&gt;</span><br><span class="line"><span class="attr">start</span>   = &lt;rfc3999|unix_timestamp&gt;</span><br><span class="line"><span class="attr">end</span>     = &lt;rfc3999|unix_timestamp&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="目标">目标</h2>
<p>目标元数据查询接口, 用于获取目标和其指标的元数据, 详见 <a href="https://prometheus.io/docs/prometheus/latest/querying/api/#querying-target-metadata">querying-target-metadata</a></p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">GET /api/v1/targets/metadata</span><br><span class="line"><span class="comment"># 入参</span></span><br><span class="line"><span class="attr">metric</span>       = &lt;string&gt;           <span class="comment"># 指定指标的名称, 如果为空则返回目标下的所有指标</span></span><br><span class="line"><span class="attr">match_target</span> = &lt;label_selectors&gt;  <span class="comment"># 标签选择器, 提供标签和标签值</span></span><br><span class="line"><span class="attr">limit</span>        = &lt;number&gt;           <span class="comment"># 返回的目标列表的最大数量</span></span><br></pre></td></tr></table></figure>
<p>目标查询接口, 用于获取目标的配置信息和状态, 详见 <a href="https://prometheus.io/docs/prometheus/latest/querying/api/#targets">targets</a></p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">GET /api/v1/targets</span><br><span class="line"><span class="comment"># 入参</span></span><br><span class="line"><span class="attr">state</span> = <span class="string">&quot;any&quot;</span>|<span class="string">&quot;active&quot;</span>|<span class="string">&quot;dropped&quot;</span>  <span class="comment"># 指定目标的状态, 默认any返回全部结果</span></span><br></pre></td></tr></table></figure>
<h2 id="规则">规则</h2>
<p>规则查询接口, 用于获取当前加载的记录规则和告警规则, 详见 <a href="https://prometheus.io/docs/prometheus/latest/querying/api/#rules">rules</a></p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">GET /api/v1/rules</span><br><span class="line"><span class="comment"># 入参</span></span><br><span class="line"><span class="attr">type</span> = <span class="string">&quot;alert&quot;</span>|<span class="string">&quot;record&quot;</span>  <span class="comment"># 指定规则的类型, 默认为空不做过滤</span></span><br></pre></td></tr></table></figure>
<p>告警查询接口, 用于获取当前状态为活动的告警列表, 详见 <a href="https://prometheus.io/docs/prometheus/latest/querying/api/#alerts">alerts</a></p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">GET /api/v1/alerts</span><br></pre></td></tr></table></figure>
<p>告警管理器接口, 用于获取当前配置的告警管理器列表及其状态, 详见 <a href="https://prometheus.io/docs/prometheus/latest/querying/api/#alertmanagers">alertmanagers</a></p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">GET /api/v1/alertmanagers</span><br></pre></td></tr></table></figure>
<h2 id="状态">状态</h2>
<p>状态查询有 6 个接口, 用于获取当前 Prometheus 的配置, 详见 <a href="https://prometheus.io/docs/prometheus/latest/querying/api/#status">status</a></p>
<ol type="1">
<li><p>配置接口, 用于获取当前的配置信息</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">GET /api/v1/status/config</span><br></pre></td></tr></table></figure></li>
<li><p>标志接口, 用于获取 Prometheus 配置的标志值</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">GET /api/v1/status/flags</span><br></pre></td></tr></table></figure></li>
<li><p>运行时接口, 用于获取服务的各种运行时信息</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">GET /api/v1/status/runtimeinfo</span><br></pre></td></tr></table></figure></li>
<li><p>构建接口, 用于获取服务构建时的信息属性</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">GET /api/v1/status/buildinfo</span><br></pre></td></tr></table></figure></li>
<li><p>TSDB 统计接口, 用于获取 Prometheus TSDB 的各种基数统计信息</p>
<ul>
<li><code>headStats</code> 提供以下统计数据
<ul>
<li><code>numSeries</code> 时序的数量</li>
<li><code>chunkCount</code> 块的数量</li>
<li><code>minTime</code> 当前最小的时间戳</li>
<li><code>maxTime</code> 当前最大的时间戳</li>
</ul></li>
<li><code>seriesCountByMetricName</code> 提供基于指标名称的时序数量</li>
<li><code>labelValueCountByLabelName</code> 提供基于标签名称的标签值数量</li>
<li><code>memoryInBytesByLabelName</code> 提供基于标签名称的内存使用量(单位字节)</li>
<li><code>seriesCountByLabelPair</code> 提供基于标签键值对的时序数量</li>
</ul>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">GET /api/v1/status/tsdb</span><br></pre></td></tr></table></figure></li>
<li><p>WAL 重载统计接口, 用于获取预写入数据恢复的次数</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">GET /api/v1/status/walreplay</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="管理员">管理员</h2>
<p>管理员接口对运维和开发人员非常实用, 它给用户开放了时序数据库 TSDB 的操作权限, 详见 <a href="https://prometheus.io/docs/prometheus/latest/querying/api/#tsdb-admin-apis">tsdb-admin-apis</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 管理员接口默认不启用, 需要在启动服务时指定选项</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> prometheus --web.enable-admin-api</span></span><br></pre></td></tr></table></figure>
<p>管理员接口有 3 个可操作的端口</p>
<ol type="1">
<li><p>snapshot 快照接口将当前所有数据在 tsdb 目录下的 <code>snapshots/&lt;datetime&gt;-&lt;rand&gt;</code> 文件夹内创建快照, 并将文件夹作为响应中的一个字段值返回</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">POST/PUT /api/v1/admin/tsdb/snapshot</span><br><span class="line"><span class="comment"># 入参</span></span><br><span class="line"><span class="attr">skip_head</span> = &lt;bool&gt;  <span class="comment"># 可选, 是否跳过块中未压缩到磁盘的数据</span></span><br></pre></td></tr></table></figure></li>
<li><p>delete series 删除时序接口可以将指定的时序标记为删除, 并在下次 tsdb 执行定期清理操作时移除</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">POST/PUT /api/v1/admin/tsdb/delete_series</span><br><span class="line"><span class="comment"># 入参</span></span><br><span class="line">match<span class="section">[]</span> = &lt;series_selector&gt;         <span class="comment"># 标签选择器, 选择要删除的时序</span></span><br><span class="line"><span class="attr">start</span>   = &lt;rfc3999|unix_timestamp&gt;</span><br><span class="line"><span class="attr">end</span>     = &lt;rfc3999|unix_timestamp&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>clean tombstones 清理里程碑接口将从磁盘中移除标记为删除的数据</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">POST/PUT /api/v1/admin/tsdb/clean_tombstones</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="示例">示例</h2>
<h3 id="表达式-1">表达式</h3>
<h4 id="瞬时查询">瞬时查询</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 瞬时查询</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl --location --request GET <span class="string">&#x27;http://localhost:9090/api/v1/query?query=up&amp;time=2021-06-30T12:00:00.000Z8&amp;timeout&#x27;</span></span></span><br><span class="line">&#123;</span><br><span class="line">    &quot;status&quot;: &quot;success&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;resultType&quot;: &quot;vector&quot;,</span><br><span class="line">        &quot;result&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;metric&quot;: &#123;</span><br><span class="line">                    &quot;__name__&quot;: &quot;up&quot;,</span><br><span class="line">                    &quot;instance&quot;: &quot;172.17.0.1:9100&quot;,</span><br><span class="line">                    &quot;job&quot;: &quot;node&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;value&quot;: [</span><br><span class="line">                    1625054400,</span><br><span class="line">                    &quot;1&quot;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;metric&quot;: &#123;</span><br><span class="line">                    &quot;__name__&quot;: &quot;up&quot;,</span><br><span class="line">                    &quot;instance&quot;: &quot;localhost:9090&quot;,</span><br><span class="line">                    &quot;job&quot;: &quot;prometheus&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;value&quot;: [</span><br><span class="line">                    1625054400,</span><br><span class="line">                    &quot;1&quot;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="区间查询">区间查询</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 区间查询</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl --location --request GET <span class="string">&#x27;http://localhost:9090/api/v1/query_range?query=node_memory_MemFree_bytes&amp;start=2021-06-30T12:00:00.000Z&amp;end=2021-06-30T12:01:00.000Z&amp;step=15&amp;timeout&#x27;</span></span></span><br><span class="line">&#123;</span><br><span class="line">    &quot;status&quot;: &quot;success&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;resultType&quot;: &quot;matrix&quot;,</span><br><span class="line">        &quot;result&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;metric&quot;: &#123;</span><br><span class="line">                    &quot;__name__&quot;: &quot;node_memory_MemFree_bytes&quot;,</span><br><span class="line">                    &quot;instance&quot;: &quot;172.17.0.1:9100&quot;,</span><br><span class="line">                    &quot;job&quot;: &quot;node&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;values&quot;: [</span><br><span class="line">                    [</span><br><span class="line">                        1625054400,</span><br><span class="line">                        &quot;4337102848&quot;</span><br><span class="line">                    ],</span><br><span class="line">                    [</span><br><span class="line">                        1625054415,</span><br><span class="line">                        &quot;4337377280&quot;</span><br><span class="line">                    ],</span><br><span class="line">                    [</span><br><span class="line">                        1625054430,</span><br><span class="line">                        &quot;4337602560&quot;</span><br><span class="line">                    ],</span><br><span class="line">                    [</span><br><span class="line">                        1625054445,</span><br><span class="line">                        &quot;4336943104&quot;</span><br><span class="line">                    ],</span><br><span class="line">                    [</span><br><span class="line">                        1625054460,</span><br><span class="line">                        &quot;4336541696&quot;</span><br><span class="line">                    ]</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指标-1">指标</h3>
<h4 id="元数据查询">元数据查询</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 指标查询, 结果返回指标的名称和类型</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl --location --request GET <span class="string">&#x27;http://localhost:9090/api/v1/metadata?metric=prometheus_http_requests_total&amp;limit=&#x27;</span></span></span><br><span class="line">&#123;</span><br><span class="line">    &quot;status&quot;: &quot;success&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;prometheus_http_requests_total&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;type&quot;: &quot;counter&quot;,</span><br><span class="line">                &quot;help&quot;: &quot;Counter of HTTP requests.&quot;,</span><br><span class="line">                &quot;unit&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="指标查询">指标查询</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 指标查询, 结果返回指标的标签和标签值</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl --location -g --request GET <span class="string">&#x27;http://localhost:9090/api/v1/series?match[]=up&amp;start=2021-06-30T12:00:00.000Z&amp;end=2021-06-30T12:01:00.000Z&#x27;</span></span></span><br><span class="line">&#123;</span><br><span class="line">    &quot;status&quot;: &quot;success&quot;,</span><br><span class="line">    &quot;data&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;__name__&quot;: &quot;up&quot;,</span><br><span class="line">            &quot;instance&quot;: &quot;172.17.0.1:9100&quot;,</span><br><span class="line">            &quot;job&quot;: &quot;node&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;__name__&quot;: &quot;up&quot;,</span><br><span class="line">            &quot;instance&quot;: &quot;localhost:9090&quot;,</span><br><span class="line">            &quot;job&quot;: &quot;prometheus&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="标签查询">标签查询</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 标签查询</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl --location -g --request GET <span class="string">&#x27;http://localhost:9090/api/v1/labels?match[]=up&amp;start&amp;end&#x27;</span></span></span><br><span class="line">&#123;</span><br><span class="line">    &quot;status&quot;: &quot;success&quot;,</span><br><span class="line">    &quot;data&quot;: [</span><br><span class="line">        &quot;__name__&quot;,</span><br><span class="line">        &quot;instance&quot;,</span><br><span class="line">        &quot;job&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="标签值查询">标签值查询</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 标签值查询</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl --location --request GET <span class="string">&#x27;http://localhost:9090/api/v1/label/job/values&#x27;</span></span></span><br><span class="line">&#123;</span><br><span class="line">    &quot;status&quot;: &quot;success&quot;,</span><br><span class="line">    &quot;data&quot;: [</span><br><span class="line">        &quot;prometheus&quot;,</span><br><span class="line">        &quot;node&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="目标-1">目标</h3>
<h4 id="元数据查询-1">元数据查询</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 目标查询, 结果返回目标和其指标的元数据</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl --location -g --request GET <span class="string">&#x27;http://localhost:9090/api/v1/targets/metadata?metric=go_goroutines&amp;match_target=&#123;job=%22prometheus%22&#125;&amp;limit=&#x27;</span></span></span><br><span class="line">&#123;</span><br><span class="line">    &quot;status&quot;: &quot;success&quot;,</span><br><span class="line">    &quot;data&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;target&quot;: &#123;</span><br><span class="line">                &quot;instance&quot;: &quot;localhost:9090&quot;,</span><br><span class="line">                &quot;job&quot;: &quot;prometheus&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;type&quot;: &quot;gauge&quot;,</span><br><span class="line">            &quot;help&quot;: &quot;Number of goroutines that currently exist.&quot;,</span><br><span class="line">            &quot;unit&quot;: &quot;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="目标查询">目标查询</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 目标查询, 结果按状态划分, 返回目标的配置信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl --location --request GET <span class="string">&#x27;http://localhost:9090/api/v1/targets&#x27;</span></span></span><br><span class="line">&#123;</span><br><span class="line">    &quot;status&quot;: &quot;success&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;activeTargets&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;discoveredLabels&quot;: &#123;</span><br><span class="line">                    &quot;__address__&quot;: &quot;localhost:9090&quot;,</span><br><span class="line">                    &quot;__metrics_path__&quot;: &quot;/metrics&quot;,</span><br><span class="line">                    &quot;__scheme__&quot;: &quot;http&quot;,</span><br><span class="line">                    &quot;job&quot;: &quot;prometheus&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;labels&quot;: &#123;</span><br><span class="line">                    &quot;instance&quot;: &quot;localhost:9090&quot;,</span><br><span class="line">                    &quot;job&quot;: &quot;prometheus&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;scrapePool&quot;: &quot;prometheus&quot;,</span><br><span class="line">                &quot;scrapeUrl&quot;: &quot;http://localhost:9090/metrics&quot;,</span><br><span class="line">                &quot;globalUrl&quot;: &quot;http://6f464fc27554:9090/metrics&quot;,</span><br><span class="line">                &quot;lastError&quot;: &quot;&quot;,</span><br><span class="line">                &quot;lastScrape&quot;: &quot;2021-06-30T17:13:44.334177173Z&quot;,</span><br><span class="line">                &quot;lastScrapeDuration&quot;: 0.011411324,</span><br><span class="line">                &quot;health&quot;: &quot;up&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;discoveredLabels&quot;: &#123;</span><br><span class="line">                    &quot;__address__&quot;: &quot;172.17.0.1:9100&quot;,</span><br><span class="line">                    &quot;__metrics_path__&quot;: &quot;/metrics&quot;,</span><br><span class="line">                    &quot;__scheme__&quot;: &quot;http&quot;,</span><br><span class="line">                    &quot;job&quot;: &quot;node&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;labels&quot;: &#123;</span><br><span class="line">                    &quot;instance&quot;: &quot;172.17.0.1:9100&quot;,</span><br><span class="line">                    &quot;job&quot;: &quot;node&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;scrapePool&quot;: &quot;node&quot;,</span><br><span class="line">                &quot;scrapeUrl&quot;: &quot;http://172.17.0.1:9100/metrics&quot;,</span><br><span class="line">                &quot;globalUrl&quot;: &quot;http://172.17.0.1:9100/metrics&quot;,</span><br><span class="line">                &quot;lastError&quot;: &quot;&quot;,</span><br><span class="line">                &quot;lastScrape&quot;: &quot;2021-06-30T17:13:51.450626205Z&quot;,</span><br><span class="line">                &quot;lastScrapeDuration&quot;: 0.102887838,</span><br><span class="line">                &quot;health&quot;: &quot;up&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;droppedTargets&quot;: []</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="规则-1">规则</h3>
<h4 id="规则查询">规则查询</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 规则查询</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl --location --request GET <span class="string">&#x27;http://localhost:9090/api/v1/rules?type=record&#x27;</span></span></span><br><span class="line">&#123;</span><br><span class="line">    &quot;status&quot;: &quot;success&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;groups&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;instance_alerts&quot;,</span><br><span class="line">                &quot;file&quot;: &quot;/etc/prometheus/node.rules.yml&quot;,</span><br><span class="line">                &quot;rules&quot;: [],</span><br><span class="line">                &quot;interval&quot;: 15,</span><br><span class="line">                &quot;evaluationTime&quot;: 0.000715755,</span><br><span class="line">                &quot;lastEvaluation&quot;: &quot;2021-06-30T18:50:48.167936761Z&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;node_rules&quot;,</span><br><span class="line">                &quot;file&quot;: &quot;/etc/prometheus/node.rules.yml&quot;,</span><br><span class="line">                &quot;rules&quot;: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;name&quot;: &quot;instance_mode:node_cpu_seconds_total:rate5m&quot;,</span><br><span class="line">                        &quot;query&quot;: &quot;sum without(cpu)(rate(node_cpu_seconds_total&#123;job=\&quot;node\&quot;&#125;[5m]))&quot;,</span><br><span class="line">                        &quot;health&quot;: &quot;ok&quot;,</span><br><span class="line">                        &quot;evaluationTime&quot;: 0.003344801,</span><br><span class="line">                        &quot;lastEvaluation&quot;: &quot;2021-06-30T18:50:40.652989552Z&quot;,</span><br><span class="line">                        &quot;type&quot;: &quot;recording&quot;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;name&quot;: &quot;mode:node_cpu_seconds_total:rate5m&quot;,</span><br><span class="line">                        &quot;query&quot;: &quot;sum without(instance) (instance_mode:node_cpu_seconds_total:rate5m)&quot;,</span><br><span class="line">                        &quot;health&quot;: &quot;ok&quot;,</span><br><span class="line">                        &quot;evaluationTime&quot;: 0.000686561,</span><br><span class="line">                        &quot;lastEvaluation&quot;: &quot;2021-06-30T18:50:40.656349439Z&quot;,</span><br><span class="line">                        &quot;type&quot;: &quot;recording&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                &quot;interval&quot;: 15,</span><br><span class="line">                &quot;evaluationTime&quot;: 0.004074525,</span><br><span class="line">                &quot;lastEvaluation&quot;: &quot;2021-06-30T18:50:40.652975653Z&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="告警查询">告警查询</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 告警查询</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl --location --request GET <span class="string">&#x27;http://localhost:9090/api/v1/alerts&#x27;</span></span></span><br><span class="line">&#123;</span><br><span class="line">    &quot;status&quot;: &quot;success&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;alerts&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;labels&quot;: &#123;</span><br><span class="line">                    &quot;alertname&quot;: &quot;instance:down&quot;,</span><br><span class="line">                    &quot;instance&quot;: &quot;172.17.0.1:8080&quot;,</span><br><span class="line">                    &quot;job&quot;: &quot;jenkins&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;annotations&quot;: &#123;</span><br><span class="line">                    &quot;description&quot;: &quot;172.17.0.1:8080 of job jenkins has been down for more than 5 minutes.&quot;,</span><br><span class="line">                    &quot;summary&quot;: &quot;Instance 172.17.0.1:8080 down&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;state&quot;: &quot;pending&quot;,</span><br><span class="line">                &quot;activeAt&quot;: &quot;2021-06-30T18:41:33.165603645Z&quot;,</span><br><span class="line">                &quot;value&quot;: &quot;0e+00&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="状态-1">状态</h3>
<h4 id="配置查询">配置查询</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 配置查询</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl --location --request GET <span class="string">&#x27;http://localhost:9090/api/v1/status/config&#x27;</span></span></span><br><span class="line">&#123;</span><br><span class="line">    &quot;status&quot;: &quot;success&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;yaml&quot;: &quot;global:\n  scrape_interval: 15s\n  scrape_timeout: 10s\n  evaluation_interval: 15s\nalerting:\n  alertmanagers:\n  - follow_redirects: true\n    scheme: http\n    timeout: 10s\n    api_version: v2\n    static_configs:\n    - targets: []\nrule_files:\n- /etc/prometheus/node.rules.yml\nscrape_configs:\n- job_name: prometheus\n  honor_timestamps: true\n  scrape_interval: 15s\n  scrape_timeout: 10s\n  metrics_path: /metrics\n  scheme: http\n  follow_redirects: true\n  static_configs:\n  - targets:\n    - localhost:9090\n- job_name: server2\n  honor_timestamps: true\n  scrape_interval: 15s\n  scrape_timeout: 10s\n  metrics_path: /metrics\n  scheme: http\n  follow_redirects: true\n  static_configs:\n  - targets:\n    - 172.17.0.1:9100\n- job_name: jenkins\n  honor_timestamps: true\n  scrape_interval: 15s\n  scrape_timeout: 10s\n  metrics_path: prometheus\n  scheme: http\n  basic_auth:\n    username: admin\n    password: &lt;secret&gt;\n  follow_redirects: true\n  static_configs:\n  - targets:\n    - 172.17.0.1:8080\n&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="标志查询">标志查询</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 标志查询</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl --location --request GET <span class="string">&#x27;http://localhost:9090/api/v1/status/flags&#x27;</span></span></span><br><span class="line">&#123;</span><br><span class="line">    &quot;status&quot;: &quot;success&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;alertmanager.notification-queue-capacity&quot;: &quot;10000&quot;,</span><br><span class="line">        &quot;alertmanager.timeout&quot;: &quot;&quot;,</span><br><span class="line">        &quot;config.file&quot;: &quot;/etc/prometheus/prometheus.yml&quot;,</span><br><span class="line">        &quot;enable-feature&quot;: &quot;&quot;,</span><br><span class="line">        &quot;log.format&quot;: &quot;logfmt&quot;,</span><br><span class="line">        &quot;log.level&quot;: &quot;info&quot;,</span><br><span class="line">        &quot;query.lookback-delta&quot;: &quot;5m&quot;,</span><br><span class="line">        &quot;query.max-concurrency&quot;: &quot;20&quot;,</span><br><span class="line">        &quot;query.max-samples&quot;: &quot;50000000&quot;,</span><br><span class="line">        &quot;query.timeout&quot;: &quot;2m&quot;,</span><br><span class="line">        &quot;rules.alert.for-grace-period&quot;: &quot;10m&quot;,</span><br><span class="line">        &quot;rules.alert.for-outage-tolerance&quot;: &quot;1h&quot;,</span><br><span class="line">        &quot;rules.alert.resend-delay&quot;: &quot;1m&quot;,</span><br><span class="line">        &quot;scrape.adjust-timestamps&quot;: &quot;true&quot;,</span><br><span class="line">        &quot;storage.exemplars.exemplars-limit&quot;: &quot;0&quot;,</span><br><span class="line">        &quot;storage.remote.flush-deadline&quot;: &quot;1m&quot;,</span><br><span class="line">        &quot;storage.remote.read-concurrent-limit&quot;: &quot;10&quot;,</span><br><span class="line">        &quot;storage.remote.read-max-bytes-in-frame&quot;: &quot;1048576&quot;,</span><br><span class="line">        &quot;storage.remote.read-sample-limit&quot;: &quot;50000000&quot;,</span><br><span class="line">        &quot;storage.tsdb.allow-overlapping-blocks&quot;: &quot;false&quot;,</span><br><span class="line">        &quot;storage.tsdb.max-block-duration&quot;: &quot;1d12h&quot;,</span><br><span class="line">        &quot;storage.tsdb.min-block-duration&quot;: &quot;2h&quot;,</span><br><span class="line">        &quot;storage.tsdb.no-lockfile&quot;: &quot;false&quot;,</span><br><span class="line">        &quot;storage.tsdb.path&quot;: &quot;/prometheus&quot;,</span><br><span class="line">        &quot;storage.tsdb.retention&quot;: &quot;0s&quot;,</span><br><span class="line">        &quot;storage.tsdb.retention.size&quot;: &quot;0B&quot;,</span><br><span class="line">        &quot;storage.tsdb.retention.time&quot;: &quot;0s&quot;,</span><br><span class="line">        &quot;storage.tsdb.wal-compression&quot;: &quot;true&quot;,</span><br><span class="line">        &quot;storage.tsdb.wal-segment-size&quot;: &quot;0B&quot;,</span><br><span class="line">        &quot;web.config.file&quot;: &quot;&quot;,</span><br><span class="line">        &quot;web.console.libraries&quot;: &quot;/usr/share/prometheus/console_libraries&quot;,</span><br><span class="line">        &quot;web.console.templates&quot;: &quot;/usr/share/prometheus/consoles&quot;,</span><br><span class="line">        &quot;web.cors.origin&quot;: &quot;.*&quot;,</span><br><span class="line">        &quot;web.enable-admin-api&quot;: &quot;false&quot;,</span><br><span class="line">        &quot;web.enable-lifecycle&quot;: &quot;false&quot;,</span><br><span class="line">        &quot;web.external-url&quot;: &quot;&quot;,</span><br><span class="line">        &quot;web.listen-address&quot;: &quot;0.0.0.0:9090&quot;,</span><br><span class="line">        &quot;web.max-connections&quot;: &quot;512&quot;,</span><br><span class="line">        &quot;web.page-title&quot;: &quot;Prometheus Time Series Collection and Processing Server&quot;,</span><br><span class="line">        &quot;web.read-timeout&quot;: &quot;5m&quot;,</span><br><span class="line">        &quot;web.route-prefix&quot;: &quot;/&quot;,</span><br><span class="line">        &quot;web.user-assets&quot;: &quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="运行时查询">运行时查询</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 运行时查询</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl --location --request GET <span class="string">&#x27;http://localhost:9090/api/v1/status/runtimeinfo&#x27;</span></span></span><br><span class="line">&#123;</span><br><span class="line">    &quot;status&quot;: &quot;success&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;startTime&quot;: &quot;2021-06-29T07:25:02.837486394Z&quot;,</span><br><span class="line">        &quot;CWD&quot;: &quot;/prometheus&quot;,</span><br><span class="line">        &quot;reloadConfigSuccess&quot;: true,</span><br><span class="line">        &quot;lastConfigTime&quot;: &quot;2021-06-29T07:25:03Z&quot;,</span><br><span class="line">        &quot;corruptionCount&quot;: 0,</span><br><span class="line">        &quot;goroutineCount&quot;: 35,</span><br><span class="line">        &quot;GOMAXPROCS&quot;: 12,</span><br><span class="line">        &quot;GOGC&quot;: &quot;&quot;,</span><br><span class="line">        &quot;GODEBUG&quot;: &quot;&quot;,</span><br><span class="line">        &quot;storageRetention&quot;: &quot;15d&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="构建查询">构建查询</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 构建查询</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl --location --request GET <span class="string">&#x27;http://localhost:9090/api/v1/status/buildinfo&#x27;</span></span></span><br><span class="line">&#123;</span><br><span class="line">    &quot;status&quot;: &quot;success&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;version&quot;: &quot;2.26.0&quot;,</span><br><span class="line">        &quot;revision&quot;: &quot;3cafc58827d1ebd1a67749f88be4218f0bab3d8d&quot;,</span><br><span class="line">        &quot;branch&quot;: &quot;HEAD&quot;,</span><br><span class="line">        &quot;buildUser&quot;: &quot;root@a67cafebe6d0&quot;,</span><br><span class="line">        &quot;buildDate&quot;: &quot;20210331-11:56:23&quot;,</span><br><span class="line">        &quot;goVersion&quot;: &quot;go1.16.2&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="统计查询">统计查询</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: TSDB统计查询</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl --location --request GET <span class="string">&#x27;http://localhost:9090/api/v1/status/tsdb&#x27;</span></span></span><br><span class="line">&#123;</span><br><span class="line">    &quot;status&quot;: &quot;success&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;headStats&quot;: &#123;</span><br><span class="line">            &quot;numSeries&quot;: 3243,</span><br><span class="line">            &quot;numLabelPairs&quot;: 1282,</span><br><span class="line">            &quot;chunkCount&quot;: 9209,</span><br><span class="line">            &quot;minTime&quot;: 1625076006450,</span><br><span class="line">            &quot;maxTime&quot;: 1625080240651</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;seriesCountByMetricName&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;prometheus_http_request_duration_seconds_bucket&quot;,</span><br><span class="line">                &quot;value&quot;: 210</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;prometheus_http_response_size_bytes_bucket&quot;,</span><br><span class="line">                &quot;value&quot;: 189</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;node_cpu_seconds_total&quot;,</span><br><span class="line">                &quot;value&quot;: 96</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;node_scrape_collector_success&quot;,</span><br><span class="line">                &quot;value&quot;: 40</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;node_scrape_collector_duration_seconds&quot;,</span><br><span class="line">                &quot;value&quot;: 40</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;node_cpu_guest_seconds_total&quot;,</span><br><span class="line">                &quot;value&quot;: 24</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;prometheus_http_requests_total&quot;,</span><br><span class="line">                &quot;value&quot;: 24</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;prometheus_http_request_duration_seconds_sum&quot;,</span><br><span class="line">                &quot;value&quot;: 21</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;prometheus_http_response_size_bytes_sum&quot;,</span><br><span class="line">                &quot;value&quot;: 21</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;prometheus_http_response_size_bytes_count&quot;,</span><br><span class="line">                &quot;value&quot;: 21</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;labelValueCountByLabelName&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;__name__&quot;,</span><br><span class="line">                &quot;value&quot;: 915</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;le&quot;,</span><br><span class="line">                &quot;value&quot;: 70</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;collector&quot;,</span><br><span class="line">                &quot;value&quot;: 40</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;handler&quot;,</span><br><span class="line">                &quot;value&quot;: 21</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;device&quot;,</span><br><span class="line">                &quot;value&quot;: 17</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;name&quot;,</span><br><span class="line">                &quot;value&quot;: 15</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;quantile&quot;,</span><br><span class="line">                &quot;value&quot;: 12</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;cpu&quot;,</span><br><span class="line">                &quot;value&quot;: 12</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;address&quot;,</span><br><span class="line">                &quot;value&quot;: 10</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;sensor&quot;,</span><br><span class="line">                &quot;value&quot;: 10</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;memoryInBytesByLabelName&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;__name__&quot;,</span><br><span class="line">                &quot;value&quot;: 31961</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;handler&quot;,</span><br><span class="line">                &quot;value&quot;: 342</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;le&quot;,</span><br><span class="line">                &quot;value&quot;: 323</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;collector&quot;,</span><br><span class="line">                &quot;value&quot;: 266</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;address&quot;,</span><br><span class="line">                &quot;value&quot;: 170</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;device&quot;,</span><br><span class="line">                &quot;value&quot;: 143</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;pool&quot;,</span><br><span class="line">                &quot;value&quot;: 93</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;version&quot;,</span><br><span class="line">                &quot;value&quot;: 91</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;rule_group&quot;,</span><br><span class="line">                &quot;value&quot;: 87</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;revision&quot;,</span><br><span class="line">                &quot;value&quot;: 80</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;seriesCountByLabelValuePair&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;job=jenkins&quot;,</span><br><span class="line">                &quot;value&quot;: 1263</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;instance=172.17.0.1:8080&quot;,</span><br><span class="line">                &quot;value&quot;: 1263</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;job=node&quot;,</span><br><span class="line">                &quot;value&quot;: 1085</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;instance=172.17.0.1:9100&quot;,</span><br><span class="line">                &quot;value&quot;: 1077</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;instance=localhost:9090&quot;,</span><br><span class="line">                &quot;value&quot;: 895</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;job=prometheus&quot;,</span><br><span class="line">                &quot;value&quot;: 895</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;__name__=prometheus_http_request_duration_seconds_bucket&quot;,</span><br><span class="line">                &quot;value&quot;: 210</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;__name__=prometheus_http_response_size_bytes_bucket&quot;,</span><br><span class="line">                &quot;value&quot;: 189</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;quantile=0.5&quot;,</span><br><span class="line">                &quot;value&quot;: 162</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;quantile=0.99&quot;,</span><br><span class="line">                &quot;value&quot;: 160</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重载查询">重载查询</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: WAL重载查询</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl --location --request GET <span class="string">&#x27;http://localhost:9090/api/v1/status/walreplay&#x27;</span></span></span><br><span class="line">&#123;</span><br><span class="line">    &quot;status&quot;: &quot;success&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;min&quot;: 0,</span><br><span class="line">        &quot;max&quot;: 2,</span><br><span class="line">        &quot;current&quot;: 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="管理员-1">管理员</h3>
<h4 id="快照接口">快照接口</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 快照接口</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl --location --request POST <span class="string">&#x27;http://localhost:9090/api/v1/admin/tsdb/snapshot?skip_head=true&#x27;</span></span></span><br><span class="line">&#123;</span><br><span class="line">    &quot;status&quot;: &quot;success&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;name&quot;: &quot;20210701T030533Z-3a65069574a85c2f&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除接口">删除接口</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 删除时序接口</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl --location -g --request POST <span class="string">&#x27;http://localhost:9090/api/v1/admin/tsdb/delete_series?match[]=jenkins_plugins_failed&amp;start&amp;end&#x27;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 响应返回204状态码</span></span><br></pre></td></tr></table></figure>
<h4 id="清理接口">清理接口</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 清理里程碑接口</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl --location --request POST <span class="string">&#x27;http://localhost:9090/api/v1/admin/tsdb/clean_tombstones&#x27;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 响应返回204状态码</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>Selenium API</title>
    <url>/2020/11/16/selenium%20002/</url>
    <content><![CDATA[<h1 id="webdriver-api">WebDriver API</h1>
<p>WebDriver 使用浏览器供应商提供的浏览器自动化 API 来控制浏览器并运行测试, 就像真实用户操作浏览器一样, 由于 WebDriver 不需要使用应用程序代码来编译其 API, 因此它不是侵入式的</p>
<p>WebDriver API 是用于操作 WebDriver 的命令集</p>
<h2 id="浏览器操作">浏览器操作</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 浏览器操作 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开页面</span></span><br><span class="line">    driver.get(<span class="string">&quot;http://news.anhuai.com/&quot;</span>);</span><br><span class="line">    <span class="comment">// 跳转页面</span></span><br><span class="line">    driver.navigate().to(<span class="string">&quot;http://news.anhuai.com/user/login&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后退操作</span></span><br><span class="line">    driver.navigate().back();</span><br><span class="line">    <span class="comment">// 前进操作</span></span><br><span class="line">    driver.navigate().forward();</span><br><span class="line">    <span class="comment">// 刷新操作</span></span><br><span class="line">    driver.navigate().refresh();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 窗口最大化</span></span><br><span class="line">    driver.manage().window().maximize();</span><br><span class="line">    <span class="comment">// 窗口高宽</span></span><br><span class="line">    driver.manage().window().setSize(<span class="keyword">new</span> Dimension(<span class="number">1000</span>, <span class="number">500</span>));</span><br><span class="line">    <span class="comment">// 窗口全屏</span></span><br><span class="line">    driver.manage().window().fullscreen();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取标题</span></span><br><span class="line">    String title = driver.getTitle();</span><br><span class="line">    <span class="comment">// 获取当前URL</span></span><br><span class="line">    String url = driver.getCurrentUrl();</span><br><span class="line">    <span class="comment">// 获取源码</span></span><br><span class="line">    String source = driver.getPageSource();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭当前窗口</span></span><br><span class="line">    driver.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="元素操作">元素操作</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 元素操作 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    driver.get(<span class="string">&quot;http://news.anhuai.com/user/login&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取元素</span></span><br><span class="line">    WebElement username = driver.findElement(By.id(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">    WebElement password = driver.findElement(By.id(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">    WebElement submit = driver.findElement(By.className(<span class="string">&quot;ant-btn&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取元素属性</span></span><br><span class="line">    String placeholder = username.getAttribute(<span class="string">&quot;placeholder&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isNotBlank(placeholder)) &#123;</span><br><span class="line">        <span class="comment">// 清空文本</span></span><br><span class="line">        username.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入文本</span></span><br><span class="line">    username.sendKeys(<span class="string">&quot;135xxxxxxxx&quot;</span>);</span><br><span class="line">    password.sendKeys(<span class="string">&quot;xxxxxxxx&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断元素是否可点击</span></span><br><span class="line">    <span class="keyword">if</span> (submit.isDisplayed()) &#123;</span><br><span class="line">        <span class="comment">// 点击元素</span></span><br><span class="line">        submit.click();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    driver.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="鼠标键盘">鼠标键盘</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 鼠标键盘 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    driver.get(<span class="string">&quot;http://news.anhuai.com/user/login&quot;</span>);</span><br><span class="line">    WebElement username = driver.findElement(By.id(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">    WebElement password = driver.findElement(By.id(<span class="string">&quot;password&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Actions类实现鼠标操作</span></span><br><span class="line">    Actions action = <span class="keyword">new</span> Actions(driver);</span><br><span class="line">    action.click(username) <span class="comment">// 单击</span></span><br><span class="line">        .doubleClick(username) <span class="comment">// 双击</span></span><br><span class="line">        .contextClick() <span class="comment">// 右击</span></span><br><span class="line">        .moveToElement(username) <span class="comment">// 移动到元素</span></span><br><span class="line">        .pause(<span class="number">3000</span>) <span class="comment">// 悬浮3秒</span></span><br><span class="line">        .clickAndHold() <span class="comment">// 单击并按住不放</span></span><br><span class="line">        .release() <span class="comment">// 释放按键</span></span><br><span class="line">        .dragAndDrop(username, password) <span class="comment">// 拖曳</span></span><br><span class="line">        .perform() <span class="comment">// 执行Actions链中存储的行为</span></span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Keys类实现键盘操作</span></span><br><span class="line">    username.sendKeys(<span class="string">&quot;135xxxxxxxxX&quot;</span> + Keys.BACK_SPACE); <span class="comment">// 退格键</span></span><br><span class="line">    username.sendKeys(Keys.CONTROL, <span class="string">&quot;a&quot;</span>); <span class="comment">// 全选CTRL+A</span></span><br><span class="line">    username.sendKeys(Keys.CONTROL, <span class="string">&quot;c&quot;</span>); <span class="comment">// 复制CTRL+C</span></span><br><span class="line">    password.sendKeys(Keys.CONTROL, <span class="string">&quot;v&quot;</span>); <span class="comment">// 粘贴CTRL+V</span></span><br><span class="line"></span><br><span class="line">    driver.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="超时处理">超时处理</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 超时处理 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    driver.get(<span class="string">&quot;http://news.anhuai.com/user/login&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 强制等待3秒</span></span><br><span class="line">    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 隐式等待</span></span><br><span class="line">    <span class="comment">// 设置页面加载的超时时间</span></span><br><span class="line">    driver.manage().timeouts().pageLoadTimeout(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">// 设置获取元素的超时时间</span></span><br><span class="line">    driver.manage().timeouts().implicitlyWait(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">// 设置异步脚本的超时时间</span></span><br><span class="line">    driver.manage().timeouts().setScriptTimeout(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 显式等待</span></span><br><span class="line">    <span class="comment">// 设置超时时间为3秒, 每500毫秒调用一次判断</span></span><br><span class="line">    WebDriverWait wait = <span class="keyword">new</span> WebDriverWait(driver, <span class="number">3L</span>, <span class="number">500L</span>);</span><br><span class="line">    <span class="comment">// 设置判断条件, 此处判断元素是否存在</span></span><br><span class="line">    wait.until(driver2 -&gt; driver2.findElement(By.id(<span class="string">&quot;username&quot;</span>)));</span><br><span class="line">    <span class="comment">// 获取元素</span></span><br><span class="line">    WebElement username = driver.findElement(By.id(<span class="string">&quot;username&quot;</span>));</span><br><span class="line"></span><br><span class="line">    driver.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="窗口处理">窗口处理</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 多窗口处理 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    driver.get(<span class="string">&quot;http://news.anhuai.com/&quot;</span>);</span><br><span class="line">    driver.get(<span class="string">&quot;http://news.anhuai.com/user/login&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前窗口的句柄</span></span><br><span class="line">    String handle = driver.getWindowHandle();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取所有窗口的句柄</span></span><br><span class="line">    Set&lt;String&gt; handles = driver.getWindowHandles();</span><br><span class="line">    handles.forEach(h -&gt; &#123;</span><br><span class="line">        <span class="comment">// 切换到指定窗口</span></span><br><span class="line">        driver.switchTo().window(h);</span><br><span class="line">        System.out.println(driver.getTitle());</span><br><span class="line">        driver.close();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: iframe窗口处理 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    driver.get(<span class="string">&quot;http://i.firefoxchina.cn/&quot;</span>);</span><br><span class="line">    WebElement words = driver.findElement(By.className(<span class="string">&quot;engine-link-words&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换到第一个iframe标签</span></span><br><span class="line">    driver.switchTo().frame(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 切换到指定iframe元素</span></span><br><span class="line">    driver.switchTo().frame(words);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出iframe返回当前页面</span></span><br><span class="line">    driver.switchTo().defaultContent();</span><br><span class="line">    </span><br><span class="line">    driver.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 弹窗处理 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 示例基于原生弹窗</span></span><br><span class="line">    <span class="comment">// Alert / Confirm / Prompt</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换到弹窗</span></span><br><span class="line">    Alert alert = driver.switchTo().alert();</span><br><span class="line">    <span class="comment">// 获取文本值</span></span><br><span class="line">    String text = driver.switchTo().alert().getText();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 弹窗确认</span></span><br><span class="line">    driver.switchTo().alert().accept();</span><br><span class="line">    <span class="comment">// 弹窗关闭</span></span><br><span class="line">    driver.switchTo().alert().dismiss();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入文本值(仅限Prompt)</span></span><br><span class="line">    driver.switchTo().alert().sendKeys(<span class="string">&quot;xxxxxxxx&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="上传文件">上传文件</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 原生上传 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 示例基于标准上传控件</span></span><br><span class="line">    <span class="comment">// input(type=file)</span></span><br><span class="line"></span><br><span class="line">    driver.get(<span class="string">&quot;https://image.baidu.com/&quot;</span>);</span><br><span class="line"></span><br><span class="line">    WebElement stfile = driver.findElement(By.id(<span class="string">&quot;stfile&quot;</span>));</span><br><span class="line">    stfile.sendKeys(<span class="string">&quot;./demo.jpg&quot;</span>); <span class="comment">// 此方式不会有选择文件的系统弹窗</span></span><br><span class="line"></span><br><span class="line">    driver.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: Robot上传 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 示例基于非标准上传控件</span></span><br><span class="line">    <span class="comment">// Robot通过键盘事件操作完成上传文件</span></span><br><span class="line"></span><br><span class="line">    Robot robot = <span class="keyword">new</span> Robot();</span><br><span class="line">    driver.get(<span class="string">&quot;https://image.baidu.com/&quot;</span>);</span><br><span class="line"></span><br><span class="line">    WebElement sttb = driver.findElement(By.id(<span class="string">&quot;sttb&quot;</span>));</span><br><span class="line">    sttb.click();</span><br><span class="line">    WebElement uploadImg = driver.findElement(By.id(<span class="string">&quot;uploadImg&quot;</span>));</span><br><span class="line">    uploadImg.click(); <span class="comment">// 点击上传按钮, 此时显示选择文件的系统弹窗</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制文件到剪贴板</span></span><br><span class="line">    StringSelection selection = <span class="keyword">new</span> StringSelection(<span class="string">&quot;./demo.jpg&quot;</span>);</span><br><span class="line">    Toolkit.getDefaultToolkit().getSystemClipboard().setContents(selection, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 点击CTRL+V, 等同于剪贴板的文件地址粘贴到系统弹窗的文件名文本框</span></span><br><span class="line">    robot.keyPress(KeyEvent.VK_CONTROL);</span><br><span class="line">    robot.keyPress(KeyEvent.VK_V);</span><br><span class="line">    robot.delay(<span class="number">100</span>);</span><br><span class="line">    robot.keyRelease(KeyEvent.VK_CONTROL);</span><br><span class="line">    robot.keyRelease(KeyEvent.VK_V);</span><br><span class="line">    robot.delay(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 点击ENTER, 等同于点击系统弹窗的打开按钮</span></span><br><span class="line">    robot.keyPress(KeyEvent.VK_ENTER);</span><br><span class="line">    robot.delay(<span class="number">100</span>);</span><br><span class="line">    robot.keyRelease(KeyEvent.VK_ENTER);</span><br><span class="line"></span><br><span class="line">    driver.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="cookie-操作">Cookie 操作</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: Cookie操作 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    driver.get(<span class="string">&quot;http://news.anhuai.com/&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取所有Cookie</span></span><br><span class="line">    Set&lt;Cookie&gt; cookies = driver.manage().getCookies();</span><br><span class="line">    <span class="comment">// 删除所有Cookie</span></span><br><span class="line">    driver.manage().deleteAllCookies();</span><br><span class="line"></span><br><span class="line">    Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">&quot;JSESSIONID&quot;</span>, <span class="comment">//</span></span><br><span class="line">                               <span class="string">&quot;CD3027F53873A99C1EDA845E5D009B68&quot;</span>, <span class="comment">//</span></span><br><span class="line">                               <span class="string">&quot;news.anhuai.com&quot;</span>, <span class="string">&quot;/&quot;</span>, <span class="comment">//</span></span><br><span class="line">                               DateUtils.addHours(<span class="keyword">new</span> Date(), <span class="number">2</span>), <span class="comment">//</span></span><br><span class="line">                               <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 新增Cookie</span></span><br><span class="line">    driver.manage().addCookie(cookie);</span><br><span class="line"></span><br><span class="line">    driver.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="javascript-调用">JavaScript 调用</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: JavaScript调用 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    driver.get(<span class="string">&quot;http://news.anhuai.com/&quot;</span>);</span><br><span class="line"></span><br><span class="line">    JavascriptExecutor js = (JavascriptExecutor)driver;</span><br><span class="line">    <span class="comment">// 执行JS脚本</span></span><br><span class="line">    js.executeScript(<span class="string">&quot;alert(&#x27;hello selenium!&#x27;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Alert alert = driver.switchTo().alert();</span><br><span class="line">    alert.dismiss();</span><br><span class="line"></span><br><span class="line">    driver.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="截图操作">截图操作</h2>
<p>在自动化测试过程中, 运行失败时通过截图可以很好的定位问题, 因此, 截图操作是自动化测试中的一个重要环节</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: TakesScreenshot实现截图 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 截取浏览器窗体中的内容, 不包括浏览器的菜单和桌面的任务栏区域</span></span><br><span class="line"></span><br><span class="line">    driver.get(<span class="string">&quot;http://news.anhuai.com/&quot;</span>);</span><br><span class="line"></span><br><span class="line">    File screen = ((TakesScreenshot)driver).getScreenshotAs(OutputType.FILE);</span><br><span class="line">    FileCopyUtils.copy(screen, <span class="keyword">new</span> File(<span class="string">&quot;./save/screenshot.jpg&quot;</span>));</span><br><span class="line"></span><br><span class="line">    driver.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: Robot实现截图 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 截取浏览器窗体中的内容, 以及浏览器的菜单和桌面的任务栏区域</span></span><br><span class="line"></span><br><span class="line">    driver.get(<span class="string">&quot;http://news.anhuai.com/&quot;</span>);</span><br><span class="line"></span><br><span class="line">    BufferedImage image = <span class="keyword">new</span> Robot().createScreenCapture(</span><br><span class="line">        <span class="keyword">new</span> Rectangle(Toolkit.getDefaultToolkit().getScreenSize()));</span><br><span class="line">    ImageIO.write(image, <span class="string">&quot;jpg&quot;</span>, <span class="keyword">new</span> File(<span class="string">&quot;./save/screenshot.jpg&quot;</span>));</span><br><span class="line"></span><br><span class="line">    driver.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 页面元素截图 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 通过指定元素及区域大小截图</span></span><br><span class="line"></span><br><span class="line">    driver.get(<span class="string">&quot;http://news.anhuai.com/&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取要捕捉的元素</span></span><br><span class="line">    WebElement head = driver.findElement(By.id(<span class="string">&quot;head&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 截图整个页面</span></span><br><span class="line">    File screen = ((TakesScreenshot)driver).getScreenshotAs(OutputType.FILE);</span><br><span class="line">    BufferedImage image = ImageIO.read(screen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元素的坐标和高宽截取图片</span></span><br><span class="line">    BufferedImage dest = image.getSubimage(</span><br><span class="line">        head.getLocation().x, head.getLocation().y, </span><br><span class="line">        head.getSize().width, head.getSize().height);</span><br><span class="line"></span><br><span class="line">    ImageIO.write(dest, <span class="string">&quot;jpg&quot;</span>,  <span class="keyword">new</span> File(<span class="string">&quot;./save/screenshot.jpg&quot;</span>));</span><br><span class="line"></span><br><span class="line">    driver.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="录屏操作">录屏操作</h2>
<p>有时未必能通过日志文件或测试报告中操作失败的截图来分析故障, 定位并复现问题, 对于这种情况, 如果可以捕获完整的执行视频, 将有助于定位导致操作失败的问题</p>
<p>示例使用 Monte 媒体库实现视频的录制</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置: pom.xml添加monte依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.stephenc.monte<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>monte-screen-recorder<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;monte.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 录屏操作 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BrowserTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 录制文件默认保存在用户Home目录</span></span><br><span class="line">    <span class="comment">// ~/Viedo/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ScreenRecorder recorder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeAll</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 显卡配置</span></span><br><span class="line">        GraphicsConfiguration config =</span><br><span class="line">            GraphicsEnvironment</span><br><span class="line">            .getLocalGraphicsEnvironment()</span><br><span class="line">            .getDefaultScreenDevice()</span><br><span class="line">            .getDefaultConfiguration();</span><br><span class="line"></span><br><span class="line">        recorder = <span class="keyword">new</span> ScreenRecorder(config, </span><br><span class="line">            <span class="comment">// 文件格式</span></span><br><span class="line">            <span class="keyword">new</span> Format(MediaTypeKey, MediaType.FILE, </span><br><span class="line">                MimeTypeKey, MIME_AVI), </span><br><span class="line">            <span class="comment">// 视频压缩配置</span></span><br><span class="line">            <span class="keyword">new</span> Format(MediaTypeKey, MediaType.VIDEO, </span><br><span class="line">                EncodingKey, VideoFormatKeys.ENCODING_AVI_TECHSMITH_SCREEN_CAPTURE, </span><br><span class="line">                CompressorNameKey, VideoFormatKeys.ENCODING_AVI_TECHSMITH_SCREEN_CAPTURE, </span><br><span class="line">                DepthKey, <span class="number">24</span>, </span><br><span class="line">                FrameRateKey, Rational.valueOf(<span class="number">15</span>), </span><br><span class="line">                QualityKey, <span class="number">1.0f</span>, </span><br><span class="line">                KeyFrameIntervalKey, <span class="number">15</span> * <span class="number">60</span>), </span><br><span class="line">            <span class="comment">// 鼠标颜色和刷新速率</span></span><br><span class="line">            <span class="keyword">new</span> Format(MediaTypeKey, MediaType.VIDEO, </span><br><span class="line">                EncodingKey, <span class="string">&quot;black&quot;</span>, </span><br><span class="line">                FrameRateKey, Rational.valueOf(<span class="number">30</span>)), </span><br><span class="line">            <span class="comment">// 音频压缩配置, null不会记录音频</span></span><br><span class="line">            <span class="keyword">null</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 开始录制</span></span><br><span class="line">        recorder.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterAll</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 停止录制</span></span><br><span class="line">        recorder.stop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        driver.get(<span class="string">&quot;http://news.anhuai.com/&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">        driver.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>Selenium3</tag>
      </tags>
  </entry>
  <entry>
    <title>Selenium 设计模式</title>
    <url>/2020/11/16/selenium%20003/</url>
    <content><![CDATA[<h1 id="设计模式">设计模式</h1>
<h2 id="bdd">BDD</h2>
<p><strong>BDD(Behaviour-Driven Development)</strong> 行为驱动开发是一种敏捷的软件开发技术, 使用自然语言编写用例的好处是能够让非技术人员 (客户和用户) 看懂测试用例, 可以最大程度的减少技术语言和领域语言的翻译成本</p>
<h3 id="cucumber">Cucumber</h3>
<p><strong>Cucumber</strong> 是一款支持行为驱动开发, 读取以纯文本形式编写的可执行规范, 验证该软件是否满足规范的内容, 并生成报告, 官网 <a href="https://cucumber.io/">Cucumber</a></p>
<h4 id="gherkin">Gherkin</h4>
<p>Cucumber 运行时会从纯文本语言编写的 <code>.feature</code> 文件中读取测试规格说明, 解析需要测试的场景 <code>scenario</code>, 每个场景由一系列步骤 <code>step</code> 组成, 为了使 Cucumber 理解特性文件, 这些文件必须遵循 Gherkin 的基本语法规则</p>
<p><a href="https://cucumber.io/docs/gherkin/reference/">Gherkin</a> 使用一组特殊关键字为可执行规范指定结构和含义, 为了让 Gherkin 能用多种语言书写, 关键字已经被翻译成多种语言, 为了提高可读性和流畅性, 有些语言可能对任何给定的关键字有多个翻译, 列表 <a href="https://cucumber.io/docs/gherkin/languages/">languages</a></p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例: login.feature</span></span><br><span class="line"><span class="keyword">Feature</span>: 登录测试</span><br><span class="line">  使用手机号码和密码登录并跳转团队首页</span><br><span class="line"></span><br><span class="line">  <span class="keyword">Scenario</span>:</span><br><span class="line">    <span class="keyword">Given</span> 访问登录页面</span><br><span class="line">    <span class="keyword">And</span> 输入手机号码 <span class="string">&quot;135xxxxxxxx&quot;</span></span><br><span class="line">    <span class="keyword">And</span> 输入密码 <span class="string">&quot;xxxxxxxx&quot;</span></span><br><span class="line">    <span class="keyword">When</span> 点击登录按钮</span><br><span class="line">    <span class="keyword">Then</span> 跳转团队首页</span><br></pre></td></tr></table></figure>
<p>可通过文件头添加 <code># language:</code> 确定要使用什么样的语言, 如果省略此属性将默认使用英语 <code>en</code></p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line"><span class="comment"># language: zh-CN</span></span><br></pre></td></tr></table></figure>
<h4 id="keyword">Keyword</h4>
<p>Cucumber 关键字查看 <a href="https://cucumber.io/docs/gherkin/reference/#keywords">keywords</a></p>
<p><strong>Feature</strong> 每个文件都以 <code>Feature</code> 关键字开头, 后跟特性的名称和描述, 描述可以跨越多行, 该关键字完全不影响测试行为, 但是会包含在生成的报告中</p>
<p><strong>Rule</strong> 表示一个被实现的业务规则, 用于将属于此业务规则的多个场景组合在一起</p>
<p><strong>Example / Scenario</strong> 具体测试场景, 它由步骤列表组成, <code>Scenario</code> 关键字后面也可以跟上名称和描述</p>
<p><strong>Step</strong> 在 <code>Scenario</code> 中定义的步骤列表, 一般使用 <code>Given</code>, <code>When</code>, <code>Then</code>, <code>But</code> 和 <code>And</code> 这些关键词, <code>Step</code> 实际上并不关心使用哪个关键字, 关键字的选择只是为了创建可读性更好的场景</p>
<p><strong>Given</strong> 执行用例的前置条件</p>
<p><strong>When</strong> 执行用例的交互方式</p>
<p><strong>Then</strong> 断言, 检查交互的结果是否符合预期</p>
<p><strong>And</strong> 同前一个步骤</p>
<p><strong>But</strong> 反前一个步骤</p>
<blockquote>
<p>Gherkin 支持使用星号 <code>*</code> 代替任何常规 <code>step</code> 关键字</p>
</blockquote>
<p><strong>Background</strong> 在所有场景中都会重复的步骤, 可以通过将这些步骤分组到 <code>Backgroud</code>, 背景放在第一个场景之前</p>
<p><strong>Scenario Outline / Scenario Template</strong> 可以使用不同的参数组合多次测试同一场景</p>
<h3 id="示例">示例</h3>
<p>示例基于 <strong>Cucumber</strong> 和 <strong>Junit5</strong> 测试环境</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置: pom.xml添加依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.cucumber<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cucumber-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;cucumber.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.cucumber<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cucumber-junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;cucumber.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>将文件 <code>login.feature</code> 拷贝到项目文件夹 <code>/src/test/resources/feature</code> 下, 编写实现类和测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: feature定义实现类 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Login</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> WebDriver driver;</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.setProperty(<span class="string">&quot;webdriver.edge.driver&quot;</span>, <span class="string">&quot;driver/msedgedriver.exe&quot;</span>);</span><br><span class="line">        driver = <span class="keyword">new</span> EdgeDriver();</span><br><span class="line">        driver.manage().window().maximize();</span><br><span class="line">        driver.manage().timeouts().pageLoadTimeout(<span class="number">10L</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        driver.quit();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Given(&quot;访问登录页面&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loginPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        driver.get(<span class="string">&quot;http://news.anhuai.com/user/login&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@And(&quot;输入手机号码 &#123;string&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inputPhone</span><span class="params">(String phone)</span> </span>&#123;</span><br><span class="line">        driver.findElement(By.id(<span class="string">&quot;username&quot;</span>)).sendKeys(phone);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@And(&quot;输入密码 &#123;string&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inputPassword</span><span class="params">(String pwd)</span> </span>&#123;</span><br><span class="line">        driver.findElement(By.id(<span class="string">&quot;password&quot;</span>)).sendKeys(pwd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@When(&quot;点击登录按钮&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        driver.findElement(By.className(<span class="string">&quot;ant-btn&quot;</span>)).click();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Then(&quot;跳转团队首页&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">success</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000L</span>);</span><br><span class="line">        String url = driver.getCurrentUrl();</span><br><span class="line">        Assertions.assertTrue(StringUtils.startsWith(url, <span class="string">&quot;http://news.anhuai.com/team/&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 测试类 */</span></span><br><span class="line"><span class="meta">@RunWith(Cucumber.class)</span></span><br><span class="line"><span class="meta">@CucumberOptions(</span></span><br><span class="line"><span class="meta">    // 指定feature文件夹的位置</span></span><br><span class="line"><span class="meta">    features = &#123;&quot;classpath:/feature&quot;&#125;,</span></span><br><span class="line"><span class="meta">    // 指定插件的配置</span></span><br><span class="line"><span class="meta">    plugin = &#123;&quot;pretty&quot;, &quot;html:target/cucumber.html&quot;, &quot;json:target/cucumber.json&quot;&#125;, </span></span><br><span class="line"><span class="meta">    // 指定实现类的包路径</span></span><br><span class="line"><span class="meta">    glue = &#123;&quot;com.anhuai.test.demo&quot;&#125; </span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CucumberTest</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<p>运行测试, 日志输出如下, 同时文件夹 <code>/target/</code> 下生成 <code>cucumber.html</code> 和 <code>cucumber.json</code> 的测试结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Scenario:                         # feature/login.feature:4</span><br><span class="line">  Given 访问登录页面              # com.anhuai.pattern2.feature.Login.loginPage()</span><br><span class="line">  And 输入手机号码 &quot;135xxxxxxxx&quot;  # com.anhuai.pattern2.feature.Login.inputPhone(java.lang.String)</span><br><span class="line">  And 输入密码 &quot;xxxxxxxx&quot;         # com.anhuai.pattern2.feature.Login.inputPassword(java.lang.String)</span><br><span class="line">  When 点击登录按钮               # com.anhuai.pattern2.feature.Login.submit()</span><br><span class="line">  Then 跳转团队首页               # com.anhuai.pattern2.feature.Login.success()</span><br></pre></td></tr></table></figure>
<h2 id="tdd">TDD</h2>
<p><strong>TDD(Test-Driven Development)</strong> 是敏捷开发中的一项核心实践和技术, 原理是在开发功能的代码前, 先编写单元测试用例代码, 测试代码确定需要编写的具体产品代码</p>
<p><strong>数据驱动</strong> 设计是自动化测试中非常重要的一个环节, 同时也是自动化测试中的主流设计模式之一, 主要包括使用 DataProvider, CSV, Excel, YAML 和 MySQL 等方法进行数据驱动测试</p>
<p>在实际设计测试用例的过程中, 经常会用等价类或边界值这样的方法, 针对一个功能用例测试数据进行测试, 比如一个输入框的正向数据, 逆向数据, 非法输入等, 即输入不同类型的数据进行测试</p>
<h3 id="示例-1">示例</h3>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例: login.feature</span></span><br><span class="line"><span class="keyword">Feature</span>: 登录测试</span><br><span class="line">  使用手机号码和密码登录并跳转团队首页</span><br><span class="line"></span><br><span class="line">  <span class="keyword">Scenario</span>:</span><br><span class="line">    <span class="keyword">Given</span> 访问登录页面</span><br><span class="line">    <span class="keyword">And</span> 输入手机号码 <span class="string">&quot;&lt;account&gt;&quot;</span></span><br><span class="line">    <span class="keyword">And</span> 输入密码 <span class="string">&quot;&lt;password&gt;&quot;</span></span><br><span class="line">    <span class="keyword">When</span> 点击登录按钮</span><br><span class="line">    <span class="keyword">Then</span> 跳转团队首页</span><br><span class="line"></span><br><span class="line">  <span class="keyword">Examples</span>:</span><br><span class="line">    |<span class="string"> account </span>|<span class="string"> password </span>|</span><br><span class="line">    |<span class="string"> 135xxx1 </span>|<span class="string"> xxxxxxxx </span>|</span><br><span class="line">    |<span class="string"> 135xxx2 </span>|<span class="string"> xxxxxxxx </span>|</span><br></pre></td></tr></table></figure>
<h2 id="po">PO</h2>
<p><strong>页面对象(Page Object)</strong> 模式是 Selenium 实战中最为流行的一种设计模式, 在设计测试时, 常把页面元素定位和元素操作方法按照页面抽象出来, 分离成一定的对象, 再进行重新组织</p>
<p>在实际自动化测试过程中, 一般将脚本的实现分为 4 层:</p>
<ul>
<li><p>基础层: 用于存放 <code>driver</code> 对象及初始化使用;</p></li>
<li><p>对象层: 用于存放页面元素定位和控件操作行为;</p></li>
<li><p>操作层: 用于封装各个模块功能用例的操作;</p></li>
<li><p>业务层: 真正执行测试用例的操作部分</p></li>
</ul>
<h3 id="示例-2">示例</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 基础层 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasePage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> WebDriver driver;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasePage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.setProperty(<span class="string">&quot;webdriver.edge.driver&quot;</span>, <span class="string">&quot;driver/msedgedriver.exe&quot;</span>);</span><br><span class="line">        driver = <span class="keyword">new</span> EdgeDriver();</span><br><span class="line">        driver.manage().window().maximize();</span><br><span class="line">        driver.manage().timeouts().pageLoadTimeout(<span class="number">5L</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> WebDriver <span class="title">driver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> driver;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        driver.get(<span class="string">&quot;http://news.anhuai.com/user/login&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        driver.quit();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> LoginPage <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LoginPage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 对象层 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginPage</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoginPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        PageFactory.initElements(BasePage.driver(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@FindBy(id = &quot;username&quot;)</span></span><br><span class="line">    <span class="meta">@CacheLookup</span></span><br><span class="line">    <span class="keyword">private</span> WebElement username;</span><br><span class="line">    <span class="meta">@FindBy(id = &quot;password&quot;)</span></span><br><span class="line">    <span class="meta">@CacheLookup</span></span><br><span class="line">    <span class="keyword">private</span> WebElement password;</span><br><span class="line">    <span class="meta">@FindBy(className = &quot;ant-btn&quot;)</span></span><br><span class="line">    <span class="meta">@CacheLookup</span></span><br><span class="line">    <span class="keyword">private</span> WebElement submit;</span><br><span class="line">    <span class="meta">@FindBy(className = &quot;ant-form-item-explain&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;WebElement&gt; message;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username.clear();</span><br><span class="line">        <span class="keyword">this</span>.username.sendKeys(username);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password.clear();</span><br><span class="line">        <span class="keyword">this</span>.password.sendKeys(password);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">submit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.submit.click();</span><br><span class="line">        <span class="keyword">return</span> CollectionUtils.isEmpty(<span class="keyword">this</span>.message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 操作层 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginMovies</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        BasePage base = <span class="keyword">new</span> BasePage();</span><br><span class="line">        base.open();</span><br><span class="line">        base.login().sendUsername(username);</span><br><span class="line">        base.login().sendPassword(password);</span><br><span class="line">        <span class="keyword">boolean</span> submit = base.login().submit();</span><br><span class="line">        base.close();</span><br><span class="line">        Assertions.assertTrue(submit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 业务层 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LoginMovies movies = <span class="keyword">new</span> LoginMovies();</span><br><span class="line">        movies.login(<span class="string">&quot;135xxxxxxxx&quot;</span>, <span class="string">&quot;xxxxxxxx&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>Selenium3</tag>
        <tag>BDD</tag>
        <tag>TDD</tag>
      </tags>
  </entry>
  <entry>
    <title>Prometheus 数据采集</title>
    <url>/2021/07/04/prometheus-004/</url>
    <content><![CDATA[<h1 id="数据采集">数据采集</h1>
<p>Prometheus 服务采集数据, 通常可以分为以下三种方式:</p>
<ul>
<li>独立方式 使用 Exporter 以零侵入的方式单独部署, 作为代理层暴露第三方系统或应用中的数据</li>
<li>集成方式 使用 ClientLibs 耦合到应用的开发源码中, 主要用于业务相关指标的采集</li>
<li>网关方式 使用 Pushgateway 作为中间网关, 接收应用主动推送的数据, 再暴露给服务端</li>
</ul>
<p>Prometheus 服务拉取数据的规范基于简单的文本格式, 详见 <a href="https://prometheus.io/docs/instrumenting/exposition_formats/">exposition-formats</a></p>
<h2 id="exporter">Exporter</h2>
<p>现成的 exporter 列表, 详见 <a href="https://prometheus.io/docs/instrumenting/exporters/#third-party-exporters">exporter</a>, 自定义编写 exporter 的示例, 参考 <a href="https://prometheus.io/docs/instrumenting/writing_exporters/">writing-exporters</a></p>
<p>常用系统和应用的 exporter 的配置部署示例:</p>
<ol type="1">
<li><p><a href="https://github.com/prometheus/node_exporter">node-exporter</a> 基于 Linux 内核的系统指标采集, 详见 <a href="https://prometheus.io/docs/guides/node-exporter/">node-exporter-guides</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: node-exporter部署</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -d</span></span><br><span class="line">  --net=host</span><br><span class="line">  --pid=host</span><br><span class="line">  -v /:/host:ro,rslave</span><br><span class="line">  prom/node-exporter</span><br><span class="line">  --path.rootfs=/host</span><br><span class="line">  --web.listen-address=:9100</span><br><span class="line">  --web.telemetry-path=/metrics</span><br></pre></td></tr></table></figure></li>
<li><p><a href="https://github.com/prometheus/mysqld_exporter">mysqld-exporter</a> 基于 MySQL 的数据库指标采集</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: mysqld-exporter部署</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -d</span></span><br><span class="line">  --net=host</span><br><span class="line">  -e DATA_SOURCE_NAME=&quot;user:password@(hostname:3306)/&quot;</span><br><span class="line">  -v $(pwd)/config.my.cnf:~/config.my.cnf</span><br><span class="line">  prom/mysqld-exporter</span><br><span class="line">  --config.my-cnf=~/config.my.cnf</span><br><span class="line">  --web.listen-address=:9104</span><br><span class="line">  --web.telemetry-path=/metrics</span><br></pre></td></tr></table></figure></li>
<li><p><a href="https://github.com/oliver006/redis_exporter">redis-exporter</a> 基于 Redis 的数据库指标采集</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: redis_exporter部署</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -d</span></span><br><span class="line">  --net=host</span><br><span class="line">  oliver006/redis_exporter</span><br><span class="line">  --redis.password=password</span><br><span class="line">  --web.listen-address=:9121</span><br><span class="line">  --web.telemetry-path=/metrics</span><br></pre></td></tr></table></figure></li>
<li><p><a href="https://github.com/google/cadvisor">google-cadvisor</a> 基于一个正在运行的 Docker 守护进程, 用于收集, 聚合, 处理和导出进程和容器的指标, 它为每个容器记录资源隔离参数, 资源使用情况, 网络统计信息等数据, 并支持按 Prometheus 的规范格式导出, 详见 <a href="https://github.com/google/cadvisor/blob/master/docs/storage/prometheus.md">cadvisor-prometheus</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: google-cadvisor部署</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo docker run -d</span></span><br><span class="line">  --volume=/:/rootfs:ro</span><br><span class="line">  --volume=/var/run:/var/run:ro</span><br><span class="line">  --volume=/sys:/sys:ro</span><br><span class="line">  --volume=/var/lib/docker/:/var/lib/docker:ro</span><br><span class="line">  --volume=/dev/disk/:/dev/disk:ro</span><br><span class="line">  --publish=8080:8080</span><br><span class="line">  --detach=true</span><br><span class="line">  --privileged</span><br><span class="line">  google/cadvisor</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="clientlibs">ClientLibs</h2>
<p>Prometheus 提供了与应用开发语言相匹配的客户端库, 详见 <a href="https://prometheus.io/docs/instrumenting/clientlibs/">clientlibs</a>, 辅助开发的工具库列表, 详见 <a href="https://prometheus.io/docs/instrumenting/exporters/#other-third-party-utilities">utilities</a>, 自定义编写客户端库的示例, 参考 <a href="https://prometheus.io/docs/instrumenting/writing_clientlibs/">writing-clientlibs</a></p>
<p>已集成 prometheus 采集规范的应用列表, 详见 <a href="https://prometheus.io/docs/instrumenting/exporters/#software-exposing-prometheus-metrics">software</a></p>
<p>常用的集成采集规范的应用配置示例:</p>
<ol type="1">
<li><a href="https://www.docker.com/">Docker</a> 通过守护进程的命令行配置以开启公开指标的功能, 当前这是一个实验性功能, 需要守护进程运行在实验模式, 此配置才能生效, 详见 <a href="https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-metrics">dockerd-metrics</a></li>
<li><a href="https://about.gitlab.com">GitLab</a> 通过管理员权限在设置中可以开启公开指标的功能, 详见 <a href="https://docs.gitlab.com/ee/administration/monitoring/prometheus/gitlab_metrics.html#gitlab-prometheus-metrics">gitlab-prometheus-metrics</a></li>
<li><a href="https://www.jenkins.io/">Jenkins</a> 通过安装插件以公开指标的功能, 详见 <a href="https://plugins.jenkins.io/prometheus/">jenkins-plugin</a></li>
<li><a href="https://www.nginx.com/">Nginx</a> 通过添加模块以公开指标的功能, 详见 <a href="https://github.com/vozlt/nginx-module-vts">nginx-module</a></li>
</ol>
<h2 id="pushgateway">Pushgateway</h2>
<p>Pushgateway 作为一个独立的服务, 位于被采集监控数据的应用程序和 Prometheus 服务之间, 与网关类似, 它被建议用于临时性的解决方案, 应用程序主动推送采样数据到 Pushgateway 集中保存, 然后 Pushgateway 作为 Prometheus 服务配置的作业被定时拉取, 详见 <a href="https://prometheus.io/docs/practices/pushing/">pushgateway</a></p>
<p>它的使用场景主要有如下 3 种:</p>
<ol type="1">
<li>临时或短时间的作业</li>
<li>批处理的作业</li>
<li>与服务存在网络隔离的作业</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: pushgateway部署</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docekr run -d</span></span><br><span class="line">  --net host</span><br><span class="line">  prom/pushgateway</span><br><span class="line">  --web.listen-address=:9091</span><br><span class="line">  --web.telemetry-path=/metrics</span><br><span class="line">  --web.enable-admin-api  # 启用管理员接口</span><br></pre></td></tr></table></figure>
<p>应用程序可以通过基于 http 协议的 api 与网关 Pushgateway 进行交互, 使用示例参考 <a href="https://github.com/prometheus/pushgateway/blob/master/README.md#use-it">pushgateway-use</a></p>
<h3 id="查询">查询</h3>
<p>查询接口有 2 个端点, 详见 <a href="https://github.com/prometheus/pushgateway/blob/master/README.md#query-api">query-api</a></p>
<ol type="1">
<li><p>状态查询接口, 用于获取网关的构建信息, 命令行标志和启动时间等信息</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">GET /api/v1/status</span><br></pre></td></tr></table></figure></li>
<li><p>指标查询接口, 用于获取网关已接收的指标信息</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">GET /api/v1/metrics</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="推送">推送</h3>
<p>推送接口使用类似 REST 风格的端点, 详见 <a href="https://github.com/prometheus/pushgateway/blob/master/README.md#api">push-api</a></p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 推送接口使用指标的名称和标签信息作为路径参数</span></span><br><span class="line">/metrics/job/&lt;JOB_NAME&gt;/<span class="section">[&lt;LABEL_NAME&gt;/&lt;LABEL_VALUE&gt;]</span></span><br></pre></td></tr></table></figure>
<p>提交方式有以下 2 类:</p>
<ol type="1">
<li><p>推送数据</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">PUT     <span class="comment"># 推送或更新一组指标, 空请求体会删除指定路径参数的所有数据</span></span><br><span class="line">POST    <span class="comment"># 同PUT, 更新时限定路径参数完全相同的指标, 空请求体不会删除数据</span></span><br></pre></td></tr></table></figure></li>
<li><p>删除数据</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">DELETE  <span class="comment"># 删除指定路径参数的所有数据</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="管理">管理</h3>
<p>管理员接口用于维护或开发人员对网关的管理, 需要在网关启动时的命令行标志中使用 <code>--web.enable-admin-api</code> 启用管理员接口, 详见 <a href="https://github.com/prometheus/pushgateway/blob/master/README.md#admin-api">admin-api</a></p>
<ol type="1">
<li><p>擦除接口, 用于安全的删除网关已接收的所有指标数据</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">PUT /api/v1/admin/wipe</span><br></pre></td></tr></table></figure></li>
</ol>
<p>管理接口有 3 个端点, 用于 Pushgateway 的自动化和集成等场景, 详见 <a href="https://github.com/prometheus/pushgateway/blob/master/README.md#management-api">management-api</a></p>
<ol type="1">
<li><p>用于获取网关的健康度</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">GET /-/healthy</span><br></pre></td></tr></table></figure></li>
<li><p>用于判断网关是否已准备好接收推送</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">GET /-/ready</span><br></pre></td></tr></table></figure></li>
<li><p>用于触发网关正常退出</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line">PUT /-/quit</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="示例">示例</h3>
<h4 id="查询接口">查询接口</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 状态查询</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl --location --request GET <span class="string">&#x27;http://localhost:9091/api/v1/status&#x27;</span></span></span><br><span class="line">&#123;</span><br><span class="line">    &quot;status&quot;: &quot;success&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;build_information&quot;: &#123;</span><br><span class="line">            &quot;branch&quot;: &quot;HEAD&quot;,</span><br><span class="line">            &quot;buildDate&quot;: &quot;20210528-14:30:10&quot;,</span><br><span class="line">            &quot;buildUser&quot;: &quot;root@da864be5f3f0&quot;,</span><br><span class="line">            &quot;goVersion&quot;: &quot;go1.16.4&quot;,</span><br><span class="line">            &quot;revision&quot;: &quot;6fa509bbf4f082ab8455057aafbb5403bd6e37a5&quot;,</span><br><span class="line">            &quot;version&quot;: &quot;1.4.1&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;flags&quot;: &#123;</span><br><span class="line">            &quot;log.format&quot;: &quot;logfmt&quot;,</span><br><span class="line">            &quot;log.level&quot;: &quot;info&quot;,</span><br><span class="line">            &quot;persistence.file&quot;: &quot;&quot;,</span><br><span class="line">            &quot;persistence.interval&quot;: &quot;5m0s&quot;,</span><br><span class="line">            &quot;push.disable-consistency-check&quot;: &quot;false&quot;,</span><br><span class="line">            &quot;web.config.file&quot;: &quot;&quot;,</span><br><span class="line">            &quot;web.enable-admin-api&quot;: &quot;false&quot;,</span><br><span class="line">            &quot;web.enable-lifecycle&quot;: &quot;false&quot;,</span><br><span class="line">            &quot;web.external-url&quot;: &quot;&quot;,</span><br><span class="line">            &quot;web.listen-address&quot;: &quot;:9091&quot;,</span><br><span class="line">            &quot;web.route-prefix&quot;: &quot;&quot;,</span><br><span class="line">            &quot;web.telemetry-path&quot;: &quot;/metrics&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;start_time&quot;: &quot;2021-07-04T05:07:29.885822042Z&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 指标查询</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl --location --request GET <span class="string">&#x27;http://localhost:9091/api/v1/metrics&#x27;</span></span></span><br><span class="line">&#123;</span><br><span class="line">    &quot;status&quot;: &quot;success&quot;,</span><br><span class="line">    &quot;data&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;labels&quot;: &#123;</span><br><span class="line">                &quot;instance&quot;: &quot;myapp&quot;,</span><br><span class="line">                &quot;job&quot;: &quot;myjob&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;last_push_successful&quot;: true,</span><br><span class="line">            &quot;push_failure_time_seconds&quot;: &#123;</span><br><span class="line">                &quot;time_stamp&quot;: &quot;2021-07-04T06:32:35.525376434Z&quot;,</span><br><span class="line">                &quot;type&quot;: &quot;GAUGE&quot;,</span><br><span class="line">                &quot;help&quot;: &quot;Last Unix time when changing this group in the Pushgateway failed.&quot;,</span><br><span class="line">                &quot;metrics&quot;: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;labels&quot;: &#123;</span><br><span class="line">                            &quot;instance&quot;: &quot;myapp&quot;,</span><br><span class="line">                            &quot;job&quot;: &quot;myjob&quot;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &quot;value&quot;: &quot;0&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;push_time_seconds&quot;: &#123;</span><br><span class="line">                &quot;time_stamp&quot;: &quot;2021-07-04T06:32:35.525376434Z&quot;,</span><br><span class="line">                &quot;type&quot;: &quot;GAUGE&quot;,</span><br><span class="line">                &quot;help&quot;: &quot;Last Unix time when changing this group in the Pushgateway succeeded.&quot;,</span><br><span class="line">                &quot;metrics&quot;: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;labels&quot;: &#123;</span><br><span class="line">                            &quot;instance&quot;: &quot;myapp&quot;,</span><br><span class="line">                            &quot;job&quot;: &quot;myjob&quot;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &quot;value&quot;: &quot;1.6253803555253766e+09&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="推送接口">推送接口</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 推送数据</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> TYPE some_metric counter</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> HELP some_metric Just an example.</span></span></span><br><span class="line">some_metric&#123;label=&quot;val1&quot;&#125; 42</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> TYPE another_metric gauge</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> HELP another_metric Just an example.</span></span></span><br><span class="line">another_metric 2398.283</span><br><span class="line">&#x27;&#x27;&#x27; |</span><br><span class="line">curl --location --request PUT &#x27;http://localhost:9091/metrics/job/myjob/instance/myapp&#x27; --data-binary @-</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> 响应返回200状态码</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除数据</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl --location --request DELETE <span class="string">&#x27;http://localhost:9091/metrics/job/myjob/instance/myapp&#x27;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 响应返回202状态码</span></span><br></pre></td></tr></table></figure>
<h4 id="采集接口">采集接口</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 采集接口</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl --location --request GET <span class="string">&#x27;http://localhost:9091/metrics&#x27;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 截取应用指标的输出如下</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> HELP another_metric Just an example.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> TYPE another_metric gauge</span></span><br><span class="line">another_metric&#123;instance=&quot;myapp&quot;,job=&quot;myjob&quot;&#125; 2398.283</span><br><span class="line"><span class="meta">#</span><span class="bash"> HELP some_metric Just an example.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> TYPE some_metric counter</span></span><br><span class="line">some_metric&#123;instance=&quot;myapp&quot;,job=&quot;myjob&quot;,label=&quot;val1&quot;&#125; 42</span><br></pre></td></tr></table></figure>
<h2 id="telegraf">Telegraf</h2>
<p>Prometheus 采集数据的方式和种类繁多, 每个组件相互独立各司其职, 随着组件部署越多, 维护压力也越大, 尤其是内部自行开发的组件需要大量的人力来完成资源控制, 特性添加, 版本升级等工作, 可以考虑使用 Telegraf 统一进行管理</p>
<p><a href="https://www.influxdata.com/time-series-platform/telegraf/">Telegraf</a> 是开源的服务代理, 主要用于收集时间序列型数据, 其支持从堆栈, 传感器或系统中收集指标数据, 因此可以实现不同组件的多合一管理</p>
<h2 id="grafana">Grafana</h2>
<p><a href="https://grafana.com/grafana/">Grafana</a> 是网络架构和应用分析中最流行的时序数据展示工具, 主要用于大规模指标数据的可视化展示, 目前支持绝大部分时序数据库, 安装参考 <a href="https://grafana.com/docs/grafana/latest/installation/">install</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: docker部署</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -d --name=grafana -p 3000:3000 grafana/grafana</span></span><br></pre></td></tr></table></figure>
<p>服务启动成功之后可以访问本机 <a href="http://127.0.0.1:3000/">3000</a> 端口查看网页, 默认管理员的帐号和密码为 <code>admin</code></p>
<p>Grafana 支持配置 Prometheus 作为可视化的数据源, 可以通过网页手动配置, 参考 <a href="https://grafana.com/docs/grafana/latest/datasources/prometheus/">datasources/prometheus</a></p>
<p>Grafana 提供模板功能, 对于 Prometheus 的大部分 Exporter 和第三方集成基础指标的开发库, 都有现成的模板可直接使用, 在线搜索模板参考 <a href="https://grafana.com/grafana/dashboards">dashboards</a></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>Selenium 入门</title>
    <url>/2020/11/16/selenium%20001/</url>
    <content><![CDATA[<h1 id="入门">入门</h1>
<p><strong>Selenium</strong> 是一个 Web 自动化测试工具, 支持多语言, 多平台, 多浏览器</p>
<h2 id="组件">组件</h2>
<p><strong>Selenium WebDriver</strong> 支持市场上所有主流浏览器, 尽可能模拟真实用户与浏览器的交互, 在不同的浏览器中, 这可能在不同的级别上发生, 下载地址 <a href="https://www.selenium.dev/documentation/en/webdriver/driver_requirements/#quick-reference">webdriver</a></p>
<p><strong>Selenium Grid</strong> 允许测试将命令路由到远程浏览器实例, 旨在提供一种在多台计算机上并行运行测试的简便方法, 并集中管理不同的浏览器版本和浏览器配置, 下载地址 <a href="https://www.selenium.dev/downloads/">grid</a></p>
<ul>
<li><strong>hub</strong> 集线器中枢, 具有已注册服务器的列表, 可以访问并允许控制这些实例</li>
<li><strong>node</strong> 节点中枢, 执行测试的实例, 作为节点的机器不必与集线器或其他节点具有相同的平台或浏览器选择</li>
</ul>
<p><strong>Selenium IDE</strong> 用于开发 Selenium 测试用例的工具, 易于使用的 Chrome 或 Firefox 扩展程序, 通常是开发测试用例的最有效方法, IDE 使用现有的 Selenium 命令以及由该元素的上下文定义的参数, 在浏览器中记录用户的操作并支持导出多种语言, 下载地址 <a href="https://www.selenium.dev/selenium-ide/">ide</a></p>
<h2 id="示例">示例</h2>
<p>示例代码基于 <strong>Junit5</strong> 测试框架的执行环境</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置: pom.xml添加Selenium依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.seleniumhq.selenium<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>selenium-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;selenium.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="selenium-webdriver">Selenium WebDriver</h3>
<ol type="1">
<li><p>下载 WebDriver 驱动, 复制到项目根目录 <code>/driver</code> 文件夹中</p>
<blockquote>
<p>需要浏览器和 WebDriver 的版本相匹配</p>
</blockquote></li>
<li><p>项目编写测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 启动浏览器 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BrowserTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> WebDriver driver;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeAll</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 配置WebDriver位置, 示例使用edge浏览器</span></span><br><span class="line">        System.setProperty(<span class="string">&quot;webdriver.edge.driver&quot;</span>, <span class="string">&quot;driver/msedgedriver.exe&quot;</span>);</span><br><span class="line">        driver = <span class="keyword">new</span> EdgeDriver();</span><br><span class="line">        driver.manage().window().maximize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterAll</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 关闭浏览器</span></span><br><span class="line">        driver.quit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 打开URL</span></span><br><span class="line">        driver.get(<span class="string">&quot;http://news.anhuai.com/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="selenium-grid">Selenium Grid</h3>
<ol type="1">
<li><p>下载 <code>selenium-server-standalone.jar</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 运行: hub</span></span><br><span class="line">java -jar selenium-server-standalone-3.141.59.jar \</span><br><span class="line">     -role hub</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 运行: node</span></span><br><span class="line">java -Dwebdriver.edge.driver=&quot;./driver/msedgedriver.exe&quot; \</span><br><span class="line">     -jar selenium-server-standalone-3.141.59.jar \</span><br><span class="line">     -role node \</span><br><span class="line">     -hub http://localhost:4444 \</span><br><span class="line">     -browser &quot;browserName=MicrosoftEdge,maxInstances=2,version=86.0.622.69,platform=WINDOWS&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行成功可以通过 <a href="http://localhost:4444/grid/console">console</a> 查看实例信息</p>
<p><code>selenium-server-standalone.jar</code> 配置参数查看 <a href="https://www.selenium.dev/documentation/en/grid/grid_3/setting_up_your_own_grid/">setting</a></p>
</blockquote></li>
<li><p>项目编写测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例: 启动浏览器并截图 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BrowserTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> WebDriver driver;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeAll</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.setProperty(<span class="string">&quot;webdriver.edge.driver&quot;</span>, <span class="string">&quot;driver/msedgedriver.exe&quot;</span>);</span><br><span class="line">        driver = <span class="keyword">new</span> RemoteWebDriver(</span><br><span class="line">            URI.create(<span class="string">&quot;http://127.0.0.1:4444/wd/hub&quot;</span>).toURL(), </span><br><span class="line">            DesiredCapabilities.edge());</span><br><span class="line">        driver.manage().window().maximize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterAll</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        driver.quit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        driver.get(<span class="string">&quot;http://news.anhuai.com/&quot;</span>);</span><br><span class="line">        <span class="comment">// 截图</span></span><br><span class="line">        File screen = ((TakesScreenshot)<span class="keyword">new</span> Augmenter().augment(driver))</span><br><span class="line">            .getScreenshotAs(OutputType.FILE);</span><br><span class="line">        <span class="comment">// 保存文件到node实例的机器</span></span><br><span class="line">        FileCopyUtils.copy(screen, <span class="keyword">new</span> File(<span class="string">&quot;D:/save/screenshot.jpg&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="selenium-ide">Selenium IDE</h3>
<ol type="1">
<li>安装浏览器扩展程序</li>
<li>启动 IDE, 记录测试流程</li>
<li>导出测试代码</li>
</ol>
<h2 id="mock-浏览器">Mock 浏览器</h2>
<h3 id="htmlunit">HtmlUnit</h3>
<p><strong>HtmlUnit</strong> 是用于 Java 程序的无 GUI 浏览器, 它为 HTML 文档建模, 并提供允许调用页面, 填写表单, 单击连接等API, 它具有 JavaScript 支持, 并且能够与 AJAX 库一起使用, 根据所使用的配置来模拟 Chrome, Firefox 或 IE</p>
<p>官方文档 <a href="htmlunit.sourceforge.net/gettingStarted.html">HtmlUnit</a></p>
<h3 id="phantomjs">PhantomJS</h3>
<p><strong>PhantomJS</strong> 是基于 Webkit 的无头浏览器, 从历史上看, 这是一个流行的选择, 但 PlantomJS 项目已不再维护, 现在 Chrome 和 Firefox 已提供无头运行的功能</p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>Selenium3</tag>
      </tags>
  </entry>
  <entry>
    <title>自动化测试</title>
    <url>/2020/11/16/test%20001/</url>
    <content><![CDATA[<h1 id="自动化测试">自动化测试</h1>
<p><strong>自动化测试</strong> 是指通过工具录制或编写脚本模拟手工测试的过程, 并通过回放或运行脚本来执行测试, 从而代替人工检查被测软件或系统的功能是否符合预期要求</p>
<p>通过手工测试稳定的功能, 可以采用自动化测试, 机械重复的测试场景也可以采用自动化测试, 这样效率反而更高</p>
<p><strong>手工测试</strong></p>
<ol type="1">
<li>手工测试需要人的较强的思考能力, 通过人的逻辑思考来验证当前测试步骤是否正确;</li>
<li>在执行用例的过程中, 步骤更具有灵活性和跳跃性, 凭借个人的经验积累可以快速发现并准确定位问题;</li>
<li>如果版本迭代中有大量测试用例需要回归测试, 在人员有限的情况下, 在开展回归测试的过程中手工测试就会变得异常困难和吃力</li>
</ol>
<p><strong>自动化测试</strong></p>
<ol type="1">
<li>执行用例的对象是测试脚本, 能通过提供的测试用例判断, 验证当前的步骤是否正确;</li>
<li>用例步骤之间的依赖性强, 在自动执行的过程中不需要思考, 因为这个过程是事先依靠人的思考来设计的;</li>
<li>对于复杂烦琐, 机械重复的测试, 绝对是测试利器, 更能让测试人员从繁重的工作中解脱出来, 从而节省大量时间;</li>
<li>自动化测试先期投入的工作量比较大, 而且对测试人员有一定的要求</li>
</ol>
<h2 id="误区">误区</h2>
<p><strong>误区一</strong> 自动化测试就是用工具录制和回放</p>
<p>通过录制确实可以生成对应语言的脚本, 但得到的不是有效的自动化测试脚本, 录制操作步骤是否正确以及生成的脚本是否稳定, 能否重复使用等, 都会直接影响整个测试结果</p>
<p><strong>误区二</strong> 自动化测试能发现新 Bug</p>
<p>新 Bug 一般是在新功能的手工测试过程中发现的, 自动化测试主要用于大批量的回归测试, 可以发现一些偶发性 Bug, 从而节省更多测试时间</p>
<p><strong>误区三</strong> 有了自动化测试就什么都不用做了</p>
<p>能做自动化测试的项目一定是经过了很多次测试, 并且对框架和功能相对稳定的项目才能编写自动化测试代码, 如果产品版本迭代速度比脚本开发速度还快, 那么自动化测试就只能是说说而已了, 所以自动化测试是一种辅助测试的方式, 最重要的是一切要以做好功能测试为前提</p>
<h2 id="用例">用例</h2>
<p>自动化用例的好坏对自动化测试的开展有着重要的作用和影响</p>
<p><strong>选择</strong></p>
<ul>
<li>有目的地选择用例, 不是所有用例都适合做自动化测试;</li>
<li>对相对稳定的模块进行自动化测试, 而变动较大的模块仍使用手工测试;</li>
<li>优先选择主流程测试用例, 用于冒烟测试;</li>
<li>选取的用例应以步骤烦琐和重复执行率较高的优先</li>
</ul>
<p><strong>编写</strong></p>
<ul>
<li>测试人员应该了解自动化测试是如何模拟手工进行测试的;</li>
<li>编写的测试用例一定要做到步骤清晰明了;</li>
<li>当前的测试用例前置条件信息要写清楚;</li>
<li>不需要每一步都写验证点, 抓重点即可;</li>
<li>用例之间保持独立, 尽量少关联;</li>
<li>用例要以模块和场景去划分, 这样做的好处是方便参数化测试</li>
</ul>
<p><strong>脚本</strong></p>
<ul>
<li>保持测试脚本的独立性, 减少依赖;</li>
<li>保持测试脚本的可移植性;</li>
<li>减少测试脚本对执行环境的依赖;</li>
<li>如果有对执行条件的检查, 检查失败就尽快退出执行;</li>
<li>抽离登录, 初始化实现自动登录;</li>
<li>多元化数据驱动扩展;</li>
<li>减少硬性等待时间</li>
</ul>
<h2 id="场景">场景</h2>
<p>适合自动化测试的情况:</p>
<ul>
<li>需求变更不频繁, 稳定的项目;</li>
<li>项目周期长, 回归测试频率高的项目;</li>
<li>需要大量用户重复执行相同测试的场景;</li>
<li>被测软件功能相对稳定, 并且具备可测试性</li>
</ul>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
  </entry>
  <entry>
    <title>Vim 定制</title>
    <url>/2021/04/25/vim%20003/</url>
    <content><![CDATA[<h1 id="定制">定制</h1>
<h2 id="用户界面">用户界面</h2>
<p>Vim 用户界面是可扩展的, 用户可以改变 Vim 的主题, 修改某些界面元素的显示方式, 并且增强状态栏中的信息显示</p>
<h3 id="配色">配色</h3>
<p>Vim 中可以使用多种配色, 一部分是 Vim 自带的, 一部分则由社区成员提供</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot; 示例: .vimrc配置</span><br><span class="line">set background=dark  &quot; 设置背景色</span><br><span class="line">colorscheme murphy   &quot; 设置主题</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/flazz/vim-colorschemes">Colorschemes</a> 提供了大量的 Vim 配色</p>
<h3 id="状态栏">状态栏</h3>
<p>状态栏是屏幕底部用于显示信息的一个区域</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot; 示例: .vimrc配置</span><br><span class="line">set laststatus=2  &quot; 总显示状态栏</span><br><span class="line">set showcmd       &quot; 在状态栏中显示最后执行的命令</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/vim-airline/vim-airline">Airline</a> 插件提供了轻量级, 信息足够丰富的状态栏</p>
<h2 id="同步">同步</h2>
<p>一般而言, 文件的同步方式有很多, 用户通常会将文件存储在一个 Git 仓库中, 这些配置文件常常称为点文件(dotfiles), 并在主目录中用符号链接文件指向点文件目录中的相应文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: Git同步配置</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> mkdir ~/.dotfiles              <span class="comment"># 创建点文件目录</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git <span class="built_in">clone</span> &lt;URL&gt; ~/.dotfiles    <span class="comment"># 克隆版本库</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ln -s ~/.dotfiles/.vim ~/.vim  <span class="comment"># 创建符号链接</span></span></span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/tpope/vim-fugitive">Fugitive</a> 插件可以使用户在不离开 Vim 的情况下进行 Git 操作, 用户在使用 Vim 编辑文件时, 也可以同时利用版本管理系统记录编辑的位置</p>
<h2 id="vimscript">Vimscript</h2>
<p>Vimscript 是一门用于定制 Vim 的脚本语言, 脚本的命令都可在 Vim 的命令行模式下运行, 习惯上 Vimscript 都采用后缀名 <code>.vim</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 运行Vim脚本文件</span></span><br><span class="line">:source xxx.vim</span><br><span class="line">:source %  # 运行当前文件</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 查看Vim脚本相关的帮助文档</span></span><br><span class="line">:help eval</span><br></pre></td></tr></table></figure>
<h3 id="变量">变量</h3>
<p>Vim 中变量和函数的作用域是通过前缀实现的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot; 示例: 变量</span><br><span class="line">set background=dark         &quot; set关键字为内部选项赋值</span><br><span class="line">let g:airline_theme=&#x27;term&#x27;  &quot; let关键字为非内部变量赋值</span><br><span class="line">let &amp;ignorecase=0           &quot; let赋值Vim选项(布尔1真0假)</span><br><span class="line">let @a=&#x27;&#x27;                   &quot; let赋值寄存器(寄存器a)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 常用的作用域</span></span><br><span class="line">g  # 全局作用域(若未指定作用域, 则默认为全局作用域)</span><br><span class="line">v  # 为Vim所定义的全局作用域</span><br><span class="line">l  # 局部作用域(在函数内部, 若未指定作用域, 则默认为局部作用域)</span><br><span class="line">b  # 表示当前缓冲区</span><br><span class="line">w  # 表示当前窗口</span><br><span class="line">t  # 表示当前标签页</span><br><span class="line">a  # 表示函数的参数</span><br></pre></td></tr></table></figure>
<p>整数变量之间可以进行常用的加减乘除, 字符串拼接使用点运算符</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot; 示例: 点运算符</span><br><span class="line">let b:message=&#x27;theme: &#x27;.g:airline_theme</span><br><span class="line">echo b:message  &quot; 打印变量内容到状态栏中</span><br></pre></td></tr></table></figure>
<p>Vim 支持更复杂的数据结构, 比如列表和字典</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot; 示例: 数据结构</span><br><span class="line">let b:lan = [&#x27;zh&#x27;, &#x27;en&#x27;, &#x27;fr&#x27;]  &quot; 列表</span><br><span class="line">let b:lan2 = &#123;                  &quot; 字典</span><br><span class="line">  \ &#x27;zh&#x27;: &#x27;中文&#x27;,               &quot; 代码跨多行则需要用反斜划线表示换行</span><br><span class="line">  \ &#x27;en&#x27;: &#x27;英文&#x27;,</span><br><span class="line">  \ &#x27;fr&#x27;: &#x27;法文&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="条件">条件</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot; 示例: 条件</span><br><span class="line">if b:value == &#x27;zh&#x27;</span><br><span class="line">  echo &#x27;中文&#x27;</span><br><span class="line">elseif b:value == &#x27;en&#x27;</span><br><span class="line">  echo &#x27;英文&#x27;</span><br><span class="line">else</span><br><span class="line">  echo &#x27;其它&#x27;</span><br><span class="line">endif</span><br><span class="line">&quot; 三元运算符</span><br><span class="line">echo b:value==&#x27;zh&#x27;?&#x27;中文&#x27;:&#x27;其它&#x27;</span><br></pre></td></tr></table></figure>
<p>条件表达式支持常用的 与<code>&amp;&amp;</code>, 或<code>||</code>, 非<code>!</code> 逻辑运算符, 因为文本编辑本质是字符串操作, Vim 提供了一些文本比较运算符:</p>
<ul>
<li><code>==</code> 字符串匹配</li>
<li><code>=~</code> 正则匹配</li>
<li><code>!~</code> 正则不匹配</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot; 示例: 逻辑运算符</span><br><span class="line">&#x27;zh&#x27; == &#x27;ZH&#x27;          &quot; 是否忽略大小写的默认行为取决于ignorecase的设置</span><br><span class="line">&#x27;zh-cn&#x27; =~ &#x27;\vzh\w*&#x27;  &quot; 真</span><br><span class="line">&#x27;zh-cn&#x27; !~ &#x27;\v\W+&#x27;    &quot; 真</span><br><span class="line"></span><br><span class="line">&quot; 在逻辑运算符后接?强制忽略</span><br><span class="line">&quot; 在逻辑运算符后接#强制考虑</span><br><span class="line">&#x27;zh&#x27; ==? &#x27;ZH&#x27;         &quot; 真</span><br><span class="line">&#x27;zh&#x27; ==# &#x27;ZH&#x27;         &quot; 假</span><br><span class="line">&#x27;zh-cn&#x27; !~# &#x27;\vzh.*&#x27;  &quot; 假</span><br></pre></td></tr></table></figure>
<p>检查当前正在运行的 Vim 是否支持某个功能</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot; 示例: 判断功能</span><br><span class="line">if has(&#x27;python3&#x27;)               &quot; Vim提供了几个系统标示符, 它们对于编写跨平台的脚本非常有用</span><br><span class="line">  let g:gundo_prefer_python3=1  &quot; 当前Vim支持python3时配置插件</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 查看完整的功能列表</span></span><br><span class="line">:help feature-list</span><br></pre></td></tr></table></figure>
<h3 id="循环">循环</h3>
<p>循环控制流支持用 <code>continue</code> 和 <code>break</code> 来控制流程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot; 示例: 循环</span><br><span class="line">for l in lan              &quot; 循环列表</span><br><span class="line">  echo &#x27;value: &#x27;.l</span><br><span class="line">endfor</span><br><span class="line"></span><br><span class="line">for k in keys(lan2)       &quot; 循环字典</span><br><span class="line">  echo &#x27;key: &#x27;.k.&#x27;, value: &#x27;.lan2[k]</span><br><span class="line">endfor</span><br><span class="line"></span><br><span class="line">for [k,v] in items(lan2)  &quot; 循环字典</span><br><span class="line">  if k == &#x27;zh&#x27;</span><br><span class="line">    break                 &quot; 跳出</span><br><span class="line">  else</span><br><span class="line">    continue              &quot; 继续</span><br><span class="line">  endif</span><br><span class="line">  echo &#x27;key: &#x27;.k.&#x27;, value: &#x27;.v</span><br><span class="line">endfor</span><br></pre></td></tr></table></figure>
<h3 id="函数">函数</h3>
<p>在 Vim 中, 定义的函数必须以大写字母开头, 除非函数在脚本作用域或命名空间中, 否则会报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot; 示例: 定义函数</span><br><span class="line">function Translate(lan, ...)               &quot; 固定参数和可变数目参数可以结合使用</span><br><span class="line">  echo &#x27;value: &#x27;.a:lan                     &quot; 在函数内访问参数时需要使用a:作用域</span><br><span class="line">  echo &#x27;values: &#x27;.join(a:000, &#x27;, &#x27;)        &quot; a:000获取可变数目参数的列表, join是内置的列表操作函数</span><br><span class="line">  echo &#x27;values: &#x27;.a:lan.&#x27;, &#x27;.a:1.&#x27;, &#x27;.a:2  &quot; 通过序号获取可变数目参数的单个参数</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 调用函数</span></span><br><span class="line">:call Translate(&#x27;zh&#x27;, &#x27;en&#x27;, &#x27;fr&#x27;)  &quot; 调用</span><br><span class="line"><span class="meta">#</span><span class="bash"> 状态栏输出</span></span><br><span class="line">value: zh</span><br><span class="line">values: en, fr</span><br><span class="line">values: zh, en, fr</span><br><span class="line">请按 ENTER 或其它命令继续</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Vim 脚本可能会被加载多次, 但函数不一定会被重加载(比如修改参数个数时), 解决方案是使用 <code>function!</code> 来定义函数, 加载时强制使用最新的函数定义, 这在测试时非常有用</p>
</blockquote>
<h4 id="lambda">Lambda</h4>
<p>Lambda 表达式是一种匿名函数, 它有助于编写逻辑清晰的代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot; 示例: Lambda表达式</span><br><span class="line">let b:Func = &#123;arg -&gt; &#x27;arg: &#x27;.arg&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 调用</span></span><br><span class="line">:echo b:Func(&#x27;zh&#x27;)</span><br></pre></td></tr></table></figure>
<p>Vim 支持将函数作为参数传递给另一个函数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot; 示例: 函数传递</span><br><span class="line">function! Echo(frag, func)  &quot; 第二个参数为函数引用</span><br><span class="line">  echo a:func(a:frag, &#x27;-&#x27;)</span><br><span class="line">endfunction</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 调用</span></span><br><span class="line">:call Echo([&#x27;zh&#x27;, &#x27;cn&#x27;], function(&#x27;join&#x27;))                     # function引入一个函数</span><br><span class="line">:call Echo([&#x27;zh&#x27;, &#x27;cn&#x27;], &#123;frag,flag -&gt; frag[0].flag.frag[1]&#125;)  # 匿名函数</span><br></pre></td></tr></table></figure>
<h3 id="类">类</h3>
<p>Vim 本身没有类, 但是它支持在字典上定义方法, 因此可以实现面向对象编程范式, 有两种方式可以在字典上定义方法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot; 示例: 方法一</span><br><span class="line">function b:lan2.Translate(key)                  &quot; 添加函数</span><br><span class="line">  return &#x27;key: &#x27;.a:key.&#x27;, value: &#x27;.self[a:key]  &quot; self指向字典自身</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot; 示例: 方法二</span><br><span class="line">function Translate(key) dict                     &quot; 函数名后添加dict关键字</span><br><span class="line">  return &#x27;key: &#x27;.a:key.&#x27;, value: &#x27;.self[a:key]</span><br><span class="line">endfunction</span><br><span class="line">let b:lan2[&#x27;Translate&#x27;] = function(&#x27;Translate&#x27;)  &quot; 将函数绑定到字典的键上</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 调用</span></span><br><span class="line">:echo b:lan2.Translate(&#x27;zh&#x27;)</span><br></pre></td></tr></table></figure>
<h3 id="命令">命令</h3>
<p>Vim 提供了几个常用的命令, 用于将参数作为执行命令</p>
<ul>
<li><code>execute</code> 将参数解析为Vim命令并执行</li>
<li><code>normal</code> 将参数解析为Vim按键序列(与正常模式的操作相似)</li>
<li><code>silent</code> 用于隐藏命令的输出</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot; 示例: 命令</span><br><span class="line">execute &#x27;echo &amp;ignorecase&#x27;  &quot; 同命令行模式执行:echo &amp;ignorecase</span><br><span class="line">normal dd                   &quot; 同正常模式执行dd(删除当前行)</span><br><span class="line">silent echo &#x27;message&#x27;       &quot; 执行并且隐藏输出</span><br><span class="line"></span><br><span class="line">&quot; normal执行的按键序列会遵守用户配置的按键重映射, 如果要忽略用户配置, 需要使用normal!指令</span><br></pre></td></tr></table></figure>
<p>Vim 文本编辑器的大部分操作是针对文件的, 它提供了许多文件相关的函数</p>
<ul>
<li><code>expand</code> 用于操作文件路径信息</li>
<li><code>filereadable</code> 用于检查文件是否可读(是否存在)</li>
<li><code>filewritable</code> 用于检查文件是否可写(检查权限)</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot; 示例: 文件命令</span><br><span class="line">if filereadable(expand(&#x27;%&#x27;))</span><br><span class="line">  echo &#x27;current file (&#x27;.expand(&#x27;%:t&#x27;).&#x27;) is readable.&#x27;</span><br><span class="line">endif</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> expand的参数是文件名, 可以用特殊符号(比如%表示当前文件), 文件名还可以包含以下修饰符</span></span><br><span class="line">:p  # 表示展开为完整路径 </span><br><span class="line">:h  # 表示路径头(路径最后一个分量被删除)</span><br><span class="line">:t  # 表示路径尾(只保留路径最后一个分量)</span><br><span class="line">:r  # 表示根路径(删除一个文件扩展)</span><br><span class="line">:e  # 表示只保留文件扩展</span><br></pre></td></tr></table></figure>
<h3 id="交互">交互</h3>
<p>Vim 中有两种方式提示用户输入:</p>
<ul>
<li><code>confirm</code> 显示多选对话框</li>
<li><code>input</code> 自定义复杂的输入</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot; 示例: confirm</span><br><span class="line">let b:answer = confirm(&#x27;quit?&#x27;, &quot;&amp;yes\n&amp;no&quot;)</span><br><span class="line">echo b:answer</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行如下</span></span><br><span class="line">:source %</span><br><span class="line">quit?</span><br><span class="line">[y]es, [n]o: # 此处等待用户输入, 输入y则输出1, 输入n则输出2</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot; 示例: input</span><br><span class="line">let b:answer = input(&#x27;what is your preferred language?&#x27;)</span><br><span class="line">echo &quot;\n&quot;.b:answer</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行如下</span></span><br><span class="line">:source %</span><br><span class="line">what is your preferred language?  # 此处等待用户输入</span><br><span class="line"><span class="meta">#</span><span class="bash"> 此处输出用户的输入</span></span><br></pre></td></tr></table></figure>
<p>如果用户在按键重映射中使用了 <code>input</code> 函数, 则必须先调用 <code>inputsave()</code>, 并在之后调用 <code>inputrestore()</code>, 否则映射中剩余字符会被 <code>input</code> 函数获取</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot; 示例: input</span><br><span class="line">function! Func()</span><br><span class="line">  call inputsave()</span><br><span class="line">  let opera = input(&#x27;what is your operation?&#x27;)</span><br><span class="line">  call inputrestore()</span><br><span class="line">  return opera</span><br><span class="line">endfunction</span><br><span class="line">nnoremap &lt;LEADER&gt;o :let b:temp = Func()&lt;CR&gt;:echo b:temp&lt;CR&gt;</span><br></pre></td></tr></table></figure>
<h2 id="插件">插件</h2>
<p>Vim8 的插件布局应该包含如下目录结构, 它与主流插件管理器兼容</p>
<ul>
<li><code>autoload</code> 用于保存插件延迟加载的内容</li>
<li><code>colors</code> 用于保存配色</li>
<li><code>compiler</code> 用于保存编译器相关的功能</li>
<li><code>doc</code> 文档目录</li>
<li><code>ftdetect</code> 用于保存文件类型检测设置</li>
<li><code>ftplugin</code> 用于保存文件类型相关的代码</li>
<li><code>indent</code> 用于保存缩进相关的设置</li>
<li><code>plugin</code> 用于保存插件的核心功能</li>
<li><code>syntax</code> 用于保存语言语法分组</li>
</ul>
<h3 id="示例">示例</h3>
<p>示例实现一个简单的功能, 即添加一个按键绑定, 用于在当前行的行首添加 Java 风格的注释符号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 创建项目</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> mkdir -p ~/.vim/pack/plugins/start/vim-commenter</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> touch ~/.vim/pack/plugins/start/vim-commenter/plugin/commenter.vim</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot; 文件: commenter.vim</span><br><span class="line">function! g:commenter#Comment()</span><br><span class="line">  let l:line = getline(&#x27;.&#x27;)       &quot; 获取当前行的内容</span><br><span class="line">  call setline(&#x27;.&#x27;, &#x27;//&#x27;.l:line)  &quot; 在当前行的行首添加注释符号</span><br><span class="line">endfunction</span><br><span class="line">nnoremap gc :call g:commenter#Comment()&lt;CR&gt;  &quot; 将函数映射到gc按键</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例:</span> </span><br><span class="line">:source $MYVIMRC  # 重加载配置</span><br><span class="line">gc                # 光标移到需要注释的行, 执行gc</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim 工作区</title>
    <url>/2021/04/24/vim%20002/</url>
    <content><![CDATA[<h1 id="工作区">工作区</h1>
<p>在编写程序时, 经常需要同时处理多个文件, 涉及来回切换, 跨文件编辑或到其他界面查询资料等操作, Vim 可以在工作中同时处理任意多个文件</p>
<h2 id="缓冲区">缓冲区</h2>
<p>缓冲区是文件的内部表示, 每个打开的文件都有一个缓冲区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 查看缓冲区列表</span></span><br><span class="line">:ls</span><br><span class="line">  1 %a   &quot;./a_owner.proto&quot;              line 1</span><br><span class="line">  2 #    &quot;./b_address.proto&quot;            line 1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出结果显示了缓冲区的相关信息</span></span><br><span class="line">n       # 为缓冲区的编号, 具有唯一性</span><br><span class="line"><span class="meta">%</span><span class="bash">       <span class="comment"># 表示该缓冲区位于当前窗口中</span></span></span><br><span class="line">a       # 表示该缓冲区处于活动状态, 即它已被加载并可见</span><br><span class="line">&quot;&quot;      # 为文件名</span><br><span class="line">line n  # 表示当前光标位置</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 切换缓冲区</span></span><br><span class="line">:e &lt;path-to-file&gt;  # 在当前Vim窗口中编辑指定文件</span><br><span class="line">:bd                # 从打开的缓冲区列表中删除</span><br><span class="line"></span><br><span class="line">:b &lt;n&gt;     # 指定编号, 指令中的空格可省略</span><br><span class="line">:b &lt;file&gt;  # 指定文件名, 可以使用Tab键补全文件名</span><br><span class="line">:bn        # 上一个缓冲区</span><br><span class="line">:bp        # 下一个缓冲区</span><br></pre></td></tr></table></figure>
<h2 id="窗口">窗口</h2>
<p>Vim 将缓冲区加载到窗口中, 一个屏幕上可以同时显示多个窗口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 窗口操作</span></span><br><span class="line">:sp &lt;path-to-file&gt;  # 垂直新建窗口打开文件</span><br><span class="line">:vs &lt;path-to-file&gt;  # 水平新建窗口打开文件</span><br><span class="line">:qa                 # 关闭所有窗口并退出</span><br></pre></td></tr></table></figure>
<p>使光标在不同窗口间移动, 先按 <code>Ctrl+w</code> 组合键, 再输入方向键</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 查看窗口帮助文档</span></span><br><span class="line">:help window-moving  # 窗口移动位置的文档</span><br><span class="line">:help window-resize  # 窗口调整大小的文档</span><br></pre></td></tr></table></figure>
<h2 id="标签页">标签页</h2>
<p>Vim 用标签页来组织一个窗口的集合, 进而支持在不同的窗口集合之间切换, 这让用户方便的拥有了多个工作区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例:</span> </span><br><span class="line">:tabnew &lt;path-to-file&gt;  # 新建标签页打开文件</span><br><span class="line">:tabnext                # 切换上个标签</span><br><span class="line">:tabprevious            # 切换下个标签</span><br><span class="line">:tabmove &lt;n&gt;            # 移动标签到第n个标签页后</span><br><span class="line">:tabclose               # 关闭标签页</span><br></pre></td></tr></table></figure>
<h2 id="文件树">文件树</h2>
<p>Netrw 是 Vim 内置的文件管理器, 支持对文件和目录的浏览, 这和操作系统下的文件管理器类似</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: Netrw</span></span><br><span class="line">:Ex</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过Netrw, 可以在工作区看到所有的文件, 顶部的状态栏列出了常用操作的快捷键</span></span><br><span class="line">&lt;F1&gt;   # 帮助文档</span><br><span class="line">Enter  # 打开文件或目录</span><br><span class="line">-      # 进入上一层目录</span><br><span class="line">D      # 删除文件或目录</span><br><span class="line">R      # 重命名文件或目录</span><br></pre></td></tr></table></figure>
<p>Netrw 的窗口也可以在分割窗口或标签页中打开</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: Netrw</span></span><br><span class="line">:Vex  # 以左右分割方式打开Netrw</span><br><span class="line">:Sex  # 以上下分割方式打开Netrw</span><br><span class="line">:Lex  # 以左右分割方式打开Netrw, 位于最左边且高度占满整个屏幕</span><br><span class="line"></span><br><span class="line">:Ex sftp://&lt;domain&gt;/&lt;directory&gt;/      # 列出sftp下远程目录</span><br><span class="line">:e scp://&lt;domain&gt;/&lt;directory&gt;/&lt;file&gt;  # 编辑scp远程文件</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/preservim/nerdtree">NERDTree</a> 是一种模拟现代 IDE 行为的优秀插件, 它在屏幕边缘用一个分割的缓冲区来展示文件树, 并且支持书签</p>
<h2 id="文件">文件</h2>
<p>Vim 拥有一些浏览复杂代码结构的功能</p>
<h3 id="折叠">折叠</h3>
<p>折叠功能支持文件部分内容的隐藏, 隐藏的依据既可以是预定义的规则, 也可以是手动添加的折叠标记, Vim 在折叠代码方面是比较智能的, 而且支持多种折叠方式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot; 示例: .vimrc配置</span><br><span class="line">set foldmethod=manual</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可选折叠方式:</span></span><br><span class="line">manual  # 手动折叠 </span><br><span class="line">indent  # 基于缩进的折叠</span><br><span class="line">expr    # 基于正则表达式的折叠</span><br><span class="line">marker  # 使用文本中特殊的标记来定义折叠</span><br><span class="line">syntax  # 提供可识别语法的折叠</span><br><span class="line">diff    # 当Vim处于diff模式时会自动采用这种折叠方式</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 折叠操作</span></span><br><span class="line">zo  # 打开光标所在的折叠</span><br><span class="line">zc  # 关闭光标所在的折叠</span><br><span class="line">za  # 切换光标所在的折叠</span><br><span class="line">zR  # 打开所有折叠</span><br><span class="line">zM  # 关闭所有折叠</span><br></pre></td></tr></table></figure>
<h3 id="自动补全">自动补全</h3>
<p>Vim 内置了代码自动补全的功能, 通过自动补全, 用户可以在编辑时避免拼写错误, 而且无须反复输入和记忆冗长复杂的变量名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 查看自动补全的帮助文档</span></span><br><span class="line">:help ins-completion</span><br></pre></td></tr></table></figure>
<p>自动补全功能从 Vim7 开始默认启用, 输入函数名的开始几个字符, 然后按 <code>Ctrl+n</code> 组合键, Vim 会弹出一个自动补全列表, 可以通过 <code>Ctrl+n</code> 和 <code>Ctrl+p</code> 在这个列表中上下移动, 以选择合适的备选项, 如果继续输入, 列表则会消失</p>
<p><a href="https://github.com/ycm-core/YouCompleteMe">YouCompleteMe</a> 插件扩展了 Vim 内置的自动补全引擎, 而且还增添了大量新功能:</p>
<ul>
<li>支持程序语言感知的自动语义补全;</li>
<li>补全建议的智能排序和过滤;</li>
<li>能够显示代码文档, 重命名变量, 自动格式化代码以及修正某些类别的输入错误</li>
</ul>
<h3 id="标签">标签</h3>
<p>Vim 自带了在同一文件中浏览变量定义的功能, 将光标置于一个单词上, 输入 <code>gd</code> 会优先查看变量的局部声明, 输入 <code>gD</code> 会查看全局声明</p>
<blockquote>
<p>此功能并没有考虑语法, 因为 Vim 本身并不了解代码的语义结构, 不过, Vim 支持标签功能, 标签文件中可存储程序代码的语义和结构关键词, 供 Vim 检索</p>
</blockquote>
<p><a href="http://ctags.sourceforge.net/">Exuberant Ctags</a> 是一个用于生成标签文件的外部工具</p>
<h3 id="撤销树">撤销树</h3>
<p>大部分现代编辑器都支持撤销栈, 其中保存了撤销和重做操作的历史记录, Vim 则更进一步, 采用了撤销树</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 查看撤销树的帮助文档</span></span><br><span class="line">:help undo-tree</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/sjl/gundo.vim">Gundo</a> 是一个对撤销树进行可视化的插件</p>
<p>执行 <code>:GundoToggle</code> 将以分割方式打开(或关闭)两个新窗口, 左上窗口为树状结构的可视化表达, 光标默认选中了最新的版本, 左下窗口则显示此版本和上一版本之间的差异, 按 <code>Enter</code> 键将恢复到选中的版本</p>
<h3 id="差异">差异</h3>
<p>在开发过程中, 经常需要比较不同文件之间的差异, 比如比较不同的输出, 或者比较一个文件的不同版本, 或者处理合并时的冲突, Vim 提供了一个独立的可执行程序 vimdiff 用于对比文件差异</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: vimdiff</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> vimdiff &lt;path-to-file&gt; &lt;path-to-file2&gt;</span></span><br></pre></td></tr></table></figure>
<p>此命令会打开两个文件的窗口, 不同的行用一种颜色高亮显示, 而不同的字符则用另一种颜色高亮显示, 用户可以用 <code>]c</code> 和 <code>[c</code> 分别在多个修改处之间向前和向后跳转</p>
<p>用户可以在两个文件之间推送修改:</p>
<ul>
<li><code>do</code> 或 <code>:diffget</code> 将文件修改应用于当前窗口中的文件</li>
<li><code>dp</code> 或 <code>:diffput</code> 将当前窗口中的文件修改推送给另一个文件</li>
</ul>
<p>若要将一个文件整体复制到另一个文件中, 可以使用 <code>:%diffget</code> 或 <code>:%diffput</code>, 当用户手动修改了文件, 则需要执行 <code>:diffupdate</code> 手动更新高亮显示</p>
<h2 id="参数列表">参数列表</h2>
<p>参数列表(argument list, arglist) 支持在多个文件中执行同一操作, 而不需要用户预先加载缓冲区</p>
<p>参数列表支持如下命令:</p>
<ul>
<li><code>arg</code> 用于定义参数列表</li>
<li><code>argdo</code> 对参数列表中的所有文件执行一条命令</li>
<li><code>args</code> 用于显示参数列表中的文件列表</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 批量替换文件中的字符串</span></span><br><span class="line">:arg **/*.java  # 在参数列表中添加匹配的文件</span><br><span class="line">:argdo %s/\&lt;string\&gt;/String/ge | w</span><br><span class="line"><span class="meta">#</span><span class="bash"> %s/\&lt;public\&gt;/private/ge 通过正则将每个文件中的string单词替换成String</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> w 用于保存每个被修改过的缓冲区</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 使用:normal命令执行正常模式下的命令</span></span><br><span class="line">:argdo execute &quot;:normal dd&quot; | w</span><br></pre></td></tr></table></figure>
<h2 id="正则表达式">正则表达式</h2>
<p>正则表达式(regular expression) 是对字符串操作的一种逻辑公式, Vim 有一套独特的正则表达式语法, 和其他很多正则表达式不同, Vim 中的正则表达式的特殊字符需要用 <code>\</code> 来转义</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 查看特殊符号的完整列表</span></span><br><span class="line">:help ordinary-atom</span><br></pre></td></tr></table></figure>
<p>Vim 通过 <code>:substitute</code> 命令实现搜索和替换功能, 简写为 <code>:s</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 正则命令</span></span><br><span class="line">:s/&lt;find&gt;/&lt;replace&gt;/&lt;flags&gt;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> &lt;flags&gt;是可选的, 可选值</span></span><br><span class="line">g  # 全局替换, 而不仅是第一个</span><br><span class="line">c  # 每次替换前需要确认</span><br><span class="line">e  # 没有匹配项时不显示错误</span><br><span class="line">i  # 忽略大小写</span><br><span class="line">I  # 区分大小写</span><br></pre></td></tr></table></figure>
<h3 id="区间范围">区间范围</h3>
<p><code>:substitute</code> 命令可以作用于一个区间范围, 即指定范围的内容中的匹配项会被替换, 常用的范围是 <code>%</code>, 即作用于整个文件, 区间范围可以用 <code>;</code> 运算符组合起来</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 区间范围替换</span></span><br><span class="line">:3;/out/s/string/String/g</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3;/out 从第3行开始到找到包含out字符串的行</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 查看区间的帮助文档</span></span><br><span class="line">:help cmdline-ranges</span><br></pre></td></tr></table></figure>
<h3 id="魔法模式">魔法模式</h3>
<p>当用户需要编写较长的正则表达式时, 对每个特殊字符都使用 <code>\</code> 转义就比较繁琐, 这时候就需要用到 Vim 的魔法模式了, Vim 的魔法模式用于确定如何解析正则表达式, 有 3 种模式:</p>
<ul>
<li><p>基本魔法(magic) Vim 默认模式, 大部分特殊字符都需要转义, 少数除外如 <code>. *</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 显示设置\m</span></span><br><span class="line">:s/\m.\+//g  # 此处转义符号+</span><br></pre></td></tr></table></figure></li>
<li><p>无魔法(no magic) 类似于基本魔法, 只不过每个特殊字符都需要转义, 包括 <code>. *</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 显示设置\M</span></span><br><span class="line">:s/\M\.\+//g  # 此处转义符号.和+</span><br></pre></td></tr></table></figure></li>
<li><p>深度魔法(very magic) 深度魔法将数字, 字母和下划线之外的字符都视为特殊字符, 不再转义</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 显示设置\v</span></span><br><span class="line">:s/\v.+//g  # 此处不用转义</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="宏">宏</h2>
<p>宏(macro) 支持录制一系列动作, 然后用于回放, Vim 用命令 <code>q</code> 进入宏录制模式, 后面接任意寄存器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 宏录制</span></span><br><span class="line">qa  # 使用寄存器a</span><br><span class="line"><span class="meta">#</span><span class="bash"> 状态栏可以看到recording @a表示宏已经开始录制</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 宏模式下的每个移动或编辑操作都需要考虑到后续的回放</span></span><br><span class="line"></span><br><span class="line">q   # 退出录制</span><br><span class="line">@a  # 回放寄存器a中的宏</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 宏操作</span></span><br><span class="line">@@   # 回放最后一次运行的宏</span><br><span class="line">2@a  # 执行2次寄存器a中的宏</span><br><span class="line">qaq  # 清空寄存器a</span><br></pre></td></tr></table></figure>
<h3 id="递归">递归</h3>
<p>在命令前加数字表示多次重复运行宏, 不过更好的做法是, Vim 支持递归的宏</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 递归宏</span></span><br><span class="line">qbqqb  # 清空寄存器b, 再使用寄存器b进入录制</span><br><span class="line"><span class="meta">#</span><span class="bash"> 单行操作</span></span><br><span class="line">j_  # 光标移到下一行并移至行首</span><br><span class="line">@b  # 重新运行宏b(此时寄存器b为空的, 所以不会有动作)</span><br><span class="line">q   # 退出录制</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行宏b, 递归调用会访问文件中的每一行, 并执行录制的单行操作</span></span><br><span class="line">@b</span><br></pre></td></tr></table></figure>
<h2 id="终端">终端</h2>
<p>Vim 中运行 shell 命令可以使用 <code>:!</code> 命令, 这种方式不太方便, 因为用户无法在运行程序的同时编辑文档</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 传统方式</span></span><br><span class="line">:!vim --version</span><br></pre></td></tr></table></figure>
<p>Vim8.1 版本中引入终端模式, 终端模式是 Vim 会话中运行的一个终端模拟器, 当用户执行终端命令时, 可以同时使用 Vim 进行其他操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 终端模式</span></span><br><span class="line">:term       # 上下分割打开终端窗口</span><br><span class="line">:vert term  # 左右分割打开终端窗口</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 终端窗口初始情况下处于终端工作模式(terminal-job), 操作方式类似插入模式</span></span><br><span class="line">&lt;Ctrl-w&gt; N  # 组合键用于进入终端正常模式(terminal-normal), 按i键可回到终端工作模式</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 执行终端命令并将输出保存到新缓冲区</span></span><br><span class="line">:term vim --version</span><br></pre></td></tr></table></figure>
<h3 id="tmux">Tmux</h3>
<p><a href="https://github.com/tmux/tmux">Tmux</a> 是一个终端复用工具, 可以在终端屏幕中管理多个终端窗口, Tmux 面板和 Vim 窗口可以互补, 用户可以在不同的 Tmux 面板中打开 Vim, 从而让这些实例相互独立, 实现缓冲区的分组</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim 简介</title>
    <url>/2021/04/24/vim%20001/</url>
    <content><![CDATA[<h1 id="简介">简介</h1>
<p><a href="https://www.vim.org/">Vim</a> 是一个高度可配置的文本编辑器, 旨在非常高效的创建和更改任何类型的文本</p>
<blockquote>
<p>原来的 Vi 版本是针对远程终端开发出来的, 那时的带宽和网速都有限, 但正是这些限制使 Vi 的文本编辑流程变得高效而专业, 从而演变为如今的 Vim(Vi Improved) 的核心</p>
</blockquote>
<h2 id="安装">安装</h2>
<p>Vim 可在各种操作系统中安装, 官网 <a href="https://www.vim.org/download.php">download</a> 提供了详细的安装说明</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 确认Vim的版本和功能</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> vim --version</span></span><br><span class="line">VIM - Vi IMproved 8.2 (2019 Dec 12, compiled Dec 21 2020 20:40:08)</span><br><span class="line">macOS version</span><br><span class="line">Included patches: 1-850, 1972</span><br><span class="line">Compiled by root@apple.com</span><br><span class="line">Normal version without GUI.  Features included (+) or not (-):</span><br><span class="line"><span class="meta">#</span><span class="bash"> 部分截取</span></span><br><span class="line">+comments          +libcall           +python/dyn        +visual</span><br><span class="line">-conceal           +linebreak         -python3           +visualextra</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出结果列出的一系列功能, 每项功能前面的(+)表示功能启用, (-)表示功能未启用</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例的Vim支持python2(+python/dyn), 而不支持python3(-python3)</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是, 包管理器软件仓库中的 Vim 版本一般会有所滞后, 安装 Vim 的最佳方式是使用源代码, 这需要编译器及其支持的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 编译安装</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/vim/vim.git  <span class="comment"># 拉取源码</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">cd</span> vim/src</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ./configure --with-features=huge --enable-python3interp</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> make</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> sudo make install  <span class="comment"># 默认功能的安装只需执行此命令</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --with-features=huge编译选项是为了启用Vim大部分功能</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --enable-python3interp选项显式的启用python3</span></span><br></pre></td></tr></table></figure>
<h3 id="手册">手册</h3>
<p>Vim 提供了一个学习工具 <code>:help</code> 命令, Vim 手册中附带了大量的资源和教程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 查看搜索指令相关的文档</span></span><br><span class="line">:help search-commands</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为找到正确的词条, 可以在输入指令 <code>:help search</code> 时通过 <code>Ctrl+d</code> 组合键得到包含 <code>search</code> 的标签列表</p>
</blockquote>
<h3 id="配置">配置</h3>
<p>Vim 是一个高可配置软件, 支持不同层次的配置文件, 详见 <a href="http://vimdoc.sourceforge.net/htmldoc/usr_05.html">settings</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 显示配置层级</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> vim --version</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 部分截取</span></span><br><span class="line">   system vimrc file: &quot;$VIM/vimrc&quot;</span><br><span class="line">     user vimrc file: &quot;$HOME/.vimrc&quot;</span><br><span class="line"> 2nd user vimrc file: &quot;~/.vim/vimrc&quot;</span><br><span class="line">      user exrc file: &quot;$HOME/.exrc&quot;</span><br><span class="line">       defaults file: &quot;$VIMRUNTIME/defaults.vim&quot;</span><br><span class="line">  fall-back for $VIM: &quot;/usr/share/vim&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>windows 系统不允许文件名中出现句号, 因此配置文件的名称为 <code>_vimrc</code></p>
</blockquote>
<p>如果遇到了问题, 可以在 Vim 中执行 <code>:echo $MYVIMRC</code> 指令, Vim 会显示它正在使用的 <code>.vimrc</code> 路径</p>
<h4 id="常用配置">常用配置</h4>
<p>可选配置参考 <a href="http://vimdoc.sourceforge.net/htmldoc/options.html">options</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot; 示例: .vimrc配置</span><br><span class="line">syntax on           &quot; 语法高亮</span><br><span class="line">filetype indent on  &quot; 根据文件类型缩进</span><br><span class="line">set autoindent      &quot; 新行自动处理缩进</span><br><span class="line">set expandtab       &quot; 将制表符展开为空格</span><br><span class="line">set hlsearch        &quot; 高亮匹配搜索项</span><br><span class="line">set incsearch       &quot; 动态高亮搜索项</span><br><span class="line">set ignorecase      &quot; 搜索时忽略大小写</span><br><span class="line">set smartcase       &quot; 搜索时智能大小写</span><br><span class="line">set number          &quot; 启用行号</span><br><span class="line">set relativenumber  &quot; 相对行号</span><br><span class="line">set wildmenu        &quot; 在状态栏上显示补全匹配</span><br></pre></td></tr></table></figure>
<h4 id="重映射">重映射</h4>
<p>Vim 支持将每个操作的按键映射为其他键, 创建一个新映射时, 最好先确认一下此键或按键序列是否已经被映射为其他用途了, 内置的按键绑定列表可通过 <code>:help index</code> 命令查看</p>
<p>Vim 支持细粒度的映射控制方式, 可以针对每种模式分别定义映射</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot; 示例: .vimrc配置</span><br><span class="line">noremap &lt;C-u&gt; :w&lt;CR&gt;  &quot; 配置&lt;Ctrl-u&gt;来保存文件</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 查看帮助文档</span></span><br><span class="line">:help map-modes     # 映射类型</span><br><span class="line">:help key-notation  # 按键表示</span><br></pre></td></tr></table></figure>
<h4 id="先导键">先导键</h4>
<p>Vim 常用先导键来实现额外的快捷键映射, 默认情况下, 先导键为反斜线 <code>\</code>, 这个键使用起来不太方便, 在 Vim 社区中有几个替代的方案, 其中逗号 <code>,</code> 是比较流行的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot; 示例: .vimrc配置</span><br><span class="line">let mapleader = &#x27;,&#x27;       &quot; 配置先导键为逗号</span><br><span class="line">noremap &lt;LEADER&gt;w :w&lt;CR&gt;  &quot; 配置,+w来保存文件</span><br><span class="line"></span><br><span class="line">&quot; 先导键配置应该放在.vimrc中的顶部, 因为新定义的先导键只会在定义之后生效</span><br></pre></td></tr></table></figure>
<h3 id="插件">插件</h3>
<p>Vim 的功能可以通过添加插件来扩展, Vim8 提供了一种原生的插件加载方式:</p>
<ul>
<li><code>.vim/pack/&lt;folder&gt;/opt/</code> 保存的插件用于手动加载</li>
<li><code>.vim/pack/&lt;folder&gt;/start</code> 保存的插件用于始终加载</li>
</ul>
<p>Vim 的插件管理方式一直在与时俱进, 网上也能找到很多插件管理器, <a href="https://github.com/junegunn/vim-plug">vim-plug</a> 是很有前景的插件管理器, 这个插件管理器是轻量级的, 易用且兼容大量的插件</p>
<h4 id="插件配置">插件配置</h4>
<p>Vim 插件通常会提供命令来绑定快捷键, 或提供变量用于控制插件的行为, 因此, 在使用一个插件时, 查看它提供了哪些命令和选项是一个好习惯</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 查看插件的帮助文档</span></span><br><span class="line">:help airline                # airline的帮助文档</span><br><span class="line">:help airline-configuration  # airline的配置文档</span><br></pre></td></tr></table></figure>
<p>先导键在配置插件时尤其有用, 因为它可以为插件提供完整的命名空间</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot; 示例: .vimrc配置</span><br><span class="line">let mapleader = &quot;\&lt;space&gt;&quot;         &quot; 配置先导键为空格键</span><br><span class="line">noremap &lt;LEADER&gt;u :PlugUpdate&lt;CR&gt;  &quot; 配置空格+u执行vim-plug插件的更新插件指令</span><br></pre></td></tr></table></figure>
<h2 id="模式">模式</h2>
<p>Vim 利用不同的模式来响应不同的用户输入, Vim 有 7 种主模式, 理解每一种模式的用途非常重要, 有助于更好的掌握 Vim 的方方面面</p>
<h3 id="正常模式">正常模式</h3>
<p>打开 Vim 时默认为正常模式(normal mode), 在其他模式中按一次 <code>Esc</code> 键, 也会返回正常模式</p>
<h3 id="命令模式ex模式">命令模式/ex模式</h3>
<p>命令模式(command-line mode) 的进入方式是输入 <code>:</code> 或者用 <code>/</code> 或 <code>?</code> 进行搜索, 进入命令模式之后, 可以输入一条命令, 然后按 <code>Enter</code> 键执行命令</p>
<p>ex 模式是为了兼容 Vim 的前身 Ex, 进入方式是按 <code>Q</code> 键, ex 模式支持执行多个命令而无须退出</p>
<h3 id="插入模式">插入模式</h3>
<p>插入模式(insert mode) 用于输入文本 (状态栏标识文本 <code>--INSERT--</code>)</p>
<h3 id="可视模式选择模式">可视模式/选择模式</h3>
<p>可视模式(visual mode) 支持文本的任意选择, 如果需要选择的文本不属于已定义的文本对象, 则这个模式非常有用, 进入可视模式有以下几种方式:</p>
<ul>
<li><code>v</code> 进入字符可视模式 (状态栏标识文本 <code>--VISUAL--</code>)</li>
<li><code>V</code> 进入行可视模式 (状态栏标识文本 <code>--VISUAL LINE--</code>)</li>
<li><code>Ctrl+v</code> 组合键进入块可视模式 (状态栏标识文本 <code>--VISUAL BLOCK--</code>)</li>
</ul>
<p>选择模式(select mode) 模拟的是其他编辑器中的选择模式, 输入任意可打印字符可立即删除选中文本, 然后进入插入模式, 这个模式只应用于特定和受限的场合</p>
<h3 id="替换模式虚拟替换模式">替换模式/虚拟替换模式</h3>
<p>替换模式(replace mode) 输入的文本会覆盖已有的文本, 进入方式是按 <code>R</code> 键 (状态栏标识文本 <code>--REPLACE--</code>)</p>
<p>虚拟替换模式(virtual-replace mode) 和替换模式类似, 只不过操作的对象是屏幕上的显示, 而非直接针对文件中的字符</p>
<h3 id="终端模式">终端模式</h3>
<p>终端模式(terminal mode) 出现在 Vim8.1 版本中, 此模式支持在一个分割窗口中运行一个终端环境, 进入终端模式的命令为 <code>:terminal</code></p>
<h2 id="文本">文本</h2>
<p>Vim 中有两种单词对象:</p>
<ul>
<li>狭义单词(word) 指由空白字符(比如空格, 制表符, 换行符)分隔的字母, 数字和下划线组成的序列</li>
<li>广义单词(WORD) 指由空格分隔的任何非字符组成的序列</li>
</ul>
<h3 id="光标">光标</h3>
<p>在 Vim 中可以用方向键或字母 <code>h(左) j(下) k(上) l(右)</code> 来逐个字符的移动光标, 在命令之前可以加数字, 表示重复这条命令的次数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 逐字符移动</span></span><br><span class="line">5j  # 下移5次</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 逐词移动</span></span><br><span class="line">w   # 移到下个狭义单词</span><br><span class="line">W   # 移到下个广义单词</span><br><span class="line">e   # 向前移到狭义单词的结尾</span><br><span class="line">E   # 向前移到广义单词的结尾</span><br><span class="line">b   # 向后移到狭义单词的开头</span><br><span class="line">B   # 向后移到广义单词的开头</span><br><span class="line">ge  # 移到上个狭义单词的结尾</span><br><span class="line">gE  # 移到上个广义单词的结尾</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 行内移动</span></span><br><span class="line">_        # 光标移到行首</span><br><span class="line"><span class="meta">$</span><span class="bash">        <span class="comment"># 光标移到行尾</span></span></span><br><span class="line">t&lt;字符&gt;  # 在当前行内正向搜索字符, 光标置于字符之前</span><br><span class="line">T&lt;字符&gt;  # 同上反向搜索</span><br><span class="line">f&lt;字符&gt;  # 在当前行内正向搜索字符, 光标置于字符之上</span><br><span class="line">F&lt;字符&gt;  # 同上反向搜索</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 逐段移动</span></span><br><span class="line">&#123;        # 移动到段落开头</span><br><span class="line">&#125;        # 移动到段落结尾</span><br><span class="line">Ctrl+f   # 下翻页</span><br><span class="line">Ctrl+b   # 上翻页</span><br><span class="line">H        # 移动到窗口顶部</span><br><span class="line">L        # 移动到窗口底部</span><br><span class="line">gg       # 移动到文件开头</span><br><span class="line">G        # 移动到文件结尾</span><br></pre></td></tr></table></figure>
<p>Vim 支持通过行号移动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 行号移动</span></span><br><span class="line">:N   # 跳转到第N行(绝对行号)</span><br><span class="line">:+N  # 向下移动N行</span><br><span class="line">:-N  # 向上移动N行</span><br></pre></td></tr></table></figure>
<h3 id="编辑">编辑</h3>
<p>在 Vim 中使用 <code>i</code> 键进入插入模式, 插入文本的位置为光标的位置, 除此之外, 还有其他进入插入模式的便捷方法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 修改命令c</span></span><br><span class="line">ce   # 替换光标到向前的狭义单词结尾的字符, 并进入插入模式</span><br><span class="line">c4l  # 替换光标右4个字符, 并进入插入模式</span><br><span class="line">cc   # 替换光标所在的整行, 并进入插入模式</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 删除命令d</span></span><br><span class="line">dw   # 删除光标到下个狭义单词的字符</span><br><span class="line">d4e  # 删除光标到向前4个狭义单词结尾的字符</span><br><span class="line">dd   # 删除光标所在的整行</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 插入命令</span></span><br><span class="line">a   # 在光标后进入插入模式</span><br><span class="line">A   # 在光标所在行的行尾进入插入模式</span><br><span class="line">I   # 在光标所在行的行首进入插入模式</span><br><span class="line">o   # 在光标下新增一行, 在新行里进入插入模式</span><br><span class="line">O   # 在光标上新增一行, 在新行里进入插入模式</span><br><span class="line">gi  # 在最后退出的位置进入插入模式</span><br><span class="line">C   # 删除光标右边的字符, 并进入插入模式</span><br><span class="line">s   # 删除单个字符, 并进入插入模式</span><br><span class="line">S   # 等同于cc</span><br></pre></td></tr></table></figure>
<h3 id="搜索">搜索</h3>
<p>大多数情况下, Vim 中最快的文本浏览方式是搜索指定的字符串</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 搜索命令</span></span><br><span class="line">/&lt;关键字&gt;  # 正向搜索指定字符串</span><br><span class="line">?&lt;关键字&gt;  # 反向搜索指定字符串</span><br><span class="line"></span><br><span class="line">n  # 跳转到下一个匹配的位置</span><br><span class="line">N  # 跳转到上一个匹配的位置</span><br></pre></td></tr></table></figure>
<p>Vim 支持跨文件的搜索</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 跨文件搜索命令</span></span><br><span class="line">:vimgrep &lt;模式&gt; &lt;路径&gt;</span><br><span class="line"></span><br><span class="line">:cn      # 浏览下一个匹配项</span><br><span class="line">:cp      # 浏览上一个匹配项</span><br><span class="line">:copen   # 显示匹配项的列表</span><br><span class="line">:cclose  # 关闭匹配项的列表</span><br></pre></td></tr></table></figure>
<h3 id="撤销">撤销</h3>
<p>和其他编辑器一样, Vim 也记录了每一步操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 常用操作</span></span><br><span class="line">u       # 撤销</span><br><span class="line">Ctrl+r  # 重做</span><br></pre></td></tr></table></figure>
<p>Vim 支持在不同会话之间持久保存撤销历史, 从而允许撤销几天前的操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot; 示例: .vimrc配置</span><br><span class="line">set undofile               &quot; 启用持久性撤销, 这会对每个编辑的文件保留一个撤销历史记录文件</span><br><span class="line">set undodir=~/.vim/undo//  &quot; 指定撤销历史记录文件的目录</span><br></pre></td></tr></table></figure>
<h2 id="寄存器">寄存器</h2>
<p>Vim 支持多种寄存器, 每个寄存器用字母, 数字或特殊符号来标识, 寄存器的访问方式是引号键 <code>"</code> 接寄存器标识符, 然后是针对指定寄存器的操作</p>
<p>复制(<code>y</code>) 粘贴(<code>p</code>) 使用的是默认的无名寄存器, 用双引号 <code>"</code> 标识</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 无名寄存器</span></span><br><span class="line">&quot;&quot;p  # 从无名寄存器中粘贴文本, 等同于p</span><br></pre></td></tr></table></figure>
<p><code>a~z</code> 标识的寄存器用于手动复制粘贴, <code>0~9</code> 标识的寄存器存储的是最后 10 次删除操作的历史记录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 使用指定寄存器</span></span><br><span class="line">&quot;ayw  # 复制单词到a寄存器</span><br><span class="line">&quot;ap   # 从a寄存器粘贴</span><br><span class="line"></span><br><span class="line">:reg      # 显示每个寄存器中内容的列表</span><br><span class="line">:echo @a  # 查看寄存器a中的内容</span><br></pre></td></tr></table></figure>
<p>一些很有用的只读寄存器:</p>
<ul>
<li><code>%</code> 存储当前文件名</li>
<li><code>#</code> 存储上次打开的文件名</li>
<li><code>.</code> 存储最后插入的文本</li>
<li><code>:</code> 存储最后执行的命令</li>
</ul>
<p>Vim 中有如下两种内置的寄存器用于和外部交互:</p>
<ul>
<li><p><code>*</code> 寄存器表示系统的主粘贴板</p>
<p>macOS 和 Windows 系统中的默认粘贴板, 在 Linux 系统中为终端的鼠标选择内容</p></li>
<li><p><code>+</code> 寄存器称为粘贴板选择器</p>
<p>只针对 Linux 系统, 用于 Windows 风格的 <code>Ctrl+c</code> 和 <code>Ctrl+v</code> 组合键</p></li>
</ul>
<h2 id="交换文件">交换文件</h2>
<p>默认情况下, Vim 用交换文件跟踪文件的变化情况, 当用户编辑文件的时候, Vim 会在原始文件的目录下, 自动产生 <code>.swp</code> 后缀的交换文件, 交换文件的作用是恢复文件内容, 当用户的会话或系统崩溃, 再次用 Vim 打开同一个文件时, 就会看到交换文件的操作提示</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 交换文件操作</span></span><br><span class="line">r  # 从交换文件中恢复文件</span><br><span class="line">d  # 删除交换文件</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot; 示例: .vimrc配置</span><br><span class="line">set noswapfile               &quot; 不创建交换文件</span><br><span class="line">set directory=~/.vim/swap//  &quot; 指定交换文件创建的目录</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>JPA 001 简介</title>
    <url>/2019/05/07/jpa/001/</url>
    <content><![CDATA[<h1 id="简介">简介</h1>
<h2 id="orm-框架对比">ORM 框架对比</h2>
<h3 id="mybatis">MyBatis</h3>
<p><strong>MyBatis</strong> 是 Apache 的一个开源项目, 着力于 POJO 与 SQL 之间的映射关系, 可以进行更为细致的 SQL, 使用起来十分灵活, 上手简单, 容易掌握</p>
<h3 id="hibernate">Hibernate</h3>
<p><strong>Hibernate</strong> 是一个开放源代码的对象关系映射框架, 对 JDBC 进行了非常轻量级的对象封装, 使得 Java 程序员可以随心所欲的使用对象编程思维来操作数据库, 并且对象有自己的生命周期, 着力对象与对象之间的关系, 有自己的 HQL 查询语言, 是符合 JPA 规范的, Hibernate 有自己的缓存机制, 从上手的角度来说比较难, 比较适合企业级的应用系统开发</p>
<h3 id="spring-data-jpa">Spring Data JPA</h3>
<p>JPA 规范的再次封装抽象, 底层还是使用了 Hibernate 的 JPA 技术实现, 引用 JPQL(Java Persistence Query Language) 查询语言, 属于 Spring 整个生态体系的一部分, JPA 上手简单, 对对象的支持比较好, 又有很大的灵活性</p>
<h2 id="jpa">JPA</h2>
<pre class="mermaid">graph TB
A(Spring Data Jpa)
B(JAVA Application)
C[Java Persistence API]
D(Hibernate)
E(OpenJpa)
F(EclipseLink)
G(Other...)
H[Database]
A -.-> C
A -.-> D
B --> C
C --> D
C --> E
C --> F
C --> G
D --> H
E --> H
F --> H
G --> H</pre>
<p>JPA 是 Java Persistence API 的简称, 是 JDK 5.0 注解或 XML 描述对象 - 关系的映射关系, 并将运行期的实体对象持久化到数据库中, Sun 引入新的 JPA ORM 规范出于两个原因:</p>
<ul>
<li>简化现有应用开发工作;</li>
<li>整合 ORM 技术</li>
</ul>
<p>JPA 包括以下 3 方面的内容:</p>
<ul>
<li>一套 API 标准, 在 <code>javax.persistence</code> 的包下面, 用来操作实体对象, 执行 CRUD 操作, 框架在后台完成所有的事情;</li>
<li>面向对象的查询语言, Java Persistence Query Language(JPQL), 这是持久化操作中很重要的一个方面, 通过面向对象而非面向数据库的查询语言查询数据, 避免程序的 SQL 语句紧密耦合;</li>
<li>ORM(object relational metadata) 元数据的映射, JPA 支持 XML 和 JDK 5.0 注解两种元数据的形式, 元数据描述对象和表之间的映射关系, 框架据此将实体对象持久化到数据库表中</li>
</ul>
<h2 id="spring-data">Spring Data</h2>
<p>Spring Data 提供了一个一致的, 基于 Spring 的数据访问编程模型, 同时仍然保留底层数据存储的特殊特性, 它可以轻松的让开发者使用数据访问技术, 包括关系数据库, 非关系数据库 (NoSQL) 和基于云的数据服务</p>
<p>Spring Data 项目旨在提供一种通用的编码模式, 数据访问对象实现了对物理数据层的抽象, 为编写查询方法提供了方便, 通过对象映射, 实现域对象和持续化存储之间的转换, 而模板提供的是对底层存储实体的访问实现</p>
]]></content>
      <categories>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>JPA</tag>
      </tags>
  </entry>
  <entry>
    <title>JPA 003 基础查询</title>
    <url>/2019/05/08/jpa/003/</url>
    <content><![CDATA[<h1 id="jpa-基础查询">JPA 基础查询</h1>
<h2 id="repository">Repository</h2>
<p><code>Repository</code> 位于 Spring Data Common 的 lib 里面, 是 Spring Data 里面做数据库操作的最底层的抽象接口, 最顶级的父类, 源码里面其实什么方法都没有, 仅仅起到一个标识作用, 管理域类以及域类的 <code>id</code> 类型作为类型参数, 此接口主要作为标记接口捕获要使用的类型, Spring 底层做动态代理的时候发现只要是它的子类或者实现类, 都代表储存库操作</p>
<h3 id="类层次关系">类层次关系</h3>
<pre class="mermaid">graph BT
title[图 Repository层级关系]
title --> L
style title fill:#FFF,stroke:#FFF
linkStyle 0 stroke:#FFF,stroke-width:0;
B[Repository]
C[CrudRepository]
D[QueryByExampleExecutor]
E[PagingAndSortingRepository]
F[JpaSpecificationExecutor]
G[JpaRepository]
H[JpaRepositoryImplementation]
I[Serializable]
J[QuerydslPredicateExecutor]
K(SimpleJpaRepository)
L(QuerydslJpaRepository)
L -.-> I
L -.-> J
L --> K
K -.-> H
H --> F
H --> G
G --> D
G --> E
E --> C
C --> B</pre>
<h3 id="实例">实例</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据对象</span></span><br><span class="line"><span class="keyword">package</span> com.janz.jpa.database;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;b_user&quot;)</span> <span class="comment">// 设置表名</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span> <span class="comment">// 定义ID</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.AUTO)</span> <span class="comment">// 设置自增</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get/set 方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据操作Repo</span></span><br><span class="line"><span class="keyword">package</span> com.janz.jpa.database;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.repository.CrudRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">UserDO</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">package</span> com.janz.jpa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.janz.jpa.database.UserDO;</span><br><span class="line"><span class="keyword">import</span> com.janz.jpa.database.UserRepository;</span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.transaction.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest(classes = Application.class)</span></span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepositoryImpl;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserDO user = <span class="keyword">new</span> UserDO();</span><br><span class="line">        user.setName(<span class="string">&quot;测试用户&quot;</span>);</span><br><span class="line">        user.setPhone(<span class="string">&quot;13512351235&quot;</span>);</span><br><span class="line">        user.setEmail(<span class="string">&quot;13512351235@email.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        UserDO result = userRepositoryImpl.save(user);</span><br><span class="line">        Assert.assertNotNull(result);</span><br><span class="line">        Assert.assertNotNull(result.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserDO user = <span class="keyword">new</span> UserDO();</span><br><span class="line">        user.setId(<span class="number">10L</span>);</span><br><span class="line">        user.setName(<span class="string">&quot;测试用户&quot;</span>);</span><br><span class="line">        user.setPhone(<span class="string">&quot;13512351235&quot;</span>);</span><br><span class="line">        user.setEmail(<span class="string">&quot;13512351235@email.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        UserDO result = userRepositoryImpl.save(user);</span><br><span class="line">        Assert.assertNotNull(result);</span><br><span class="line">        Assert.assertNotNull(result.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userRepositoryImpl.deleteById(<span class="number">10L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义方法">自定义方法</h2>
<p>由于 Spring JPA Repository 的实现原理是采用动态代理的机制, 有两种定义查询方法:</p>
<ul>
<li>从方法名称中指定特定用于存储的查询和更新;</li>
<li>通过使用 <code>@Query</code> 手动定义的查询</li>
</ul>
<p>通过 <code>@EnableJpaRepositories</code> 的 <code>queryLookupStrategy</code> 属性可以配置方法的查询策略, 其中 <code>QueryLookupStrategy.Key</code> 的值一共有三个:</p>
<ul>
<li><code>CREATE</code> 直接根据方法名进行创建, 规则是根据方法名称的构造进行尝试, 一般的方法是从方法名中删除给定的一组已知前缀, 并解析该方法的其余部分, 如果方法名不符合规则, 启动的时候就会报异常;</li>
<li><code>USER_DECLARED_QUERY</code> 声明方式创建, 即注解方式, 启动的时候会尝试找到一个声明的查询, 如果没有找到就将抛出一个异常, 查询可以由某处注释或其他方法声明;</li>
<li><code>CREATE_IF_NOT_FOUND</code> 默认值, 以上两种方式的结合, 先用声明方式进行查找, 如果没有找到与方法相匹配的查询, 就用方法名创建规则查询</li>
</ul>
<h3 id="方法名规则">方法名规则</h3>
<p>内部基础架构中有个根据方法名的查询生成器机制, 对于在存储库的实体上构建约束查询很有用, 该机制方法的前缀有 <code>find...By</code>, <code>read...By</code>, <code>query...By</code>, <code>count...By</code> 和 <code>get...By</code>, 从这些方法可以分析它的其余部分 (实体里面的字段), 引入子句可以包含其他表达式, 第一个 <code>By</code> 作为分隔符来指示实际标准的开始, 在一个非常基本的水平上, 可以定义实体性条件, 并与它们串联 (<code>AND</code> 和 <code>OR</code>)</p>
<h4 id="前缀">前缀</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PartTree类中定义的前缀</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUERY_PATTERN = <span class="string">&quot;find|read|get|query|stream&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String COUNT_PATTERN = <span class="string">&quot;count&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXISTS_PATTERN = <span class="string">&quot;exists&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELETE_PATTERN = <span class="string">&quot;delete|remove&quot;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="关键字">关键字</h4>
<p>关键字列表</p>
<table>
<colgroup>
<col style="width: 48%" />
<col style="width: 21%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="header">
<th>关键字</th>
<th>示例</th>
<th>JPQL 表达</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>And</code></td>
<td><code>findByPhoneAndEmail</code></td>
<td><code>where a.phone = ?1 and a.email = ?2</code></td>
</tr>
<tr class="even">
<td><code>Or</code></td>
<td><code>findByPhoneOrEmail</code></td>
<td><code>where a.phone = ?1 or a.email = ?2</code></td>
</tr>
<tr class="odd">
<td><code>Is</code> <code>Equals</code></td>
<td><code>findByNameIs</code></td>
<td><code>where a.name = ?1</code></td>
</tr>
<tr class="even">
<td><code>Between</code></td>
<td><code>findByIdBetween</code></td>
<td><code>where a.id between ?1 and ?2</code></td>
</tr>
<tr class="odd">
<td><code>LessThan</code> <code>Before</code></td>
<td><code>findByIdLessThan</code></td>
<td><code>where a.id &lt; ?1</code></td>
</tr>
<tr class="even">
<td><code>LessThanEqual</code></td>
<td><code>findByIdLessThanEqual</code></td>
<td><code>where a.id &lt;= ?1</code></td>
</tr>
<tr class="odd">
<td><code>GreaterThan</code> <code>After</code></td>
<td><code>findByIdGreaterThan</code></td>
<td><code>where a.id &gt; ?1</code></td>
</tr>
<tr class="even">
<td><code>GreaterThanEqual</code></td>
<td><code>findByIdGreaterThanEqual</code></td>
<td><code>where a.id &gt;= ?1</code></td>
</tr>
<tr class="odd">
<td><code>IsNull</code></td>
<td><code>findByNameIsNull</code></td>
<td><code>where a.name is null</code></td>
</tr>
<tr class="even">
<td><code>IsNotNull</code> <code>NotNull</code></td>
<td><code>findByNameIsNotNull</code></td>
<td><code>where a.name is not null</code></td>
</tr>
<tr class="odd">
<td><code>Like</code><br><code>StartingWith(前缀%)</code><br><code>EndingWith(后缀%)</code><br><code>Containing(环绕%)</code></td>
<td><code>findByNameLike</code></td>
<td><code>where a.name like ?1</code></td>
</tr>
<tr class="even">
<td><code>OrderBy</code></td>
<td><code>findByNameOrderById</code></td>
<td><code>where a.name = ?1 order by a.id</code></td>
</tr>
<tr class="odd">
<td><code>Not</code></td>
<td><code>findByIdNot</code></td>
<td><code>where a.id &lt;&gt; ?1</code></td>
</tr>
<tr class="even">
<td><code>In</code></td>
<td><code>findByIdIn</code></td>
<td><code>where a.id in ?1</code></td>
</tr>
<tr class="odd">
<td><code>NotIn</code></td>
<td><code>findByIdNotIn</code></td>
<td><code>where a.id not in ?1</code></td>
</tr>
<tr class="even">
<td><code>True</code></td>
<td><code>findByActiveTrue</code></td>
<td><code>where a.active = true</code></td>
</tr>
<tr class="odd">
<td><code>False</code></td>
<td><code>findByActiveFalse</code></td>
<td><code>where a.active = false</code></td>
</tr>
<tr class="even">
<td><code>IgnoreCase</code></td>
<td><code>findByNameIgnoreCase</code></td>
<td><code>where UPPER(a.name) = UPPER(?1)</code></td>
</tr>
</tbody>
</table>
<h4 id="属性表达式">属性表达式</h4>
<p><strong>属性表达式(Property Expressions)</strong> 只能引用托管 (泛化) 实体的直接属性, 创建及其查找的过程是, 解析算法首先将整个解释为属性, 并使用该名称检查域类的属性, 如果算法成功, 就使用该属性, 如果不是, 就拆分右侧驼峰部分的信号源到头部和尾部, 并试图找出相应的属性, 如果算法找到一个具有头部的属性, 那么它需要尾部, 并从那里继续构建树, 然后按照刚刚描述的方式将尾部分割, 如果第一个分割不匹配, 就将分割点移动到左边, 然后继续</p>
<blockquote>
<p>算法可能会因为歧义选择错误的属性, 比如:</p>
<p><code>List&lt;Person&gt; findByAddressZipCode(String zipCode)</code></p>
<p>如果 <code>Person</code> 中同时有 <code>Address</code> 和 <code>AddressZip</code>, 算法可能会选择错误的属性, 要解决这个歧义, 可以在方法名称中手动定义遍历点, 比如:</p>
<p><code>List&lt;Person&gt; findByAddress_ZipCode(String zipCode)</code></p>
<p>Spring JPA 里面是将下划线视为保留字符, 但是强烈建议遵循标准 Java 命名约定 (不使用属性名称中的下划线, 而是使用骆驼示例)</p>
</blockquote>
<h4 id="查询结果">查询结果</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 分页/排序查询 */</span></span><br><span class="line"><span class="function">Page&lt;User&gt; <span class="title">findByName</span><span class="params">(String name, Pageable pageable)</span></span>;</span><br><span class="line"><span class="function">Slice&lt;User&gt; <span class="title">findByName</span><span class="params">(String name, Pageable pageable)</span></span>;</span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findByName</span><span class="params">(String name, Pageable pageable)</span></span>;</span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findByName</span><span class="params">(String name, Sort sort)</span></span>;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">Pageable: 分页+排序参数, 会多执行一条count语句</span></span><br><span class="line"><span class="comment">Sort: 排序参数</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 流式查询 */</span></span><br><span class="line"><span class="function">Stream&lt;User&gt; <span class="title">findByName</span><span class="params">(String name)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 异步查询 */</span></span><br><span class="line"><span class="function">Future&lt;User&gt; <span class="title">findByName</span><span class="params">(String name)</span></span>;</span><br><span class="line"><span class="function">CompletableFuture&lt;User&gt; <span class="title">findByName</span><span class="params">(String name)</span></span>;</span><br><span class="line"><span class="function">ListenableFuture&lt;User&gt; <span class="title">findByName</span><span class="params">(String name)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="查询结果扩展-projections">查询结果扩展 (Projections)</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定义想返回字段的接口或类 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NameOnly</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用SPEL语法处理字段, 会导致select全部字段</span></span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;target.phone + &#x27;,&#x27; + target.email&#125;&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">getUserInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子对象也可通过内部接口/类的形式定义</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 返回类型使用定义的接口 */</span></span><br><span class="line"><span class="function">Collection&lt;NameOnly&gt; <span class="title">findById</span><span class="params">(Collection&lt;Long&gt; ids)</span></span>;</span><br><span class="line"><span class="comment">// 可以通过泛化实现返回动态字段</span></span><br><span class="line"><span class="function">Collection&lt;T&gt; <span class="title">findById</span><span class="params">(Collection&lt;Long&gt; ids, Class&lt;T&gt; type)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="注解式">注解式</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Spring JPA里的优先级:</span></span><br><span class="line"><span class="meta">@Query</span> &gt; <span class="meta">@NamedQuery</span> &gt; 方法名规则</span><br><span class="line"><span class="comment">// 都不支持动态条件查询</span></span><br></pre></td></tr></table></figure>
<h4 id="query"><span class="citation" data-cites="Query">@Query</span></h4>
<p>使用命名查询为实体声明查询是一种有效的方法, 对于少量查询很有效, 使用声明式 JPQL 查询有一个好处, 就是启动的时候就知道语法正确与否</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例 */</span></span><br><span class="line"><span class="meta">@Query(value = &quot;select u from UserDO u where u.id = ?1&quot;)</span></span><br><span class="line"><span class="function">List&lt;UserDO&gt; <span class="title">findWithCustomize</span><span class="params">(Long id)</span></span>;</span><br><span class="line"><span class="comment">// LIKE查询</span></span><br><span class="line"><span class="meta">@Query(value = &quot;select u from UserDO u where u.name like %?1%&quot;)</span></span><br><span class="line"><span class="function">List&lt;UserDO&gt; <span class="title">findWithCustomize</span><span class="params">(String name)</span></span>;</span><br><span class="line"><span class="comment">// 原始SQL</span></span><br><span class="line"><span class="meta">@Query(value = &quot;select u.* from b_user u where u.id = ?1&quot;, nativeQuery = true)</span></span><br><span class="line"><span class="function">List&lt;UserDO&gt; <span class="title">findWithCustomize</span><span class="params">(Long id)</span></span>;</span><br><span class="line"><span class="comment">// 排序</span></span><br><span class="line"><span class="meta">@Query(value = &quot;select u.name,LENGTH(u.name) as un_len from UserDO u where u.id = ?1&quot;)</span></span><br><span class="line">List&lt;Object[]&gt; findWithCustomize(Long id, Sort sort);</span><br><span class="line"><span class="comment">// 分页</span></span><br><span class="line"><span class="meta">@Query(value = &quot;select u from UserDO u where u.id = ?1&quot;)</span></span><br><span class="line"><span class="function">Page&lt;UserDO&gt; <span class="title">findWithCustomize</span><span class="params">(Long id, Pageable pageable)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* SpEL表达式的支持 */</span></span><br><span class="line"><span class="meta">@Query(value = &quot;select e from #&#123;#entityName&#125; e where e.id in ?1&quot;)</span></span><br><span class="line"><span class="function">List&lt;UserDO&gt; <span class="title">findById</span><span class="params">(Collection&lt;Long&gt; ids)</span></span>;</span><br><span class="line"><span class="comment">// 适合自定义公用的父类repository</span></span><br></pre></td></tr></table></figure>
<h4 id="namedquery-namednativequery"><span class="citation" data-cites="NamedQuery">@NamedQuery</span> / <span class="citation" data-cites="NamedNativeQuery">@NamedNativeQuery</span></h4>
<p>预定义查询</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例 */</span></span><br><span class="line"><span class="comment">// 在Entity上定义</span></span><br><span class="line"><span class="meta">@NamedQuery(name = &quot;User.findWithNamedQuery&quot;, query = &quot;select u from UserDO u where u.id = ?1&quot;)</span></span><br><span class="line"><span class="comment">// 在Repository中定义</span></span><br><span class="line"><span class="function">Optional&lt;UserDO&gt; <span class="title">findWithNamedQuery</span><span class="params">(Long id)</span></span>;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="meta">@Query(&quot;User.findWithNamedQuery&quot;)</span></span><br><span class="line"><span class="function">Optional&lt;UserDO&gt; <span class="title">findById</span><span class="params">(Long id)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="param"><span class="citation" data-cites="Param">@Param</span></h4>
<p>默认情况下, 参数是通过顺序绑定在查询语句上的, 这使得查询方法对参数位置的重构容易出错, 为了解决这个问题, 可以使用 <code>@Param</code> 注解指定方法参数的具体名称, 通过绑定的参数名字做查询条件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 根据参数进行查询 */</span></span><br><span class="line"><span class="meta">@Query(value = &quot;select u from UserDO u where u.id = :id&quot;)</span></span><br><span class="line"><span class="function">Optional&lt;UserDO&gt; <span class="title">findWithParam</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span></span>;</span><br><span class="line"><span class="comment">// 不加@Param时查询参数名与方法参数名相同</span></span><br></pre></td></tr></table></figure>
<h4 id="modifying"><span class="citation" data-cites="Modifying">@Modifying</span></h4>
<p>修改查询</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 更新指定字段 */</span></span><br><span class="line"><span class="meta">@Modifying(clearAutomatically = true)</span></span><br><span class="line"><span class="meta">@Query(value = &quot;update UserDO u set u.phone = ?2, u.email = ?3 where u.id = ?1&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">updateWithCustomize</span><span class="params">(Long id, String phone, String email)</span></span>;</span><br><span class="line"><span class="comment">// Modifying的clearAutomatically属性用于设置是否刷新hibernate的一级缓存</span></span><br><span class="line"><span class="comment">// 自定义的update/delete语句返回为数字类型的结果, 表示执行语句后受影响的行数</span></span><br></pre></td></tr></table></figure>
<h4 id="procedure"><span class="citation" data-cites="Procedure">@Procedure</span></h4>
<p>存储过程的查询方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例 */</span></span><br><span class="line"><span class="comment">// 在Entity上定义存储过程</span></span><br><span class="line"><span class="meta">@NamedStoredProcedureQuery(name = &quot;UserDO.findWithProcedure&quot;, procedureName = &quot;userFindNameById&quot;, parameters = &#123;</span></span><br><span class="line"><span class="meta">        @StoredProcedureParameter(mode = ParameterMode.IN, name = &quot;id&quot;, type = Long.class),</span></span><br><span class="line"><span class="meta">        @StoredProcedureParameter(mode = ParameterMode.OUT, name = &quot;name&quot;, type = String.class)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="comment">// 在Repository中定义</span></span><br><span class="line"><span class="meta">@Procedure(&quot;UserDO.findWithProcedure&quot;)</span></span><br><span class="line"><span class="function">String <span class="title">findWithProcedure</span><span class="params">(Long id)</span></span>;</span><br><span class="line"><span class="comment">// 注意, 参数名称及类型必须匹配</span></span><br></pre></td></tr></table></figure>
<h4 id="queryhints"><span class="citation" data-cites="QueryHints">@QueryHints</span></h4>
<p>很多数据库支持 Hint Query 的语法, Spring Data JPA 只支持一些固定的 HintValue 值, 用来优化 Query 的作用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例 */</span></span><br><span class="line"><span class="meta">@QueryHints(value = &#123;@QueryHint(name = &quot;&quot;, value = &quot;&quot;)&#125;, forCounting = false)</span></span><br><span class="line"><span class="function">Page&lt;UserDO&gt; <span class="title">findByName</span><span class="params">(String name, Pageable pageable)</span></span>;</span><br><span class="line"><span class="comment">// 了解即可, 不推荐使用</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>JPA</tag>
      </tags>
  </entry>
  <entry>
    <title>JPA 004 扩展查询</title>
    <url>/2019/05/08/jpa/004/</url>
    <content><![CDATA[<h1 id="jpa-扩展查询">JPA 扩展查询</h1>
<h2 id="qbequerybyexample">QBE(QueryByExample)</h2>
<p>按 <strong>实例查询(QBE)</strong> 是一种用户友好的查询技术, 具有简单的接口, 它允许动态查询创建, 并且不需要编写包含字段名称的查询, 继承 <code>QueryByExampleExecutor</code> 和 <code>JpaRepository</code> 都会有这些基本方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* QueryByExampleExecutor源码 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">QueryByExampleExecutor</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    &lt;S extends T&gt; <span class="function">S <span class="title">findOne</span><span class="params">(Example&lt;S&gt; example)</span></span>;</span><br><span class="line">    &lt;S extends T&gt; <span class="function">Iterable&lt;S&gt; <span class="title">findAll</span><span class="params">(Example&lt;S&gt; example)</span></span>;</span><br><span class="line">    &lt;S extends T&gt; <span class="function">Iterable&lt;S&gt; <span class="title">findAll</span><span class="params">(Example&lt;S&gt; example, Sort sort)</span></span>;</span><br><span class="line">    &lt;S extends T&gt; <span class="function">Page&lt;S&gt; <span class="title">findAll</span><span class="params">(Example&lt;S&gt; example, Pageable pageable)</span></span>;</span><br><span class="line">    &lt;S extends T&gt; <span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">(Example&lt;S&gt; example)</span></span>;</span><br><span class="line">    &lt;S extends T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">(Example&lt;S&gt; example)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用示例">使用示例</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 创建查询条件 */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepositoryImpl;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Optional&lt;UserDO&gt; <span class="title">findByName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        UserDO user = <span class="keyword">new</span> UserDO();</span><br><span class="line">        user.setId(<span class="number">10L</span>);</span><br><span class="line">        user.setName(name);</span><br><span class="line">        <span class="comment">// 创建匹配器, 即如何使用查询条件</span></span><br><span class="line">        ExampleMatcher matcher = ExampleMatcher.matching()</span><br><span class="line">            .withIgnoreCase(<span class="keyword">true</span>)</span><br><span class="line">            .withMatcher(<span class="string">&quot;name&quot;</span>, ExampleMatcher.GenericPropertyMatchers.contains())</span><br><span class="line">            .withIgnorePaths(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建实例</span></span><br><span class="line">        Example&lt;UserDO&gt; example = Example.of(user, matcher);</span><br><span class="line">        <span class="comment">// 查询</span></span><br><span class="line">        <span class="keyword">return</span> userRepositoryImpl.findOne(example);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="特点-约束">特点 / 约束</h3>
<p>实例查询顾名思义, 就是通过一个例子来查询:</p>
<ul>
<li><strong>支持动态查询</strong> 即支持查询条件个数不固定的情况;</li>
<li><strong>不支持过滤条件分组</strong> 即不支持过滤条件用 <code>or</code> 来连接, 所有的过滤条件都是简单用 <code>and</code> 连接;</li>
<li><strong>仅支持一个过滤条件值</strong> 要查询的条件值只有一个存储过滤值的位置, 没办法同时传入两个过滤值</li>
</ul>
<h3 id="examplematcher-配置">ExampleMatcher 配置</h3>
<p><strong><code>nullHandler</code></strong> 标识作为条件的实体对象中, 一个属性值为 <code>null</code> 时, 表示是否参与过滤</p>
<ul>
<li><code>INCLUDE</code> 表示参与过滤, 会匹配数据库表中该字段值是 <code>NULL</code> 的记录;</li>
<li><code>IGNORE</code> 表示不参与过滤</li>
</ul>
<p><strong><code>defaultStringMatcher</code></strong> 默认字符串匹配方式</p>
<ul>
<li><code>DEFAULT</code> 默认值, 效果同 <code>EXACT</code>;</li>
<li><code>EXACT</code> 相等;</li>
<li><code>STARTING</code> 开始匹配;</li>
<li><code>ENDING</code> 结束匹配;</li>
<li><code>CONTAINING</code> 包含匹配;</li>
<li><code>REGEX</code> 正则表达式</li>
</ul>
<p><strong><code>defaultIgnoreCase</code></strong> 默认大小写忽略方式, 布尔型</p>
<p><strong><code>propertySpecifiers</code></strong> 各属性特定查询方式, 描述了各个属性单独定义的查询方式</p>
<p><strong><code>ignoredPaths</code></strong> 忽略属性列表, 忽略的属性不参与查询过滤</p>
<h2 id="qbcquerybycriteria">QBC(QueryByCriteria)</h2>
<p><strong><code>Root&lt;T&gt;</code></strong> 代表了可以查询和操作的实体对象的根, 通过对象的 <code>Path&lt;Y&gt; get(String attributeName)</code> 来获得操作的字段</p>
<p><strong><code>CriteriaQuery&lt;?&gt;</code></strong> 代表了一个顶层查询对象, 包含着查询的各个部分, 比如 <code>select</code>, <code>from</code>, <code>where</code>, <code>group by</code>, <code>order by</code> 等</p>
<p><strong><code>CriteriaBuilder</code></strong> 用来构建 <code>CritiaQuery</code> 的构建器对象, 相当于条件或者是条件组合, 以谓语即 <code>Predicate</code> 的形式返回</p>
<h3 id="使用示例-1">使用示例</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 动态查询 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserDO&gt; <span class="title">findByCriteria</span><span class="params">(String name, String phone, String email)</span> </span>&#123;</span><br><span class="line">    CriteriaBuilder cb = entityManager.getCriteriaBuilder();</span><br><span class="line">    CriteriaQuery&lt;UserDO&gt; query = cb.createQuery(UserDO.class);</span><br><span class="line">    Root&lt;UserDO&gt; root = query.from(UserDO.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isEmpty(name)) &#123;</span><br><span class="line">        query.where(cb.like(root.get(<span class="string">&quot;name&quot;</span>), <span class="string">&quot;%&quot;</span> + name + <span class="string">&quot;%&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isEmpty(phone)) &#123;</span><br><span class="line">        query.where(cb.equal(root.get(<span class="string">&quot;phone&quot;</span>), phone));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isEmpty(email)) &#123;</span><br><span class="line">        query.where(cb.equal(root.get(<span class="string">&quot;email&quot;</span>), email));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> entityManager.createQuery(query).getResultList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="jsejpaspecificationexecutor">JSE(JpaSpecificationExecutor)</h2>
<p>Spring Data JPA 支持 Criteria 查询, 可以很方便的使用, <code>JpaSpecificationExecutor</code> 是 JPA 2.0 提供的 Criteria API, 可以用于动态生成 query</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* JpaSpecificationExecutor源码 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JpaSpecificationExecutor</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Optional&lt;T&gt; <span class="title">findOne</span><span class="params">(Specification&lt;T&gt; spec)</span></span>;</span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">findAll</span><span class="params">(Specification&lt;T&gt; spec)</span></span>;</span><br><span class="line">    <span class="function">Page&lt;T&gt; <span class="title">findAll</span><span class="params">(Specification&lt;T&gt; spec, Pageable pageable)</span></span>;</span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">findAll</span><span class="params">(Specification&lt;T&gt; spec, Sort sort)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">(Specification&lt;T&gt; spec)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Specification源码 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Specification</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Specification&lt;T&gt; <span class="title">not</span><span class="params">(Specification&lt;T&gt; spec)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Specifications.negated(spec);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> &lt;T&gt; <span class="function">Specification&lt;T&gt; <span class="title">where</span><span class="params">(Specification&lt;T&gt; spec)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Specifications.where(spec);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">default</span> Specification&lt;T&gt; <span class="title">and</span><span class="params">(Specification&lt;T&gt; other)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Specifications.composed(<span class="keyword">this</span>, other, AND);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">default</span> Specification&lt;T&gt; <span class="title">or</span><span class="params">(Specification&lt;T&gt; other)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Specifications.composed(<span class="keyword">this</span>, other, OR);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Predicate <span class="title">toPredicate</span><span class="params">(Root&lt;T&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder criteriaBuilder)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用示例-2">使用示例</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 动态查询 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Page&lt;UserDO&gt; <span class="title">findBySpecification</span><span class="params">(String name, String phone, String email, Pageable pageable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userRepositoryImpl.findAll((root, query, cb) -&gt; &#123;</span><br><span class="line">        List&lt;Predicate&gt; predicates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(name)) &#123;</span><br><span class="line">            predicates.add(cb.like(root.get(<span class="string">&quot;name&quot;</span>), <span class="string">&quot;%&quot;</span> + name + <span class="string">&quot;%&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(phone)) &#123;</span><br><span class="line">            predicates.add(cb.equal(root.get(<span class="string">&quot;phone&quot;</span>), phone));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(email)) &#123;</span><br><span class="line">            predicates.add(cb.equal(root.get(<span class="string">&quot;email&quot;</span>), email));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> query.where(predicates.toArray(<span class="keyword">new</span> Predicate[predicates.size()])).getRestriction();</span><br><span class="line">    &#125;, pageable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义-repository">自定义 Repository</h2>
<p>由于业务场景的差别, 有可能需要定义自己的 Repository 类, 有两种方式:</p>
<ul>
<li>继承 <code>JpaSpecificationExecutor</code> 通过 <code>CriteriaQuery</code> 几乎可以实现任何逻辑;</li>
<li>写独立接口继承 <code>CrudRepository</code>, 独立实现类利用 <code>EntityManager</code> 操作 <code>Criteria Query API</code> 可以实现任何逻辑</li>
</ul>
<h3 id="entitymanager">EntityManager</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 使用EntityManager查询 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryImpl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PersistenceContext</span></span><br><span class="line">    <span class="keyword">private</span> EntityManager entityManager;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Optional&lt;UserDO&gt; <span class="title">findById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        UserDO user = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用原生SQL查询</span></span><br><span class="line">        String sql = <span class="string">&quot;select * from b_user u where u.id = ?1&quot;</span>;</span><br><span class="line">        user = (UserDO) entityManager.createNativeQuery(sql).setParameter(<span class="number">1</span>, id).getSingleResult();</span><br><span class="line">        <span class="comment">// 使用JPQL查询</span></span><br><span class="line">        String jpql = <span class="string">&quot;select u from UserDO u where u.id = ?1&quot;</span>;</span><br><span class="line">        user = (UserDO) entityManager.createQuery(jpql).setParameter(<span class="number">1</span>, id).getSingleResult();</span><br><span class="line">        <span class="comment">// 使用find方法</span></span><br><span class="line">        user = entityManager.find(UserDO.class, id);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Optional.of(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>JPA</tag>
      </tags>
  </entry>
  <entry>
    <title>JPA 002 Entity</title>
    <url>/2019/05/07/jpa/002/</url>
    <content><![CDATA[<h1 id="jpa-entity">JPA Entity</h1>
<h2 id="jpa-类层级结构">JPA 类层级结构</h2>
<p>JPA 是存储业务实体关联的实体来源, 它显示了如何定义一个面向普通 Java 对象 (POJO) 作为一个实体, 以及如何与管理关系实体提供了一套标准</p>
<p>表 JPA 类层次结构的显示单元</p>
<table>
<colgroup>
<col style="width: 26%" />
<col style="width: 73%" />
</colgroup>
<thead>
<tr class="header">
<th>单元</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>EntityManagerFactory</code></td>
<td>一个 <code>EntityManager</code> 的工厂类, 创建并管理多个 <code>EntityManager</code> 实例</td>
</tr>
<tr class="even">
<td><code>EntityManager</code></td>
<td>一个接口, 管理持久化操作的对象, 工作原理类似工厂的查询实例</td>
</tr>
<tr class="odd">
<td><code>Entity</code></td>
<td>实体是持久性对象, 是存储在数据库中的记录</td>
</tr>
<tr class="even">
<td><code>EntityTransaction</code></td>
<td>与 <code>EntityManager</code> 是一对一的关系, 对于每一个 <code>EntityManager</code>, 操作是由 <code>EntityTransaction</code> 类维护的</td>
</tr>
<tr class="odd">
<td><code>Persistence</code></td>
<td>这个类包含静态方法来获取 <code>EntityManagerFactory</code> 实例</td>
</tr>
<tr class="even">
<td><code>Query</code></td>
<td>该接口由每个 JPA 供应商实现, 能够获得符合标准的关系对象</td>
</tr>
</tbody>
</table>
<h2 id="基本注解">基本注解</h2>
<h3 id="entity"><span class="citation" data-cites="Entity">@Entity</span></h3>
<p><code>@Entity</code> 定义对象将会成为被 JPA 管理的实体, 将映射到指定的数据库表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Entity &#123;</span><br><span class="line">    <span class="comment">// 可选, 默认是此实体类的名字, 全局唯一</span></span><br><span class="line">	<span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="table"><span class="citation" data-cites="Table">@Table</span></h3>
<p><code>@Table</code> 指定数据库的表名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Table &#123;</span><br><span class="line">    <span class="comment">// 表的名字, 可选, 如果不填写, 系统使用实体的名字为表名</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// 此表的catalog, 可选</span></span><br><span class="line">    <span class="function">String <span class="title">catalog</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// 此表所在的schema, 可选</span></span><br><span class="line">    <span class="function">String <span class="title">schema</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// 唯一性约束, 只有创建表的时候有用, 默认不需要</span></span><br><span class="line">    UniqueConstraint[] uniqueConstraints() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">// 索引, 只有创建表的时候使用, 默认不需要</span></span><br><span class="line">    Index[] indexes() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="id"><span class="citation" data-cites="Id">@Id</span></h3>
<p><code>@Id</code> 定义属性为数据库的主键, 一个实体里面必须有一个</p>
<h3 id="idclass"><span class="citation" data-cites="IdClass">@IdClass</span></h3>
<p><code>@IdClass</code> 利用外部类的联合主键</p>
<p>作为符合主键类, 要满足以下几点要求:</p>
<ul>
<li>必须实现 <code>Serializable</code> 接口;</li>
<li>必须有默认的 <code>public</code> 无参数的构造方法;</li>
<li>必须覆盖 <code>equals</code> 和 <code>hashCode</code> 方法</li>
</ul>
<h3 id="generatedvalue"><span class="citation" data-cites="GeneratedValue">@GeneratedValue</span></h3>
<p><code>@GenerateValue</code> 为主键生成策略</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> GeneratedValue &#123;</span><br><span class="line">    <span class="comment">// Id的生成策略</span></span><br><span class="line">    <span class="function">GenerationType <span class="title">strategy</span><span class="params">()</span> <span class="keyword">default</span> AUTO</span>;</span><br><span class="line">    <span class="comment">// 通过Sequences生成Id, 常见的是Orcale数据库ID生成规则, 需要配合@SequenceGenerator使用</span></span><br><span class="line">    <span class="function">String <span class="title">generator</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>GenerationType</code> 共有以下 4 个值:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">GenerationType</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过表产生主键, 框架由表模拟序列产生主键, 使用该策略可以使应用更易于数据库移植</span></span><br><span class="line">    TABLE,</span><br><span class="line">    <span class="comment">// 通过序列产生主键, 通过@SequenceGenerator注解指定序列名, MySQL不支持这种方式</span></span><br><span class="line">    SEQUENCE,</span><br><span class="line">    <span class="comment">// 采用数据库ID自增长, 一般用于MySQL数据库</span></span><br><span class="line">    IDENTITY,</span><br><span class="line">    <span class="comment">// JPA自动选择合适的策略, 是默认选项</span></span><br><span class="line">    AUTO</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="basic"><span class="citation" data-cites="Basic">@Basic</span></h3>
<p><code>@Basic</code> 表示属性是到数据库表的字段的映射, 如果实体的字段上没有任何注解, 默认即为 <code>@Basic</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Basic &#123;</span><br><span class="line">    <span class="comment">// 可选, EAGER(默认)为立即加载, LAZY为延迟加载</span></span><br><span class="line">    <span class="function">FetchType <span class="title">fetch</span><span class="params">()</span> <span class="keyword">default</span> EAGER</span>;</span><br><span class="line">    <span class="comment">// 可选, 设置这个字段是否可以为null, 默认是true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">optional</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="transient"><span class="citation" data-cites="Transient">@Transient</span></h3>
<p><code>@Transient</code> 表示该属性并非一个到数据库表的字段的映射, 表示非持久化属性, 与 <code>@Basic</code> 作用相反, JPA 映射数据库的时候忽略它</p>
<h3 id="column"><span class="citation" data-cites="Column">@Column</span></h3>
<p><code>@Column</code> 定义该属性对应数据库中的列名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Column &#123;</span><br><span class="line">    <span class="comment">// 数据库中表的列名, 可选, 如果不填写认为字段名和实体属性名一样</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// 是否唯一, 默认false, 可选</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">unique</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="comment">// 数据字段是否允许空, 可选, 默认true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">nullable</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">    <span class="comment">// 执行insert操作的时候是否包含此字段, 默认true, 可选</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">insertable</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">    <span class="comment">// 执行update操作的时候是否包含此字段, 默认true, 可选</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">updatable</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">    <span class="comment">// 表示该字段在数据库中的实际类型</span></span><br><span class="line">    <span class="function">String <span class="title">columnDefinition</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// 数据库字段的长度, 可选, 默认255</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">default</span> 255</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="temporal"><span class="citation" data-cites="Temporal">@Temporal</span></h3>
<p><code>@Temporal</code> 用来设置 <code>Date</code> 类型的属性映射到对应精度的字段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Temporal &#123;</span><br><span class="line">    <span class="comment">// 日期精度类型</span></span><br><span class="line">    <span class="function">TemporalType <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>TemporalType</code> 共有以下 3 个值:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">TemporalType</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 映射为日期</span></span><br><span class="line">    DATE,</span><br><span class="line">    <span class="comment">// 映射为时间</span></span><br><span class="line">    TIME,</span><br><span class="line">    <span class="comment">// 映射为日期+时间</span></span><br><span class="line">    TIMESTAMP</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="enumerated"><span class="citation" data-cites="Enumerated">@Enumerated</span></h3>
<p><code>@Enumerated</code> 映射枚举类型的字段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Enumerated &#123;</span><br><span class="line">    <span class="comment">// 枚举映射的类型, 默认是ORDINAL(枚举字段的下标)</span></span><br><span class="line">    <span class="function">EnumType <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ORDINAL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>EnumType</code> 共有以下 2 个值:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">EnumType</span> </span>&#123;</span><br><span class="line">    ORDINAL,</span><br><span class="line">    STRING</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关联关系注解">关联关系注解</h2>
<h3 id="joincolumn"><span class="citation" data-cites="JoinColumn">@JoinColumn</span></h3>
<p><code>@JoinColumn</code> 定义外键关联字段名称, <code>@JoinColumns</code> 定义多个字段的关联关系, <code>@JoinTable</code> 用于对象与对象之间有一个关联关系表的时候, 一般和 <code>@ManyToMany</code> 一起使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> JoinColumn &#123;</span><br><span class="line">    <span class="comment">// 目标表的字段名, 必填</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// 本实体的字段名, 非必填, 默认是本表ID</span></span><br><span class="line">    <span class="function">String <span class="title">referencedColumnName</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// 外键字段是否唯一</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">unique</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="comment">// 外键字段是否允许为空</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">nullable</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">    <span class="comment">// 是否跟随一起新增</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">insertable</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">    <span class="comment">// 是否跟随一起更新</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">updatable</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="onetoone"><span class="citation" data-cites="OneToOne">@OneToOne</span></h3>
<p><code>@OneToOne</code> 一对一关联关系, <code>@OneToMany</code> 一对多关联关系, <code>@ManyToOne</code> 多对一关联关系, <code>@ManyToMany</code> 多对多关联关系</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> OneToOne &#123;</span><br><span class="line">    <span class="comment">// 关系目标实体, 非必填, 默认该字段的类型</span></span><br><span class="line">    <span class="function">Class <span class="title">targetEntity</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">void</span>.class</span>;</span><br><span class="line">    <span class="comment">// 级联操作策略</span></span><br><span class="line">    CascadeType[] cascade() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">// 数据获取方式</span></span><br><span class="line">    <span class="function">FetchType <span class="title">fetch</span><span class="params">()</span> <span class="keyword">default</span> EAGER</span>;</span><br><span class="line">    <span class="comment">// 是否允许为空</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">optional</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">    <span class="comment">// 关联关系被谁维护, 非必填, 一般不需要特别指定</span></span><br><span class="line">    <span class="function">String <span class="title">mappedBy</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// 是否级联删除, 和CascadeType.REMOVE的效果一样</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">orphanRemoval</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CascadeType</code> 共有以下 6 个值:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">CascadeType</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 全选</span></span><br><span class="line">    ALL,</span><br><span class="line">    <span class="comment">// 级联新建</span></span><br><span class="line">    PERSIST,</span><br><span class="line">    <span class="comment">// 级联更新</span></span><br><span class="line">    MERGE,</span><br><span class="line">    <span class="comment">// 级联删除</span></span><br><span class="line">    REMOVE,</span><br><span class="line">    <span class="comment">// 级联刷新</span></span><br><span class="line">    REFRESH,</span><br><span class="line">    <span class="comment">// 级联脱管/游离</span></span><br><span class="line">    DETACH</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="orderby"><span class="citation" data-cites="OrderBy">@OrderBy</span></h3>
<p><code>@OrderBy</code> 关联表的排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> OrderBy &#123;</span><br><span class="line">    <span class="comment">// 要排序的字段, 字段可以是实体属性, 也可以是数据字段, 默认ASC</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="namedentitygraph"><span class="citation" data-cites="NamedEntityGraph">@NamedEntityGraph</span></h3>
<p>JPA 2.1 推出的解决级联查询效率的注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 实体类 */</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;b_user&quot;)</span></span><br><span class="line"><span class="meta">@NamedEntityGraph(name = &quot;Team.graph&quot;, attributeNodes = &#123;@NamedAttributeNode(value = &quot;team&quot;)&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDO</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ManyToOne</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;team_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> TeamDO team;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* REPO接口 */</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">UserDO</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EntityGraph(value = &quot;Team.graph&quot;)</span></span><br><span class="line">    <span class="function">List&lt;UserDO&gt; <span class="title">findByIdIn</span><span class="params">(Collection&lt;Long&gt; ids)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="特点-约束">特点 / 约束</h2>
<ol type="1">
<li>所有的注解要么全配置在字段上, 要么全配置在 <code>get</code> 方法上, 不能混用, 否则会启动不起来, 但是语法配置没有问题;</li>
<li>所有的关联都是支持单向 / 双向关联的, 视具体业务场景而定, JSON 序列化的时候使用双向注解会产生死循环, 需要人为转化一次或者使用 <code>@JsonIgnore</code>;</li>
<li>在所有的关联查询中, 表一般是不需要建立外键索引的, <code>@mappedBy</code> 的使用需要注意;</li>
<li>级联删除比较危险, 建议考虑清楚或者完全掌握;</li>
<li>不同的关联关系的配置, <code>@JoinColumn</code> 里面的 <code>name</code>, <code>referencedColumnName</code> 代表的意思是不一样的, 很容易弄混, 可以根据打印出来的 SQL 做调整</li>
</ol>
]]></content>
      <categories>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>JPA</tag>
      </tags>
  </entry>
  <entry>
    <title>JPA 005 扩展</title>
    <url>/2019/05/22/jpa/005/</url>
    <content><![CDATA[<h1 id="jpa-扩展">JPA 扩展</h1>
<h2 id="auditing">Auditing</h2>
<p>Spring Data JPA 提供了审计功能的架构实现, 提供了 4 个注解:</p>
<ul>
<li><code>@CreatedBy</code> 哪个用户创建的;</li>
<li><code>@CreatedDate</code> 创建的时间;</li>
<li><code>@LastModifiedBy</code> 修改实体的用户;</li>
<li><code>@LastModifiedDate</code> 最后修改的时间</li>
</ul>
<h3 id="配置">配置</h3>
<p>实体中需要添加相应的字段, 并增加 <code>@EntityListeners</code> 注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 配置实体 */</span></span><br><span class="line"><span class="meta">@EntityListeners(AuditingEntityListener.class)</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;b_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDO</span> </span>&#123;</span><br><span class="line">    <span class="meta">@CreatedBy</span></span><br><span class="line">    <span class="keyword">private</span> String createdUserId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@LastModifiedBy</span></span><br><span class="line">    <span class="keyword">private</span> String modifiedUserId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CreatedDate</span></span><br><span class="line">    <span class="keyword">private</span> Date createDate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@LastModifiedDate</span></span><br><span class="line">    <span class="keyword">private</span> Date updateDate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现 <code>AuditorAware</code> 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 配置获取当前用户 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAuditorAware</span> <span class="keyword">implements</span> <span class="title">AuditorAware</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Optional&lt;String&gt; <span class="title">getCurrentAuditor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String userId = <span class="string">&quot;XXXXXX&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> Optional.of(userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开启 JPA 的 Auditing 功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 配置启用 */</span></span><br><span class="line"><span class="meta">@EnableJpaAuditing</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuditorAware <span class="title">auditorProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyAuditorAware();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="乐观锁">乐观锁</h2>
<p>使用对单条数据进行版本校验和比较, 来保证本次的更新是最新的, 否则就失败, 效率要高很多</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 悲观锁的做法</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">for</span> update;</span><br><span class="line">update <span class="keyword">user</span> <span class="keyword">set</span> ... <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 乐观锁的做法</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span>,version <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">update <span class="keyword">user</span> <span class="keyword">set</span> version <span class="operator">=</span> <span class="number">2</span>,... <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> version <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="配置-1">配置</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 实体上字段加@Version */</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;b_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDO</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Version</span></span><br><span class="line">    <span class="keyword">private</span> Long version;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="事务">事务</h2>
<p>正常情况下, 需要在配置类加上 <code>@EnableTransactionManagement</code> 注解才能开启事务管理, spring boot 默认加载的 <code>TransactionAutoConfiguration</code> 类已经加了此注解, 默认采用 <code>AdviceMode.PROXY</code></p>
<h3 id="注解式事务">注解式事务</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Transactional &#123;</span><br><span class="line">    <span class="comment">// 用于设置事务的传播行为</span></span><br><span class="line">    <span class="function">TxType <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> TxType.REQUIRED</span>;</span><br><span class="line">    <span class="comment">// 用于设置需要进行回滚的异常类数组</span></span><br><span class="line">    <span class="keyword">public</span> Class[] rollbackOn() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">// 用于设置不需要进行回滚的异常类数组</span></span><br><span class="line">    <span class="keyword">public</span> Class[] dontRollbackOn() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>TxType</code> 有以下值:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">TxType</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前存在事务, 则加入该事务, 如果当前没有事务, 则创建一个新的事务</span></span><br><span class="line">    REQUIRED,</span><br><span class="line">    <span class="comment">// 创建一个新的事务, 如果当前存在事务, 则把当前事务挂起</span></span><br><span class="line">    REQUIRES_NEW,</span><br><span class="line">    <span class="comment">// 如果当前存在事务, 则加入该事务, 如果当前没有事务, 则抛出异常</span></span><br><span class="line">    MANDATORY,</span><br><span class="line">    <span class="comment">// 如果当前存在事务, 则加入该事务, 如果当前没有事务, 则以非事务的方式继续运行</span></span><br><span class="line">    SUPPORTS,</span><br><span class="line">    <span class="comment">// 以非事务的方式运行, 如果当前存在事务, 则把当前事务挂起</span></span><br><span class="line">    NOT_SUPPORTED,</span><br><span class="line">    <span class="comment">// 以非事务的方式运行, 如果当前存在事务, 则抛出异常</span></span><br><span class="line">    NEVER</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>JPA</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven 001 简介</title>
    <url>/2018/08/29/maven/001/</url>
    <content><![CDATA[<h1 id="maven-简介">Maven 简介</h1>
<h2 id="maven-定义">Maven 定义</h2>
<p>作为 Apache 组织中的一个颇为成功的开源项目, <strong>Maven</strong> 主要服务于基于 Java 平台的项目构建, 依赖管理和项目信息管理</p>
<ul>
<li>Maven 的用途之一是服务于构建, 它是一个异常强大的构建工具, 能够帮我们自动化构建过程, 从清理, 编译, 测试到生成报告, 再到打包和部署;</li>
<li>Maven 不仅是构建工具, 还是一个依赖管理工具和项目信息管理工具</li>
</ul>
<blockquote>
<p>Maven 是跨平台的, 这意味着无论是在 Windows 上, 还是在 Linux 或者 Mac 上, 都可以使用同样的命令</p>
</blockquote>
<p>使用 Maven 的优点:</p>
<ol type="1">
<li>Maven 抽象了一个完整的构建生命周期模型, 这个模型吸取了大量其他的构建脚本和构建工具的优点, 总结了大量项目的实际需求;</li>
<li>Maven 能帮助我们标准化构建过程;</li>
<li>Maven 给第三方类库引入了坐标系统, 让它们变得有秩序, 可以借助它来有序地管理依赖, 轻松地解决那些繁杂的依赖问题;</li>
<li>Maven 能管理原本分散在项目中各个角落的项目信息, 包括项目描述, 开发者列表, 版本控制系统地址, 许可证, 缺陷管理系统地址等;</li>
<li>Maven 为全世界的 Java 开发者提供了一个免费的中央仓库, 在其中几乎可以找到任何的流行开源类库;</li>
<li>使用 Maven 还能享受一个额外的好处, 即 Maven 对于项目目录结构, 测试用例命名方式等内容都有既定的规则, 只要遵循了这些成熟的规则, 用户在项目间切换的时候就免去了额外的学习成本, 可以说是约定优于配置 (Convention Over Configuration)</li>
</ol>
<h2 id="maven-安装">Maven 安装</h2>
<ol type="1">
<li><p>安装 JDK</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装Java</span></span><br><span class="line">λ scoop install adopt8<span class="literal">-openj9</span></span><br><span class="line"><span class="comment"># 查看版本号</span></span><br><span class="line">λ java <span class="literal">-version</span></span><br><span class="line">openjdk version <span class="string">&quot;1.8.0_252&quot;</span></span><br><span class="line">OpenJDK Runtime Environment (build <span class="number">1.8</span>.<span class="number">0</span>_252<span class="literal">-b09</span>)</span><br><span class="line">Eclipse OpenJ9 VM (build openj9<span class="literal">-0</span>.<span class="number">20.0</span>, JRE <span class="number">1.8</span>.<span class="number">0</span> Windows <span class="number">10</span> amd64<span class="literal">-64</span><span class="literal">-Bit</span> Compressed References <span class="number">20200422</span>_667 (JIT enabled, AOT enabled)</span><br><span class="line">OpenJ9   - <span class="number">05</span>fa2d361</span><br><span class="line">OMR      - d4365f371</span><br><span class="line">JCL      - <span class="number">5</span>e623848e9 based on jdk8u252<span class="literal">-b09</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Maven 可以运行在 JDK 1.4 及以上的版本上</p>
</blockquote></li>
<li><p>安装 Maven</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装Maven</span></span><br><span class="line">λ scoop install maven</span><br><span class="line"><span class="comment"># 查看版本号</span></span><br><span class="line">λ mvn <span class="literal">-v</span></span><br><span class="line">Apache Maven <span class="number">3.6</span>.<span class="number">3</span> (cecedd343002696d0abb50b32b541b8a6ba2883f)</span><br><span class="line">Maven home: D:\Scoop\apps\maven\current\bin\..</span><br><span class="line">Java version: <span class="number">1.8</span>.<span class="number">0</span>_252, vendor: Eclipse OpenJ9, runtime: D:\Scoop\apps\adopt8<span class="literal">-openj9</span>\current\jre</span><br><span class="line">Default locale: zh_CN, platform encoding: UTF8</span><br><span class="line">OS name: <span class="string">&quot;windows 10&quot;</span>, version: <span class="string">&quot;10.0&quot;</span>, arch: <span class="string">&quot;amd64&quot;</span>, family: <span class="string">&quot;windows&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="目录分析">目录分析</h2>
<h3 id="m2_home">M2_HOME</h3>
<p><code>M2_HOME</code> 环境变量指向 Maven 的安装目录</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 目录的结构和文件夹</span></span><br><span class="line">λ  <span class="built_in">Get-ChildItem</span> <span class="literal">-Directory</span> D:\Scoop\apps\maven\current\</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Directory: D:\Scoop\apps\maven\current</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mode                LastWriteTime         Length Name</span><br><span class="line">----                -------------         ------ ----</span><br><span class="line">d-----         <span class="number">2020</span>/<span class="number">3</span>/<span class="number">9</span>      <span class="number">7</span>:<span class="number">43</span>                bin</span><br><span class="line">d-----         <span class="number">2020</span>/<span class="number">3</span>/<span class="number">9</span>      <span class="number">7</span>:<span class="number">43</span>                boot</span><br><span class="line">d<span class="literal">-r</span>-<span class="literal">-l</span>         <span class="number">2020</span>/<span class="number">3</span>/<span class="number">9</span>      <span class="number">7</span>:<span class="number">43</span>                conf</span><br><span class="line">d-----         <span class="number">2020</span>/<span class="number">3</span>/<span class="number">9</span>      <span class="number">7</span>:<span class="number">43</span>                lib</span><br></pre></td></tr></table></figure>
<h4 id="bin">bin</h4>
<p>该目录包含了 <code>mvn</code> 运行的脚本, 这些脚本用来配置 Java 命令, 准备好 <code>classpath</code> 和相关的 Java 系统属性, 然后执行 Java 命令</p>
<blockquote>
<p>其中 <code>mvn</code> 是基于 UNIX 平台的 shell 脚本, <code>mvn.bat</code> 是基于 Windows 平台的 bat 脚本, 该目录还包含了 <code>mvnDebug</code> 和 <code>mvnDebug.bat</code> 两个文件, 同样, 前者是 UNIX 平台的 shell 脚本, 后者是 Windows 平台的 bat 脚本, <code>mvnDebug</code> 相比 <code>mvn</code> 多了一条 <code>MAVEN_DEBUG_OPTS</code> 配置, 其作用就是在运行 Maven 时开启 debug, 以便调试 Maven 本身</p>
</blockquote>
<h4 id="boot">boot</h4>
<p>该目录只包含一个文件, 以 <code>maven 3.6.3</code> 为例, 该文件为 <code>plexus-classworlds-2.6.0.jar</code>, <code>plexus-classworlds</code> 是一个类加载器框架, 相对于默认的 Java 类加载器, 它提供了更丰富的语法以方便配置, Maven 使用该框架加载自己的类库</p>
<blockquote>
<p>更多关于 <code>classworlds</code> 的信息请参考 <a href="http://classworlds.codehaus.org/">classworlds</a></p>
</blockquote>
<h4 id="conf">conf</h4>
<p>该目录包含了一个非常重要的文件 <code>settings.xml</code>, 直接修改该文件, 就能在机器上全局地定制 Maven 的行为</p>
<blockquote>
<p>一般情况下, 我们更偏向于复制该文件至 <code>~/.m2/</code> 目录下 (<code>~</code> 表示用户目录), 然后修改该文件, 在用户范围定制 Maven 的行为</p>
</blockquote>
<h4 id="lib">lib</h4>
<p>该目录包含了所有 Maven 运行时需要的 Java 类库</p>
<h3 id="m2">~/.m2</h3>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">λ mvn help:system</span><br><span class="line"><span class="comment"># 该命令会打印出所有的Java系统属性和环境变量, 这些信息对日常的编程工作很有帮助</span></span><br></pre></td></tr></table></figure>
<p>在用户目录下可以发现 <code>.m2</code> 文件夹, 默认情况下, 该文件夹下放置了 Maven 本地仓库 <code>.m2/repository</code>, 所有的 Maven 构件都被存储到该仓库中, 以方便重用</p>
<blockquote>
<p>默认情况下, <code>~/.m2</code> 目录下除了 <code>repository</code> 仓库之外就没有其他目录和文件了, 不过大多数 Maven 用户需要复制 <code>$env:M2_HOME/conf/settings.xml</code> 文件到 <code>~/.m2/settings.xml</code>, 这是一条最佳实践</p>
</blockquote>
<h2 id="配置代理">配置代理</h2>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">λ ping repo1.maven.org</span><br><span class="line"><span class="comment"># 运行该命令可以检查网络是否可以直接访问公共的Maven中央仓库</span></span><br></pre></td></tr></table></figure>
<p>编辑 <code>~/.m2/settings.xml</code> (用户配置) 文件或 <code>$env:M2_HOME/conf/settings.xml</code> (全局配置) 文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">proxies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- proxies下可以有多个proxy元素, 如果声明了多个proxy, 则默认情况下第一个被激活的proxy会生效 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">proxy</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>my-proxy<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- active的值为true表示激活该代理 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">active</span>&gt;</span>true<span class="tag">&lt;/<span class="name">active</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- protocol表示使用的代理协议 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">protocol</span>&gt;</span>http<span class="tag">&lt;/<span class="name">protocol</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">host</span>&gt;</span><span class="tag">&lt;/<span class="name">host</span>&gt;</span> <span class="comment">&lt;!-- 主机名 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">port</span>&gt;</span><span class="tag">&lt;/<span class="name">port</span>&gt;</span> <span class="comment">&lt;!-- 端口 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">username</span>&gt;</span><span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">password</span>&gt;</span><span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- nonProxyHost元素用来指定哪些主机名不需要代理, 可以使用 &quot;|&quot; 符号来分隔多个主机名, 此外, 该配置也支持通配符 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">nonProxyHosts</span>&gt;</span><span class="tag">&lt;/<span class="name">nonProxyHosts</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">proxy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">proxies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="最佳实践">最佳实践</h2>
<h3 id="设置-maven_opts-环境变量">设置 MAVEN_OPTS 环境变量</h3>
<p>通常需要设置 <code>MAVEN_OPTS</code> 的值为 <code>-Xms128m -Xmx512m</code>, 因为 Java 默认的最大可用内存往往不能够满足 Maven 运行的需要, 比如在项目较大时, 使用 Maven 生成项目站点需要占用大量的内存, 如果没有该配置, 则很容易得到 <code>java.lang.OutOfMemeoryError</code>, 因此, 一开始就配置该变量是推荐的做法</p>
<h3 id="配置用户范围-settings.xml">配置用户范围 settings.xml</h3>
<p>Maven 用户可以选择配置 <code>$env:M2_HOME/conf/settings.xml</code> 或者 <code>~/.m2/settings.xml</code>, 前者是全局范围的, 整台机器上的所有用户都会直接受到该配置的影响, 而后者是用户范围的, 只有当前用户才会受到该配置的影响</p>
<p>推荐使用用户范围的 <code>settings.xml</code>, 主要是为了避免无意识地影响到系统中的其他用户, 除了影响范围这一因素, 配置用户范围 <code>settings.xml</code> 文件还便于 Maven 升级</p>
<h3 id="不要使用-ide-内嵌的-maven">不要使用 IDE 内嵌的 Maven</h3>
<p>无论 Eclipse 还是 NetBeans, 当集成 Maven 时, 都会安装上一个内嵌的 Maven, 这个内嵌的 Maven 通常会比较新, 但不一定很稳定, 而且往往也会和在命令行使用的 Maven 不是同一个版本, 这里又会出现两个潜在的问题:</p>
<ol type="1">
<li>较新版本的 Maven 存在很多不稳定因素, 容易造成一些难以理解的问题;</li>
<li>除了 IDE, 也经常还会使用命令行的 Maven, 如果版本不一致, 容易造成构建行为的不一致, 这是我们所不希望看到的, 因此, 应该在 IDE 中配置 Maven 插件时使用与命令行一致的 Maven</li>
</ol>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven 004 聚合与继承</title>
    <url>/2018/09/05/maven/004/</url>
    <content><![CDATA[<h1 id="聚合和继承">聚合和继承</h1>
<h2 id="聚合">聚合</h2>
<p>想要一次构建两个项目, 而不是到两个模块的目录下分别执行 <code>mvn</code> 命令, Maven <strong>聚合</strong> (或者称为多模块) 这一特性就是为该需求服务的</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- project-parent的POM --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.janz.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 对于聚合模块来说, 其打包方式packaging的值必须为pom, 否则就无法构建 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>project-parent<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过在一个打包方式为pom的Maven项目中声明任意数量的module元素来实现模块的聚合 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>project-child-a<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>project-child-b<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>为了方便用户构建项目, 通常将聚合模块放在项目目录的最顶层, 其他模块则作为聚合模块的子目录存在, 这样当用户得到源码的时候, 第一眼发现的就是聚合模块的 <code>POM</code>, 不用从多个模块中去寻找聚合模块来构建整个项目</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">λ tree</span><br><span class="line">文件夹 PATH 列表</span><br><span class="line">卷序列号为 <span class="number">000002</span>B5 D0AF:ECF9</span><br><span class="line">code</span><br><span class="line">├─project<span class="literal">-parent</span></span><br><span class="line">│  ├─project<span class="literal">-child</span><span class="literal">-a</span></span><br><span class="line">│  │  ├─src</span><br><span class="line">│  │  └─pom.xml</span><br><span class="line">│  └─project<span class="literal">-child</span><span class="literal">-b</span></span><br><span class="line">│     ├─src</span><br><span class="line">│     └─pom.xml</span><br><span class="line">└─pom.xml</span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于目录结构还需要注意的是, 聚合模块与其他模块的目录结构并非一定要是父子关系, 如果使用其他目录结构, 聚合模块的 <code>POM</code> 也需要做相应的修改, 以指向正确的模块目录</p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从聚合模块运行mvn clean compile命令</span></span><br><span class="line">λ mvn clean compile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 会首先解析聚合模块的POM, 分析要构建的模块, 并计算出一个反应堆构建顺序(Reactor Build Order), 然后根据这个顺序依次构建各个模块, 反应堆是所有模块组成的一个构建结构</span></span><br></pre></td></tr></table></figure>
<h2 id="继承">继承</h2>
<p>在 Maven 的世界中, 也有类似的机制能让我们抽取出重复的配置, 这就是 <code>POM</code> 的 <strong>继承</strong>, 需要创建 <code>POM</code> 的父子结构, 然后在父 <code>POM</code> 中声明一些配置供子 <code>POM</code> 继承</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- project-parent的POM --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.janz.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 作为父模块的POM, 其打包类型也必须为pom --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>project-parent<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>由于父模块只是为了帮助消除配置的重复, 因此它本身不包含除 <code>POM</code> 之外的项目文件, 也就不需要 <code>src/main/java/</code> 之类的文件夹了</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- project-child-a继承project-parent, project-child-b同理 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用parent元素声明父模块, parent下的子元素groupId, artifactId和version指定了父模块的坐标 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.janz.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 元素relativePath表示父模块POM的相对路径 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 当项目构建时, Maven会首先根据relativePath检查父POM, 如果找不到, 再从本地仓库查找 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- relativePath的默认值是../pom.xml, 即Maven默认父POM在上一层目录下 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project-child-a<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>project-child-a<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 隐式地从父模块继承了这两个元素, 这也就消除了一些不必要的配置, 如果遇到子模块需要使用和父模块不一样的groupId和version的情况, 那么完全可以在子模块中显式声明 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">&lt;groupId&gt;com.janz.maven&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>正确设置 <code>relativePath</code> 非常重要, 考虑这样一个情况, 开发团队的新成员从源码库签出一个包含父子模块关系的 Maven 项目, 由于只关心其中的某一个子模块, 它就直接到该模块的目录下执行构建, 这个时候, 父模块是没有被安装到本地仓库的, 因此如果子模块没有设置正确的 <code>relativePath</code>, Maven 将无法找到父 <code>POM</code>, 这将直接导致构建失败, 如果 Maven 能够根据 <code>relativePath</code> 找到父 <code>POM</code>, 它就不需要再去检查本地仓库</p>
</blockquote>
<h3 id="可继承的-pom-元素">可继承的 POM 元素</h3>
<p>以下是可以被继承的 <code>POM</code> 元素的完整列表, 并附带了简单的说明:</p>
<ul>
<li><code>groupId</code> 项目组 ID, 项目坐标的核心元素;</li>
<li><code>version</code> 项目版本, 项目坐标的核心元素;</li>
<li><code>description</code> 项目的描述信息;</li>
<li><code>organization</code> 项目的组织信息;</li>
<li><code>inceptionYear</code> 项目的创始年份;</li>
<li><code>url</code> 项目的 URL 地址;</li>
<li><code>developers</code> 项目的开发者信息;</li>
<li><code>contributors</code> 项目的贡献者信息;</li>
<li><code>distributionManagement</code> 项目的部署配置;</li>
<li><code>issueManagement</code> 项目的缺陷跟踪系统信息;</li>
<li><code>ciManagement</code> 项目的持续集成系统信息;</li>
<li><code>scm</code> 项目的版本控制系统信息;</li>
<li><code>mailingLists</code> 项目的邮件列表信息;</li>
<li><code>properties</code> 自定义的 Maven 属性;</li>
<li><code>dependencies</code> 项目的依赖配置;</li>
<li><code>dependencyManagement</code> 项目的依赖管理配置;</li>
<li><code>repositories</code> 项目的仓库配置;</li>
<li><code>build</code> 包括项目的源码目录配置, 输出目录配置, 插件配置, 插件管理配置等;</li>
<li><code>reporting</code> 包括项目的报告输出目录配置, 报告插件配置等</li>
</ul>
<h3 id="依赖管理">依赖管理</h3>
<p>Maven 提供的 <code>dependencyManagement</code> 元素既能让子模块继承到父模块的依赖配置, 又能保证子模块依赖使用的灵活性, 在 <code>dependencyManagement</code> 元素下的依赖声明不会引入实际的依赖, 不过它能够约束 <code>dependencies</code> 下的依赖使用</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在project-parent中配置dependencyManagement元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.janz.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>project-parent<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">springframework.version</span>&gt;</span>5.1.1.RELEASE<span class="tag">&lt;/<span class="name">springframework.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;springframework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;springframework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;springframework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;springframework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 继承了dependencyManagement的project-child-a POM --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">javax.mail.version</span>&gt;</span>1.4.1<span class="tag">&lt;/<span class="name">javax.mail.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">greenmail.version</span>&gt;</span>1.3.1b<span class="tag">&lt;/<span class="name">greenmail.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.mail<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;javax.mail.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.icegreen<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>greenmail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;greenmail.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用这种依赖管理机制似乎不能减少太多的 <code>POM</code> 配置, 不过笔者还是强烈推荐采用这种方法, 其主要原因在于在父 <code>POM</code> 中使用 <code>dependencyManagement</code> 声明依赖能够统一项目范围中依赖的版本, 当依赖版本在父 <code>POM</code> 中声明之后, 子模块在使用依赖的时候就无须声明版本, 也就不会发生多个子模块使用依赖版本不一致的情况, 这可以帮助降低依赖冲突的几率</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用import范围依赖导入依赖管理配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.janz.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 依赖范围为import只在dependencyManagement元素下才有效果, 使用该范围的依赖通常指向一个POM, 作用是将目标POM的dependencyManagement配置导入并合并到当前POM的dependencyManagement元素中 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="插件管理">插件管理</h3>
<p>Maven 提供了 <code>pluginManagement</code> 元素版主管理插件, 该元素中配置的依赖不会造成实际的插件调用行为, 当 <code>POM</code> 中配置了真正的 <code>plugin</code> 元素, 并且其 <code>groupId</code> 和 <code>artifactId</code> 与 <code>pluginManagement</code> 中配置的插件匹配时, <code>pluginManagement</code> 的配置才会影响实际的插件行为</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在父POM中配置pluginManagement --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-source-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>attach-sources<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>verify<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar-no-fork<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置了maven-source-plugin, 将其jar-no-fork目标绑定到了verity生命周期阶段, 以生成项目源码包 --&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在子POM中继承了pluginManagement后的插件配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-source-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果子模块需要不同的插件配置, 则可以自行配置以覆盖父模块的pluginManagement配置 --&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>当项目中的多个模块有同样的插件配置时, 应当将配置移到父 <code>POM</code> 的 <code>pluginManagement</code> 元素中, 即使各个模块对于同一插件的具体配置不尽相同, 也应当使用父 <code>POM</code> 的 <code>pluginManagement</code> 元素统一声明插件的版本, 甚至可以要求将所有用到的插件的版本在父 <code>POM</code> 的 <code>pluginManagement</code> 元素中声明, 子模块使用插件时不配置版本信息, 这么做可以统一项目的插件版本, 避免潜在的插件不一致或者不稳定问题, 也更易于维护</p>
</blockquote>
<h2 id="聚合与继承的关系">聚合与继承的关系</h2>
<p>多模块 Maven 项目中的聚合与继承其实是两个概念, 其目的完全是不同的, 前者主要是为了方便快速构建项目, 后者主要是为了消除重复配置:</p>
<ul>
<li>对于聚合模块来说, 它知道有哪些被聚合的模块, 但那些被聚合的模块不知道这个聚合模块的存在;</li>
<li>对于继承关系的父 <code>POM</code> 来说, 它不知道有哪些子模块继承于它, 但那些子模块都必须知道自己的父 <code>POM</code> 是什么</li>
</ul>
<pre class="mermaid">graph TB
title[图 聚合关系与继承关系的比较]
D --> title
style title fill:#FFF,stroke:#FFF
linkStyle 0 stroke:#FFF,stroke-width:0;
A(聚合模块)
B(被聚合模块)
C(被聚合模块)
D(被聚合模块)
E(父模块)
F(子模块)
G(子模块)
H(子模块)
subgraph 继承
E -.-> F
E -.-> G
E -.-> H
end
subgraph 聚合
A --> B
A --> C
A --> D
end</pre>
<blockquote>
<p>在现有的实际项目中, 往往一个 <code>POM</code> 既是聚合<code>POM</code>, 又是父<code>POM</code>, 这么做主要是为了方便, 一般来说, 融合使用聚合与继承也没有什么问题</p>
</blockquote>
<h2 id="反应堆">反应堆</h2>
<p>在一个多模块的 Maven 项目中, <strong>反应堆 (Reactor)</strong> 是指所有模块组成的一个构建结构, 对于单模块的项目, 反应堆就是该模块本身, 但对于多模块项目来说, 反应堆就包含了各模块之间继承与依赖的关系, 从而能够自动计算出合理的模块构建顺序</p>
<h3 id="反应堆构建顺序">反应堆构建顺序</h3>
<p>Maven 按序读取 <code>POM</code>, 如果该 <code>POM</code> 没有依赖模块, 那么就构建该模块, 否则就先构建其依赖模块, 如果该依赖还依赖于其他模块, 则进一步先构建依赖的依赖</p>
<p>模块间的依赖关系会将反应堆构成一个有向非循环图 (Directed Acyclic Graph, DAG), 各个模块是该图的节点, 依赖关系构成了有向边, 这个图不允许出现循环, 因此, 当出现模块 A 依赖于 B, 而 B 又依赖于 A 的情况时, Maven 就会报错</p>
<h3 id="裁剪反应堆">裁剪反应堆</h3>
<p>有些时候, 会想要仅仅构建完整反应堆中的某些个模块, 换句话说, 需要实时地 <strong>裁剪反应堆</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Maven提供很多的命令行选项支持裁剪反应堆, 输入mvn-h可以看到这些选项</span></span><br><span class="line">λ mvn <span class="literal">-h</span></span><br><span class="line"></span><br><span class="line">usage: mvn [<span class="type">options</span>] [&lt;<span class="type">goal</span>(<span class="type">s</span>)&gt;] [&lt;<span class="type">phase</span>(<span class="type">s</span>)&gt;]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line"><span class="comment"># 同时构建所列模块的依赖模块</span></span><br><span class="line"> <span class="literal">-am</span>,-<span class="literal">-also</span><span class="literal">-make</span>                        <span class="keyword">If</span> project list is specified, also</span><br><span class="line">                                        build projects required by the</span><br><span class="line">                                        list</span><br><span class="line"><span class="comment"># 同时构建依赖于所列模块的模块</span></span><br><span class="line"> <span class="literal">-amd</span>,-<span class="literal">-also</span><span class="literal">-make</span><span class="literal">-dependents</span>            <span class="keyword">If</span> project list is specified, also</span><br><span class="line">                                        build projects that depend on</span><br><span class="line">                                        projects on the list</span><br><span class="line"><span class="comment"># 构建指定的模块, 模块间用逗号分隔</span></span><br><span class="line"> <span class="literal">-pl</span>,-<span class="literal">-projects</span> &lt;arg&gt;                   Comma<span class="literal">-delimited</span> list of specified</span><br><span class="line">                                        reactor projects to build instead</span><br><span class="line">                                        of all projects. A project can be</span><br><span class="line">                                        specified by [<span class="type">groupId</span>]:artifactId</span><br><span class="line">                                        or by its relative path</span><br><span class="line"><span class="comment"># 从指定的模块回复反应堆</span></span><br><span class="line"> <span class="literal">-rf</span>,-<span class="literal">-resume</span><span class="literal">-from</span> &lt;arg&gt;                Resume reactor from specified</span><br><span class="line">                                        project</span><br></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用-am选项可以同时构建所列模块的依赖模块, 例如:</span></span><br><span class="line">λ mvn clean compile <span class="literal">-pl</span> project<span class="literal">-child</span><span class="literal">-a</span> <span class="literal">-am</span></span><br></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用-rf选项可以在完整的反应堆构建顺序基础上指定从哪个模块开始构建</span></span><br><span class="line">λ mvn clean compile <span class="literal">-rf</span> project<span class="literal">-child</span><span class="literal">-a</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在开发过程中, 灵活应用上述 4 个参数, 可以帮助我们跳过无须构建的模块, 从而加速构建, 在项目庞大, 模块特别多的时候, 这种效果就会异常明显</p>
</blockquote>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven 005 仓库</title>
    <url>/2018/09/08/maven/005/</url>
    <content><![CDATA[<h1 id="仓库">仓库</h1>
<h2 id="maven-仓库">Maven 仓库</h2>
<p>在 Maven 世界中, 任何一个依赖, 插件或者项目构建的输出, 都可以称为 <strong>构件</strong>, 任何一个构件都有一组坐标唯一标识</p>
<p>得益于坐标机制, 任何 Maven 项目使用任何一个构件的方式都是完全相同的, 在此基础上, Maven 可以在某个位置统一存储所有 Maven 项目共享的构件, 这个统一的位置就是 <strong>仓库</strong>, 实际的 Maven 项目将不再各自存储其依赖文件, 它们只需要声明这些依赖的坐标, 在需要的时候 (例如, 编译项目的时候需要将依赖加入到 <code>classpath</code> 中), Maven 会自动根据坐标找到仓库中的构件, 并使用它们, 为了实现重用, 项目构建完毕后生成的构件也可以安装或者部署到仓库中, 供其他项目使用</p>
<h2 id="仓库的布局">仓库的布局</h2>
<p>任何一个构件都有其唯一的坐标, 根据这个坐标可以定义其在仓库中的唯一存储路径, 这便是 Maven 的 <strong>仓库布局</strong> 方式, 例如 <code>log4j:log4j:1.2.15</code> 这一依赖, 其对应的仓库路径为 <code>log4j/log4j/1.2.15/log4j-1.2.15.jar</code>, 该路径与坐标的大致对应关系为 <code>groupId/artifactId/version/artifactId-version.packaging</code></p>
<blockquote>
<p>Maven 仓库是基于简单文件系统存储的, 我们也理解了其存储方式, 因此, 当遇到一些与仓库相关的问题时, 可以很方便地查找相关文件, 方便定位问题</p>
</blockquote>
<h2 id="仓库的分类">仓库的分类</h2>
<p>对于 Maven 来说, 仓库只分为两类: <strong>本地仓库</strong> 和 <strong>远程仓库</strong></p>
<p>当 Maven 根据坐标寻找构件的时候, 它首先会查看本地仓库, 如果本地仓库存在此构件, 则直接使用, 如果本地仓库不存在此构件, 或者需要查看是否有更新的构件版本, Maven 就会去远程仓库查找, 发现需要的构件之后, 下载到本地仓库再使用, 如果本地仓库和远程仓库都没有需要的构件, Maven 就会报错</p>
<p><strong>中央仓库</strong> 是 Maven 核心自带的远程仓库, 它包含了绝大部分开源的构件, 在默认配置下, 当本地仓库没有 Maven 需要的构件的时候, 它就会尝试从中央仓库下载</p>
<p><strong>私服</strong> 是另一种特殊的远程仓库, 为了节省带宽和时间, 应该在局域网内架设一个私有的仓库服务器, 用其代理所有外部的远程仓库, 内部的项目还能部署到私服上供其他项目使用</p>
<p>除了中央仓库和私服, 还有很多其他公开的远程仓库, 常见的有 <a href="http://download.java.net/maven/2/">Java.net Maven 库</a> 和 <a href="http://repository.jboss.com/maven2/">JBoss Maven 库</a> 等</p>
<pre class="mermaid">graph TB
title["图 Maven仓库的分类"]
E --> title
style title fill:#FFF,stroke:#FFF
linkStyle 0 stroke:#FFF,stroke-width:0;
A(Maven仓库)
B(本地仓库)
C(远程仓库)
D(中央仓库)
E(私服)
F(其他公共库)
A --- B
A --- C
C --- D
C --- E
C --- F</pre>
<h3 id="本地仓库">本地仓库</h3>
<p>当 Maven 在执行编译或测试时, 如果需要使用依赖文件, 它总是基于坐标使用 <strong>本地仓库</strong> 的依赖文件</p>
<p>默认情况下, 不管是在 Windows 还是 Linux 上, 每个用户在自己的用户目录下都有一个路径名为 <code>.m2/repository/</code> 的仓库 目录, 可以编辑文件 <code>~/.m2/settings.xml</code>, 设置 <code>localRepository</code> 元素的值为想要的仓库地址</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 自定义本地仓库目录地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:\maven\repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="远程仓库">远程仓库</h3>
<p>安装好 Maven 后, 如果不执行任何 Maven 命令, 本地仓库目录是不存在的, 当用户输入第一条 Maven 命令之后, Maven 才会创建本地仓库, 然后根据配置和需要, 从 <strong>远程仓库</strong> 下载构件至本地仓库, 对于 Maven 来说, 每个用户只有一个本地仓库, 但可以配置访问很多远程仓库</p>
<h3 id="中央仓库">中央仓库</h3>
<p>由于最原始的本地仓库是空的, Maven 必须知道至少一个可用的远程仓库, 才能在执行 Maven 命令的时候下载到需要的构件, <strong>中央仓库</strong> 就是这样一个默认的远程仓库, Maven 的安装文件自带了中央仓库的配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用解压工具打开$M2_HOME/lib/maven-model-builder-3.5.4.jar --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 访问org/apache/maven/model/pom-4.0.0.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Central Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.maven.apache.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 对于Maven1的仓库, 需要配置值为legacy的layout --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 不从该中央仓库下载快照版本的构件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 包含这段配置的文件是所有Maven项目都会继承的超级POM --&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="私服">私服</h3>
<p><strong>私服</strong> 是一种特殊的远程仓库, 它是架设在局域网内的仓库服务, 私服代理广域网上的远程仓库, 供局域网内的 Maven 用户使用, 当 Maven 需要下载构件的时候, 它从私服请求, 如果私服上不存在该构件, 则从外部的远程仓库下载, 缓存在私服上之后, 再为 Maven 的下载请求提供服务, 此外, 一些无法从外部仓库下载到的构件也能从本地上传到私服上供大家使用</p>
<pre class="mermaid">graph BT
title["图 私服的用途图"]
title --> D
style title fill:#FFF,stroke:#FFF
linkStyle 0 stroke:#FFF,stroke-width:0;
A(Maven用户)
B(Maven用户)
C(私服)
D(中央仓库)
D -->|缓存构件| C
subgraph 局域网
C -->|下载构件| A
A -->|上传构件| C
C -->|下载构件| B
end</pre>
<p>即使在一台直接连入 Internet 的个人机器上使用 Maven, 也应该在本地建立私服, 因为私服可以帮助你:</p>
<ul>
<li><strong>节省自己的外网带宽</strong> 建立私服同样可以减少组织自己的开支, 大量的对于外部仓库的重复请求会消耗很大的带宽, 利用私服代理外部仓库之后, 对外的重复构件下载便得以消除, 即降低外网带宽的压力;</li>
<li><strong>加速 Maven 构建</strong> 不停地连接请求外部仓库是十分耗时的, 但是 Maven 的一些内部机制 (如快照更新检查) 要求 Maven 在执行构建的时候不停地检查远程仓库数据, 因此, 当项目配置了很多外部远程仓库的时候, 构建的速度会被大大降低, 使用私服可以很好地解决这一问题, 当 Maven 只需要检查局域网内私服的数据时, 构建的速度便能得到很大程度的提高;</li>
<li><strong>部署第三方构件</strong> 当某个构件无法从任何一个外部远程仓库获得, 如组织内部生成的私有构件肯定无法从外部仓库获得, Oracle 的 JDBC 驱动由于版权因素不能发布到公共仓库中, 建立私服之后, 便可以将这些构件部署到这个内部的仓库中, 供内部的 Maven 项目使用;</li>
<li><strong>提高稳定性, 增强控制</strong> Maven 构建高度依赖于远程仓库, 因此, 当 Internet 不稳定的时候, Maven 构建也会变得不稳定, 甚至无法构建, 使用私服后, 即使暂时没有 Internet 连接, 由于私服中已经缓存了大量构件, Maven 也仍然可以正常运行, 此外, 一些私服软件 (如 Nexus) 还提供了很多额外的功能, 如权限管理, <code>RELEASE/SNAPSHOT</code> 区分等, 管理员可以对仓库进行一些更高级的控制;</li>
<li><strong>降低中央仓库的负荷</strong> 运行并维护一个中央仓库不是一件容易的事情, 服务数百万的请求, 存储数 T 的数据, 需要相当大的财力, 使用私服可以避免很多对中央仓库重复的下载</li>
</ul>
<h2 id="远程仓库的配置">远程仓库的配置</h2>
<p>在很多情况下, 默认的中央仓库无法满足项目的需求, 可能项目需要的构件存在于另外一个远程仓库中, 如 JBoss Maven 仓库, 这时, 可以在 <code>POM</code> 中配置该仓库</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置POM使用JBoss Maven仓库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在repositories元素下, 可以使用repository子元素声明一个或者多个远程仓库 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>jboss<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>JBoss Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repository.jboss.com/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 对于releases和snapshots, 它们还包含另外两个子元素updatePolicy和checksumPolicy --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>daily<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">checksumPolicy</span>&gt;</span>ignore<span class="tag">&lt;/<span class="name">checksumPolicy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 元素updatePolicy用来配置Maven从远程仓库检查更新的频率</span></span><br><span class="line"><span class="comment">    daily(默认值) 表示Maven每天检查一次</span></span><br><span class="line"><span class="comment">    never 从不检查更新</span></span><br><span class="line"><span class="comment">    always 每次构建都检查更新</span></span><br><span class="line"><span class="comment">    interval:X 每隔X分钟检查一次更新(X为任意整数)</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 元素checksumPolicy用来配置Maven检查检验和文件的策略, 当构件被部署到Maven仓库中时, 会同时部署对应的校验和文件, 在下载构件的时候, Maven会验证校验和文件</span></span><br><span class="line"><span class="comment">    warn(默认值) Maven会在执行构建时输出警告信息</span></span><br><span class="line"><span class="comment">    fail Maven遇到校验和错误就让构建失败</span></span><br><span class="line"><span class="comment">    ignore 使Maven完全忽略校验和错误</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>任何一个仓库声明的 <code>id</code> 必须是唯一的, 尤其需要注意的是, Maven 自带的中央仓库使用的 <code>id</code> 为 <code>central</code>, 如果其他的仓库声明也使用该 <code>id</code>, 就会覆盖中央仓库的配置</p>
</blockquote>
<h3 id="远程仓库的认证">远程仓库的认证</h3>
<p>大部分远程仓库无须认证就可以访问, 但有时候出于安全方面的考虑, 我们需要提供认证信息才能访问一些远程仓库</p>
<blockquote>
<p>配置认证信息和配置仓库信息不同, 仓库信息可以直接配置在 <code>POM</code> 文件中, 但是认证信息必须配置在 <code>settings.xml</code> 文件中, 这是因为 <code>POM</code> 往往是被提交到代码仓库中供所有成员访问的, 而 <code>settings.xml</code> 一般只放在本机, 因此, 在 <code>settings.xml</code> 中配置认证信息更为安全</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在settings.xml中配置仓库认证信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 这里的关键是id元素, settings.xml中server元素的id必须与POM中需要认证的repository元素的id完全一致, 换句话说, 正是这个id将认证信息与仓库配置联系在了一起 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>my-proj<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">username</span>&gt;</span>repo-user<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">password</span>&gt;</span>repo-pwd<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="部署至远程仓库">部署至远程仓库</h3>
<p>私服的一大作用是部署第三方构件, 包括组织内部生成的构件以及一些无法从外部仓库直接获取的构件, 无论是日常开发中生成的构件, 还是正式版本发布的构件, 都需要部署到仓库中, 供其他团队成员使用</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在POM中配置构件部署地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- distributionManagement包含repository和snapshotRepository子元素, 前者表示发布版本构件的仓库, 后者表示快照版本的仓库 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>proj-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Proj Release Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.1.100/content/repositories/proj-releases<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>proj-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Proj Snapshot Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.1.100/content/repositories/proj-snapshots<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置正确后, 在命令行运行mvn clean deploy, Maven 就会将项目构建输出的构件部署到配置对应的远程仓库, 如果项目当前的版本是快照版本, 则部署到快照版本仓库地址, 否则就部署到发布版本仓库地址</span></span><br><span class="line">λ mvn clean deploy</span><br></pre></td></tr></table></figure>
<h3 id="快照版本">快照版本</h3>
<p><strong>快照版本</strong> 只应该在组织内部的项目或模块间依赖使用, 因为这时, 组织对于这些快照版本的依赖具有完全的理解及控制权, 项目不应该依赖于任何组织外部的快照版本依赖, 由于快照版本的不稳定性, 这样的依赖会造成潜在的危险, 也就是说, 即使项目构建今天是成功的, 由于外部的快照版本依赖实际对应的构件随时可能变化, 项目的构建就可能由于这些外部的不受控制的因素而失败</p>
<h2 id="从仓库解析依赖的机制">从仓库解析依赖的机制</h2>
<p>当本地仓库没有依赖构件的时候, Maven 会自动从远程仓库下载, 当依赖版本为快照版本的时候, Maven 会自动找到最新的快照, 这背后的依赖解析机制可以概括如下:</p>
<ol type="1">
<li>当依赖的范围是 <code>system</code> 的时候, Maven 直接从本地文件系统解析构件;</li>
<li>根据依赖坐标计算仓库路径后, 尝试直接从本地仓库寻找构件, 如果发现相应构件, 则解析成功;</li>
<li>在本地仓库不存在相应构件的情况下, 如果依赖的版本是显式的发布版本构件, 如 <code>1.2</code>, <code>2.1-beta-1</code> 等, 则遍历所有的远程仓库, 发现后下载并解析使用;</li>
<li>如果依赖的版本是 <code>RELEASE</code> 或者 <code>LATEST</code>, 则基于更新策略读取所有远程仓库的元数据 <code>groupId/artifactId/maven-metadata.xml</code>, 将其与本地仓库的对应元数据合并后, 计算出 <code>RELEASE</code> 或者 <code>LATEST</code> 真实的值, 然后基于这个真实的值检查本地和远程仓库, 如步骤 2 和 3;</li>
<li>如果依赖的版本是 <code>SNAPSHOT</code>, 则基于更新策略读取所有远程仓库的元数据 <code>groupId/artifactId/version/maven-metadata.xml</code>, 将其与本地仓库的对应元数据合并后, 得到最新快照版本的值, 然后基于该值检查本地仓库, 或者从远程仓库下载;</li>
<li>如果最后解析得到的构件版本是时间戳格式的快照, 如 <code>1.4.1-20091104.121450-121</code>, 则复制其时间戳格式的文件至非时间戳格式, 如 <code>SNAPSHOT</code>, 并使用该非时间戳格式的构件</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 基于groupId和artifactId的maven-metadata.xml --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">metadata</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.sonatype.nexus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">versioning</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- latest元素指向了这些版本中最新的那个版本 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">latest</span>&gt;</span>1.4.2-SNAPSHOT<span class="tag">&lt;/<span class="name">latest</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- release元素指向了这些版本中最新的发布版本 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">release</span>&gt;</span>1.4.0<span class="tag">&lt;/<span class="name">release</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">versions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.2-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">versions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">lastUpdated</span>&gt;</span>20091214221557<span class="tag">&lt;/<span class="name">lastUpdated</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">versioning</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">metadata</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 基于groupId、artifactId和version的maven-metadata.xml --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">metadata</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.sonatype.nexus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.2-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">versioning</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshot</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 快照的时间戳 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timestamp</span>&gt;</span>20091214.221414<span class="tag">&lt;/<span class="name">timestamp</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 快照的构建号 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">buildNumber</span>&gt;</span>13<span class="tag">&lt;/<span class="name">buildNumber</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">lastUpdated</span>&gt;</span>20091214221558<span class="tag">&lt;/<span class="name">lastUpdated</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">versioning</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">metadata</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>仓库元数据并不是永远正确的, 有时候当用户发现无法解析某些构件, 或者解析得到错误构件的时候, 就有可能是出现了仓库元数据错误, 这时就需要手工地, 或者使用工具 (如 Nexus) 对其进行修复</p>
</blockquote>
<h2 id="镜像">镜像</h2>
<p>如果仓库 X 可以提供仓库 Y 存储的所有内容, 那么就可以认为 X 是 Y 的一个 <strong>镜像</strong>, 换句话说, 任何一个可以从仓库 Y 获得的构件, 都能够从它的镜像中获取</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置中央仓库镜像 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- http://maven.net.cn/content/groups/public/是中央仓库在中国的镜像 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven.net.cn<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>one of the central mirrors in China<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.net.cn/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 该例中, mirrorOf的值为central, 表示该配置为中央仓库的镜像, 任何对于中央仓库的请求都会转至该镜像 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>由于私服可以代理任何外部的公共仓库 (包括中央仓库), 因此, 对于组织内部的 Maven 用户来说, 使用一个私服地址就等于使用了所有需要的外部仓库, 这可以将配置集中到私服, 从而简化 Maven 本身的配置, 在这种情况下, 任何需要的构件都可以从私服获得, 私服就是所有仓库的镜像</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置使用私服作为镜像 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>internal-repository<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Internal Repository Manager<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.1.100/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- mirrorOf的值为星号, 表示该配置是所有Maven仓库的镜像, 任何对于远程仓库的请求都会被转至私服 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>为了满足一些复杂的需求, Maven 还支持更高级的镜像配置:</p>
<ul>
<li><strong><code>&lt;mirrorOf&gt;*&lt;/mirrorOf&gt;</code></strong> 匹配所有远程仓库;</li>
<li><strong><code>&lt;mirrorOf&gt;external:*&lt;/mirrorOf&gt;</code></strong> 匹配所有远程仓库, 使用 <code>localhost</code> 的除外, 使用 <code>file://</code> 协议的除外, 也就是说, 匹配所有不在本机上的远程仓库;</li>
<li><strong><code>&lt;mirrorOf&gt;repo1,repo2&lt;/mirrorOf&gt;</code></strong> 匹配仓库 <code>repo1</code> 和 <code>repo2</code>, 使用逗号分隔多个远程仓库;</li>
<li><strong><code>&lt;mirrorOf&gt;*,!repo1&lt;/mirrorOf&gt;</code></strong> 匹配所有远程仓库, <code>repo1</code> 除外, 使用感叹号将仓库从匹配中排除</li>
</ul>
<blockquote>
<p>需要注意的是, 由于镜像仓库完全屏蔽了被镜像仓库, 当镜像仓库不稳定或者停止服务的时候, Maven 仍将无法访问被镜像仓库, 因而将无法下载构件</p>
</blockquote>
<h2 id="仓库搜索服务">仓库搜索服务</h2>
<p>使用 Maven 进行日常开发的时候, 一个常见的问题就是如何寻找需要的依赖, 我们可能只知道需要使用类库的项目名称, 但添加 Maven 依赖要求提供确切的 Maven 坐标, 这时, 就可以使用 <strong>仓库搜索服务</strong> 来根据关键字得到 Maven 坐标</p>
<p><a href="http://repository.sonatype.org/">Sonatype Nexus</a> <a href="">Jarvana</a> <a href="">MVNbrowser</a> <a href="http://mvnrepository.com/">MVNrepository</a></p>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven 002 入门</title>
    <url>/2018/09/01/maven/002/</url>
    <content><![CDATA[<h1 id="maven-入门">Maven 入门</h1>
<h2 id="编写-pom">编写 POM</h2>
<p><strong>POM (Project Object Model, 项目对象模型)</strong> 定义了项目的基本信息, 用于描述项目如何构建, 声明项目依赖, 等等</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- project是所有pom.xml的根元素, 它还声明了一些POM相关的命名空间及xsd元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 根元素下的第一个子元素modelVersion指定了当前POM模型的版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- groupId定义了项目属于哪个组, 这个组往往和项目所在的组织或公司存在关联 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.janz.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- artifactId定义了当前Maven项目在组中唯一的ID --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hello-world<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- version指定了Hello World项目当前的版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- name元素声明了一个对于用户更为友好的项目名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hello-world<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 添加了dependencies元素, 该元素下可以包含多个dependency元素以声明项目的依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 添加JUnit依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- scope为依赖范围, 默认值compile, 表示该依赖对主代码和测试代码都有效, 若依赖范围为test则表示该依赖只对测试有效 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>没有任何实际的 Java 代码, 就能够定义一个 Maven 项目的 <code>POM</code>, 这体现了 Maven 的一大优点, 它能让项目对象模型最大程度地与实际代码相独立, 可以称之为解耦, 或者正交性, 这在很大程度上避免了 Java 代码和 <code>POM</code> 代码的相互影响, 比如当项目需要升级版本时, 只需要修改 <code>POM</code>, 而不需要更改 Java 代码, 而在 <code>POM</code> 稳定之后, 日常的 Java 代码开发工作基本不涉及 <code>POM</code> 的修改</p>
</blockquote>
<h2 id="编写主代码">编写主代码</h2>
<p>默认情况下, Maven 假设项目主代码位于 <code>src/main/java</code> 目录</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.janz.maven;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Hello Maven&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="keyword">new</span> HelloWorld().sayHello());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于该 Java 代码有两点需要注意:</p>
<ul>
<li>在绝大多数情况下, 应该把项目主代码放到 <code>src/main/java/</code> 目录下 (遵循 Maven 的约定), 而无须额外的配置, Maven 会自动搜寻该目录找到项目主代码;</li>
<li>该 Java 类的包名是 <code>com.janz.maven</code>, 这与之前在 <code>POM</code> 中定义的 <code>groupId</code> 和 <code>artifactId</code> 相吻合, 一般来说, 项目中 Java 类的包都应该基于项目的 <code>groupId</code> 和 <code>artifactId</code>, 这样更加清晰, 更加符合逻辑, 也方便搜索构件或者 Java 类</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码编写完毕后, 使用Maven进行编译</span></span><br><span class="line">λ mvn clean compile</span><br><span class="line">[<span class="type">INFO</span>] Scanning <span class="keyword">for</span> projects...</span><br><span class="line">[<span class="type">INFO</span>]</span><br><span class="line">[<span class="type">INFO</span>] ---------------------&lt; com.janz.maven:hello<span class="literal">-world</span> &gt;---------------------</span><br><span class="line">[<span class="type">INFO</span>] Building hello<span class="literal">-world</span> <span class="number">1.0</span><span class="literal">-SNAPSHOT</span></span><br><span class="line">[<span class="type">INFO</span>] --------------------------------[ <span class="type">jar</span> ]---------------------------------</span><br><span class="line">[<span class="type">INFO</span>]</span><br><span class="line">[<span class="type">INFO</span>] --- maven<span class="literal">-clean</span><span class="literal">-plugin</span>:<span class="number">2.5</span>:clean (default<span class="literal">-clean</span>) <span class="selector-tag">@</span> hello<span class="literal">-world</span> ---</span><br><span class="line">[<span class="type">INFO</span>] Deleting D:\code\<span class="number">02</span>\hello<span class="literal">-world</span>\target</span><br><span class="line">[<span class="type">INFO</span>]</span><br><span class="line">[<span class="type">INFO</span>] --- maven<span class="literal">-resources</span><span class="literal">-plugin</span>:<span class="number">2.6</span>:resources (default<span class="literal">-resources</span>) <span class="selector-tag">@</span> hello<span class="literal">-world</span> ---</span><br><span class="line">[<span class="type">INFO</span>] <span class="keyword">Using</span> <span class="string">&#x27;UTF-8&#x27;</span> encoding to copy filtered resources.</span><br><span class="line">[<span class="type">INFO</span>] skip non existing resourceDirectory D:\code\<span class="number">02</span>\hello<span class="literal">-world</span>\src\main\resources</span><br><span class="line">[<span class="type">INFO</span>]</span><br><span class="line">[<span class="type">INFO</span>] --- maven<span class="literal">-compiler</span><span class="literal">-plugin</span>:<span class="number">3.1</span>:compile (default<span class="literal">-compile</span>) <span class="selector-tag">@</span> hello<span class="literal">-world</span> ---</span><br><span class="line">[<span class="type">INFO</span>] Changes detected - recompiling the module!</span><br><span class="line">[<span class="type">INFO</span>] Compiling <span class="number">1</span> source file to D:\code\<span class="number">02</span>\hello<span class="literal">-world</span>\target\classes</span><br><span class="line">[<span class="type">INFO</span>] ------------------------------------------------------------------------</span><br><span class="line">[<span class="type">INFO</span>] BUILD SUCCESS</span><br><span class="line">[<span class="type">INFO</span>] ------------------------------------------------------------------------</span><br><span class="line">[<span class="type">INFO</span>] Total time: <span class="number">0.926</span> s</span><br><span class="line">[<span class="type">INFO</span>] Finished at: <span class="number">2019</span><span class="literal">-02</span><span class="literal">-18T10</span>:<span class="number">18</span>:<span class="number">16</span>+<span class="number">08</span>:<span class="number">00</span></span><br><span class="line">[<span class="type">INFO</span>] ------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment"># clean告诉Maven清理输出目录target/</span></span><br><span class="line"><span class="comment"># compile告诉Maven编译项目主代码</span></span><br><span class="line"><span class="comment"># 从输出中看到Maven首先执行了clean:clean任务, 删除target/目录, 默认情况下, Maven构建的所有输出都在target/目录中</span></span><br><span class="line"><span class="comment"># 接着执行resources:resources任务(未定义项目资源, 暂且略过)</span></span><br><span class="line"><span class="comment"># 最后执行compiler:compile任务, 将项目主代码编译至target/classes目录(编译好的类为com\janz\maven\HelloWorld.Class)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>旧版本的 Maven 的核心插件 <code>compiler</code> 默认只支持编译 Java 1.3, 因此需要配置该插件使其支持 Java 5</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 旧版本需要配置maven-compiler-plugin支持Java 5 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.5<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.5<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="编写测试代码">编写测试代码</h2>
<p>项目主代码和测试代码不同, 项目的主代码会被打包到最终的构件中 (如 <code>jar</code>), 而测试代码只在运行测试时用到, 不会被打包</p>
<p>为了使项目结构保持清晰, 主代码与测试代码应该分别位于独立的目录中, Maven 项目中默认的测试代码目录是 <code>src/test/java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.janz.maven;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 准备测试类及数据</span></span><br><span class="line">		HelloWorld helloWorld = <span class="keyword">new</span> HelloWorld();</span><br><span class="line">        <span class="comment">// 执行要测试的行为</span></span><br><span class="line">		String result = helloWorld.sayHello();</span><br><span class="line">        <span class="comment">// 检查结果</span></span><br><span class="line">		Assert.assertEquals(result, <span class="string">&quot;Hello Maven&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试用例编写完毕之后就可以调用Maven执行测试</span></span><br><span class="line">λ mvn clean test</span><br><span class="line">[<span class="type">INFO</span>] Scanning <span class="keyword">for</span> projects...</span><br><span class="line">[<span class="type">INFO</span>]</span><br><span class="line">[<span class="type">INFO</span>] ---------------------&lt; com.janz.maven:hello<span class="literal">-world</span> &gt;---------------------</span><br><span class="line">[<span class="type">INFO</span>] Building hello<span class="literal">-world</span> <span class="number">1.0</span><span class="literal">-SNAPSHOT</span></span><br><span class="line">[<span class="type">INFO</span>] --------------------------------[ <span class="type">jar</span> ]---------------------------------</span><br><span class="line">[<span class="type">INFO</span>]</span><br><span class="line">[<span class="type">INFO</span>] --- maven<span class="literal">-clean</span><span class="literal">-plugin</span>:<span class="number">2.5</span>:clean (default<span class="literal">-clean</span>) <span class="selector-tag">@</span> hello<span class="literal">-world</span> ---</span><br><span class="line">[<span class="type">INFO</span>] Deleting D:\code\<span class="number">02</span>\hello<span class="literal">-world</span>\target</span><br><span class="line">[<span class="type">INFO</span>]</span><br><span class="line">[<span class="type">INFO</span>] --- maven<span class="literal">-resources</span><span class="literal">-plugin</span>:<span class="number">2.6</span>:resources (default<span class="literal">-resources</span>) <span class="selector-tag">@</span> hello<span class="literal">-world</span> ---</span><br><span class="line">[<span class="type">INFO</span>] <span class="keyword">Using</span> <span class="string">&#x27;UTF-8&#x27;</span> encoding to copy filtered resources.</span><br><span class="line">[<span class="type">INFO</span>] skip non existing resourceDirectory D:\code\<span class="number">02</span>\hello<span class="literal">-world</span>\src\main\resources</span><br><span class="line">[<span class="type">INFO</span>]</span><br><span class="line">[<span class="type">INFO</span>] --- maven<span class="literal">-compiler</span><span class="literal">-plugin</span>:<span class="number">3.1</span>:compile (default<span class="literal">-compile</span>) <span class="selector-tag">@</span> hello<span class="literal">-world</span> ---</span><br><span class="line">[<span class="type">INFO</span>] Changes detected - recompiling the module!</span><br><span class="line">[<span class="type">INFO</span>] Compiling <span class="number">1</span> source file to D:\code\<span class="number">02</span>\hello<span class="literal">-world</span>\target\classes</span><br><span class="line">[<span class="type">INFO</span>]</span><br><span class="line">[<span class="type">INFO</span>] --- maven<span class="literal">-resources</span><span class="literal">-plugin</span>:<span class="number">2.6</span>:testResources (default<span class="literal">-testResources</span>) <span class="selector-tag">@</span> hello<span class="literal">-world</span> ---</span><br><span class="line">[<span class="type">INFO</span>] <span class="keyword">Using</span> <span class="string">&#x27;UTF-8&#x27;</span> encoding to copy filtered resources.</span><br><span class="line">[<span class="type">INFO</span>] skip non existing resourceDirectory D:\code\<span class="number">02</span>\hello<span class="literal">-world</span>\src\test\resources</span><br><span class="line">[<span class="type">INFO</span>]</span><br><span class="line">[<span class="type">INFO</span>] --- maven<span class="literal">-compiler</span><span class="literal">-plugin</span>:<span class="number">3.1</span>:testCompile (default<span class="literal">-testCompile</span>) <span class="selector-tag">@</span> hello<span class="literal">-world</span> ---</span><br><span class="line">[<span class="type">INFO</span>] Changes detected - recompiling the module!</span><br><span class="line">[<span class="type">INFO</span>] Compiling <span class="number">1</span> source file to D:\code\<span class="number">02</span>\hello<span class="literal">-world</span>\target\<span class="built_in">test-classes</span></span><br><span class="line">[<span class="type">INFO</span>]</span><br><span class="line">[<span class="type">INFO</span>] --- maven<span class="literal">-surefire</span><span class="literal">-plugin</span>:<span class="number">2.12</span>.<span class="number">4</span>:test (default<span class="literal">-test</span>) <span class="selector-tag">@</span> hello<span class="literal">-world</span> ---</span><br><span class="line">[<span class="type">INFO</span>] Surefire report directory: D:\code\<span class="number">02</span>\hello<span class="literal">-world</span>\target\surefire<span class="literal">-reports</span></span><br><span class="line"></span><br><span class="line">-------------------------------------------------------</span><br><span class="line"> T E S T S</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">Running com.janz.maven.HelloWorldTest</span><br><span class="line">Tests run: <span class="number">1</span>, Failures: <span class="number">0</span>, Errors: <span class="number">0</span>, Skipped: <span class="number">0</span>, Time elapsed: <span class="number">0.045</span> sec</span><br><span class="line"></span><br><span class="line">Results :</span><br><span class="line"></span><br><span class="line">Tests run: <span class="number">1</span>, Failures: <span class="number">0</span>, Errors: <span class="number">0</span>, Skipped: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">[<span class="type">INFO</span>] ------------------------------------------------------------------------</span><br><span class="line">[<span class="type">INFO</span>] BUILD SUCCESS</span><br><span class="line">[<span class="type">INFO</span>] ------------------------------------------------------------------------</span><br><span class="line">[<span class="type">INFO</span>] Total time: <span class="number">1.535</span> s</span><br><span class="line">[<span class="type">INFO</span>] Finished at: <span class="number">2019</span><span class="literal">-02</span><span class="literal">-18T10</span>:<span class="number">27</span>:<span class="number">27</span>+<span class="number">08</span>:<span class="number">00</span></span><br><span class="line">[<span class="type">INFO</span>] ------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment"># surefire:test任务运行测试, surefire是Maven中负责执行测试的插件, 这里它运行测试用例HelloWorldTest, 并且输出测试报告, 显示一共运行了多少测试, 失败了多少, 出错了多少, 跳过了多少</span></span><br></pre></td></tr></table></figure>
<h2 id="常用命令">常用命令</h2>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">λ mvn clean</span><br><span class="line"><span class="comment"># 清理项目, 删除target文件夹</span></span><br><span class="line"></span><br><span class="line">λ mvn compile</span><br><span class="line"><span class="comment"># 编译项目, 不会编译测试项目</span></span><br><span class="line"></span><br><span class="line">λ mvn <span class="built_in">test-compile</span></span><br><span class="line"><span class="comment"># 编译测试项目, 会先编译主项目</span></span><br><span class="line"></span><br><span class="line">λ mvn test</span><br><span class="line"><span class="comment"># 运行测试项目</span></span><br><span class="line"></span><br><span class="line">λ mvn site</span><br><span class="line"><span class="comment"># 生成报告, 需配置</span></span><br><span class="line"></span><br><span class="line">λ mvn package</span><br><span class="line"><span class="comment"># 打包项目, 默认jar, 不包含源码</span></span><br><span class="line"><span class="comment"># jar:jar任务负责打包, 实际上就是jar插件的jar目标将项目主代码打包成一个名为hello-world-1.0-SNAPSHOT.jar的文件, 该文件也位于target/输出目录中, 它是根据artifact-version.jar规则进行命名的, 如有需要, 还可以使用finalName来自定义该文件的名称</span></span><br><span class="line"></span><br><span class="line">λ mvn source:jar</span><br><span class="line">λ mvn source:jar<span class="literal">-no</span><span class="literal">-fork</span></span><br><span class="line"><span class="comment"># 打包源码, 会根据artifact-version-sources.jar规则生成源码jar包</span></span><br><span class="line"><span class="comment"># 优先使用jar-no-fork</span></span><br><span class="line"></span><br><span class="line">λ mvn install</span><br><span class="line"><span class="comment"># 安装到本地仓库</span></span><br><span class="line"></span><br><span class="line">λ mvn deploy</span><br><span class="line"><span class="comment"># 发布到远程私服</span></span><br><span class="line"></span><br><span class="line">λ mvn archetype:generate</span><br><span class="line">λ mvn archetype:generate <span class="literal">-DarchetypeCatalog</span>=internal</span><br><span class="line"><span class="comment"># 运行生成项目模板, -DarchetypeCatalog=internal指定只使用archetype内置的catalog</span></span><br></pre></td></tr></table></figure>
<h3 id="其他命令">其他命令</h3>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">λ mvn eclipse:eclipse</span><br><span class="line"><span class="comment"># 生成eclipse项目的配置文件</span></span><br><span class="line"></span><br><span class="line">λ mvn eclipse:clean</span><br><span class="line"><span class="comment"># 清除eclipse项目的配置文件</span></span><br><span class="line"></span><br><span class="line">λ mvn cargo:run</span><br><span class="line">λ mvn cargo:<span class="built_in">start</span></span><br><span class="line"><span class="comment"># 运行cargo指定的容器</span></span><br><span class="line"></span><br><span class="line">λ mvn cargo:deploy</span><br><span class="line"><span class="comment"># 将项目war包发布到cargo指定的容器</span></span><br></pre></td></tr></table></figure>
<h2 id="运行">运行</h2>
<p>默认打包生成的 <code>jar</code> 是不能够直接运行的, 因为带有 <code>main</code> 方法的类信息不会添加到 <code>manifest</code> 中 (打开 <code>jar</code> 文件中的 <code>META-INF/MANIFEST.MF</code> 文件, 将无法看到 <code>Main-Class</code> 一行)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 为了生成可执行的jar文件, 需要借助maven-shade-plugin, 配置该插件如下 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span><span class="tag">&lt;<span class="name">plugins</span>&gt;</span><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">transformers</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">transformer</span> <span class="attr">implementation</span>=<span class="string">&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 配置mainClass, 项目在打包时会将该信息放到MANIFEST中 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.janz.maven.HelloWorld<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">transformer</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">transformers</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重新打包项目</span></span><br><span class="line">λ mvn clean package</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建完成之后打开target/目录, 可以看到hello-world-1.0-SNAPSHOT.jar和original-hello-world-1.0-SNAPSHOT.jar, 前者是带有Main-Class信息的可运行jar, 后者是原始的jar</span></span><br></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在项目根目录中执行jar文件</span></span><br><span class="line">λ java <span class="literal">-jar</span> target\hello<span class="literal">-world</span><span class="literal">-1</span>.<span class="number">0</span><span class="literal">-SNAPSHOT</span>.jar</span><br><span class="line">Hello Maven</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven 003 坐标和依赖</title>
    <url>/2018/09/04/maven/003/</url>
    <content><![CDATA[<h1 id="坐标和依赖">坐标和依赖</h1>
<h2 id="maven-坐标">Maven 坐标</h2>
<p>Maven 定义了这样一组规则, 世界上任何一个构件都可以使用 <strong>Maven 坐标</strong> 唯一标识, Maven 坐标的元素包括<code>groupId</code>, <code>artifactId</code>, <code>version</code>, <code>packaging</code>, <code>classifier</code>, Maven 内置了一个中央仓库的地址, 该中央仓库包含了世界上大部分流行的开源项目构件, Maven 会在需要的时候去那里下载</p>
<h3 id="坐标详解">坐标详解</h3>
<p><code>nexus-indexer</code> 是一个对 Maven 仓库编纂索引并提供搜索功能的类库, 它是 Nexus 项目的一个子模块, 下面是 <code>nexus-indexer</code> 的坐标定义</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.sonatype.nexus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nexus-indexer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong><code>groupId</code></strong> 定义当前 Maven 项目隶属的实际项目, Maven 项目和实际项目不一定是一对一的关系, 一个实际项目往往会被划分成很多模块, <code>groupId</code> 不应该对应项目隶属的组织或公司, <code>groupId</code> 的表示方式与 Java 包名的表示方式类似, 通常与域名反向一一对应</p>
<p>上例中, <code>groupId</code> 为 <code>org.sonatype.nexus</code>, <code>org.sonatype</code> 表示 Sonatype 公司建立的一个非盈利性组织, <code>nexus</code> 表示 <code>Nexus</code> 这一实际项目, 该 <code>groupId</code> 与域名 <code>nexus.sonatype.org</code> 对应</p></li>
<li><p><strong><code>artifactId</code></strong> 该元素定义实际项目中的一个 Maven 项目 (模块), 推荐的做法是使用实际项目名称作为 <code>artifactId</code> 的前缀</p>
<p>上例中的 <code>artifactId</code> 是 <code>nexus-indexer</code>, 使用了实际项目名 <code>nexus</code> 作为前缀, 这样做的好处是方便寻找实际构件, 在默认情况下, Maven 生成的构件, 其文件名会以 <code>artifactId</code> 作为开头, 如 <code>nexus-indexer-2.0.0.jar</code>, 使用实际项目名称作为前缀之后, 就能方便从一个 <code>lib</code> 文件夹中找到某个项目的一组构件</p></li>
<li><p><strong><code>version</code></strong> 该元素定义 Maven 项目当前所处的版本</p>
<p>上例中 <code>nexus-indexer</code> 的版本是 <code>2.0.0</code>, 需要注意的是, Maven 定义了一套完整的版本规范, 以及快照 (<code>SNAPSHOT</code>) 的概念</p></li>
<li><p><strong><code>packaging</code></strong> 该元素定义 Maven 项目的打包方式, 打包方式通常与所生成构件的文件扩展名对应</p>
<p>上例中 <code>packaging</code> 为 <code>jar</code>, 最终的文件名为 <code>nexus-indexer-2.0.0.jar</code>, 而使用 <code>war</code> 打包方式的 Maven 项目最终生成的构件会有一个 <code>.war</code> 文件, 不过这不是绝对的, 打包方式会影响到构建的生命周期, 比如 <code>jar</code> 打包和 <code>war</code> 打包会使用不同的命令, 当不定义 <code>packaging</code> 的时候, Maven 会使用默认值 <code>jar</code></p></li>
<li><p><strong><code>classifier</code></strong> 该元素用来帮助定义构建输出的一些附属构件, 附属构件与主构件对应</p>
<p>上例中的主构件是 <code>nexus-indexer-2.0.0.jar</code>, 该项目可能还会通过使用一些插件生成如 <code>nexus-indexer-2.0.0-javadoc.jar</code>, <code>nexus-indexer-2.0.0-sources.jar</code> 这样一些附属构件, 其包含了 Java 文档和源代码, 这时候, <code>javadoc</code> 和 <code>sources</code> 就是这两个附属构件的 <code>classifier</code>, 这样附属构件也就拥有了自己唯一的坐标, 注意, 不能直接定义项目的 <code>classifier</code>, 因为附属构件不是项目直接默认生成的, 而是由附加的插件帮助生成</p></li>
</ul>
<h2 id="依赖的配置">依赖的配置</h2>
<p>一个依赖声明可以包含如下的一些元素</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- dependencies可以包含一个或者多个dependency元素, 以声明一个或者多个项目依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span><span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span><span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span><span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>groupId</code>, <code>artifactId</code>, <code>version</code></strong> 依赖的基本坐标, 对于任何一个依赖来说, 基本坐标是最重要的, Maven 根据坐标才能找到需要的依赖</li>
<li><strong><code>type</code></strong> 依赖的类型, 对应于项目坐标定义的 <code>packaging</code>, 大部分情况下, 该元素不必声明, 其默认值为 <code>jar</code></li>
<li><strong><code>scope</code></strong> 依赖的范围</li>
<li><strong><code>optional</code></strong> 标记依赖是否可选</li>
<li><strong><code>exclusions</code></strong> 用来排除传递性依赖</li>
</ul>
<h3 id="依赖范围">依赖范围</h3>
<p><strong>依赖范围</strong> 用来控制依赖与三种 <code>classpath</code> (编译 <code>classpath</code>, 测试 <code>classpath</code>, 运行 <code>classpath</code>) 的关系</p>
<p>Maven 有以下几种依赖范围:</p>
<ul>
<li><p><strong><code>compile</code></strong> 编译依赖范围, 如果没有指定, 就会默认使用该依赖范围, 使用此依赖范围的 Maven 依赖, 对于编译, 测试, 运行三种 <code>classpath</code> 都有效</p></li>
<li><p><strong><code>test</code></strong> 测试依赖范围, 使用此依赖范围的 Maven 依赖, 只对于测试 <code>classpath</code> 有效, 在编译主代码或者运行项目的使用时将无法使用此类依赖</p></li>
<li><p><strong><code>provided</code></strong> 已提供依赖范围, 使用此依赖范围的 Maven 依赖, 对于编译和测试 <code>classpath</code> 有效, 但在运行时无效</p></li>
<li><p><strong><code>runtime</code></strong> 运行时依赖范围, 使用此依赖范围的 Maven 依赖, 对于测试和运行 <code>classpath</code> 有效, 但在编译主代码时无效</p></li>
<li><p><strong><code>system</code></strong> 系统依赖范围, 该依赖与三种 <code>classpath</code> 的关系, 和 <code>provided</code> 依赖范围完全一致, 但是使用 <code>system</code> 范围的依赖时必须通过 <code>systemPath</code> 元素显式地指定依赖文件的路径, 由于此类依赖不是通过 Maven 仓库解析的, 而且往往与本机系统绑定, 可能造成构建的不可移植, 因此应该谨慎使用</p>
<p><code>systemPath</code> 元素可以引用环境变量如:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.sql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jdbc-stdext<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;java.home&#125;/lib/rt.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong><code>import</code> (Maven 2.0.9 及以上)</strong> 导入依赖范围, 该依赖范围不会对三种 <code>classpath</code> 产生实际的影响</p></li>
</ul>
<table>
<thead>
<tr class="header">
<th>依赖范围 (<code>scope</code>)</th>
<th>对于编译 <code>classpath</code> 有效</th>
<th>对于测试 <code>classpath</code> 有效</th>
<th>对于运行时 <code>classpath</code> 有效</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>compile</code></td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>spring-core</td>
</tr>
<tr class="even">
<td><code>test</code></td>
<td>-</td>
<td>Y</td>
<td>-</td>
<td>JUnit</td>
</tr>
<tr class="odd">
<td><code>provided</code></td>
<td>Y</td>
<td>Y</td>
<td>-</td>
<td>servlet-api</td>
</tr>
<tr class="even">
<td><code>runtime</code></td>
<td>-</td>
<td>Y</td>
<td>Y</td>
<td>JDBC驱动实现</td>
</tr>
<tr class="odd">
<td><code>system</code></td>
<td>Y</td>
<td>Y</td>
<td>-</td>
<td>本地的, Maven 仓库之外的类库文件</td>
</tr>
</tbody>
</table>
<h3 id="传递性依赖">传递性依赖</h3>
<p>以 <code>org.springframework:spring-webmvc</code> 项目为例, 该项目有一个 <code>org.springframework:spring-core</code> 的依赖, 而实际上 <code>spring-core</code> 也有它自己的一个<code>commons-logging</code> 依赖, 那么 <code>commons-logging</code> 就会成为 <code>spring-webmvc</code> 的一个 <strong>传递性依赖</strong></p>
<pre class="mermaid">graph LR
title["图 传递性依赖"]
title --> C
style title fill:#FFF,stroke:#FFF
linkStyle 0 stroke:#FFF,stroke-width:0;
A(spring-webmvc)
B(spring-core)
C(commons-logging)
A --> B
B --> C
A -.-> C</pre>
<p>有了传递性依赖机制, 在使用 <code>Spring Framework</code> 的时候就不用去考虑它依赖了什么, 也不用担心引入多余的依赖, Maven 会解析各个直接依赖的 <code>POM</code>, 将那些必要的间接依赖, 以传递性依赖的形式引入到当前的项目中</p>
<p>依赖范围不仅可以控制依赖与三种 <code>classpath</code> 的关系, 还对传递性依赖产生影响</p>
<p>假设 A 依赖于 B, B 依赖于 C, 我们说 A 对于 B 是第一直接依赖, B 对于 C 是第二直接依赖, A 对于 C 是传递性依赖, 第一直接依赖的范围和第二直接依赖的范围决定了传递性依赖的范围, 如表所示, 最左边一列表示第一直接依赖范围, 最上面一行表示第二直接依赖范围, 中间的交叉单元格则表示传递性依赖范围</p>
<table>
<thead>
<tr class="header">
<th></th>
<th><code>compile</code></th>
<th><code>test</code></th>
<th><code>provided</code></th>
<th><code>runtime</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong><code>compile</code></strong></td>
<td><code>compile</code></td>
<td>-</td>
<td>-</td>
<td><code>runtime</code></td>
</tr>
<tr class="even">
<td><strong><code>test</code></strong></td>
<td><code>test</code></td>
<td>-</td>
<td>-</td>
<td><code>test</code></td>
</tr>
<tr class="odd">
<td><strong><code>provided</code></strong></td>
<td><code>provided</code></td>
<td>-</td>
<td><code>provided</code></td>
<td><code>provided</code></td>
</tr>
<tr class="even">
<td><strong><code>runtime</code></strong></td>
<td><code>runtime</code></td>
<td>-</td>
<td>-</td>
<td><code>runtime</code></td>
</tr>
</tbody>
</table>
<p>Maven 引入的传递性依赖机制, 一方面大大简化和方便了依赖声明, 另一方面, 大部分情况下我们只需要关心项目的直接依赖是什么, 而不用考虑这些直接依赖会引入什么传递性依赖</p>
<h3 id="依赖调解">依赖调解</h3>
<p>例如, 项目 A 有这样的依赖关系: <code>A -&gt; B -&gt; C -&gt; X (1.0)</code>, <code>A -&gt; D -&gt; X (2.0)</code>, X 是 A 的传递性依赖, 但是两条依赖路径上有两个版本的 X</p>
<p>Maven <strong>依赖调解 (Dependency Mediation)</strong> 的原则:</p>
<ol type="1">
<li>路径最近者优先;</li>
<li>第一声明者优先</li>
</ol>
<blockquote>
<p>在依赖路径长度相等的前提下, 在 Maven 2.8 及之前的版本中, 解析是不确定的, 从 Maven 2.0.9 开始, 为了尽可能避免构建的不确定性, 在 POM 中依赖声明最靠前的会被使用</p>
</blockquote>
<h3 id="可选依赖">可选依赖</h3>
<p>例如, 项目 A 依赖于项目 B, 项目 B 依赖于项目 X 和 Y, B 对于 X 和 Y 的依赖都是可选依赖: <code>A -&gt; B</code>, <code>B -&gt; X (可选)</code>, <code>B -&gt; Y (可选)</code>, 根据传递性依赖的定义, 如果所有这三个依赖的范围都是 <code>compile</code>, 那么 X, Y 就是 A 的 <code>compile</code> 范围传递性依赖, 然而由于这里 X, Y 是可选依赖, 依赖将不会得以传递, 换句话说, X, Y 将不会对 A 有任何影响</p>
<pre class="mermaid">graph LR
title["图 可选依赖"]
title --> C
style title fill:#FFF,stroke:#FFF
linkStyle 0 stroke:#FFF,stroke-width:0;
A(A)
B(B)
C("X(可选依赖)")
D("Y(可选依赖)")
A -.->|X| C
A --> B
A -.->|X| D
B --> C
B --> D</pre>
<blockquote>
<p>关于可选依赖需要说明的一点是, 在理想的情况下, 是不应该使用可选依赖的, 使用可选依赖的原因是某一个项目实现了多个特性, 在面向对象设计中, 有个单一职责性原则, 意指一个类应该只有一项职责, 而不是糅合太多的功能, 这个原则在规划 Maven 项目的时候也同样适用</p>
</blockquote>
<h2 id="实践">实践</h2>
<h3 id="排除依赖">排除依赖</h3>
<p>传递性依赖会给项目隐式地引入很多依赖, 这极大地简化了项目依赖的管理, 但是有些时候这种特性也会带来问题:</p>
<ul>
<li>项目依赖 <code>SNAPSHOT</code> 版本的传递依赖时, <code>SNAPSHOT</code> 的不稳定性会直接影响到当前的项目;</li>
<li>由于版权因素不在中央仓库的依赖项目</li>
</ul>
<pre class="mermaid">graph LR
title["图 排除依赖"]
title --> C
style title fill:#FFF,stroke:#FFF
linkStyle 0 stroke:#FFF,stroke-width:0;
A(A)
B(B)
C("C(version?)")
D("C(version 1.10)")
A --> B
B -->|X| C
A --> D</pre>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 代码清单5-9 排除传递性依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 项目依赖项目spring-core, 但是不想引入传递性依赖commons-logging --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 使用exclusions元素声明排除依赖, 可以排除一个或多个传递性依赖 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 声明exclusion只需要groupId和artifactId, 而不需要version --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 手动添加项目org.slf4j, 用于替代commons-logging --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.0-beta2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="归类依赖">归类依赖</h3>
<p>项目中, 有很多关于 <code>Spring Framework</code> 的依赖, 它们分别是 <code>org.springframework:spring-core:2.5.6</code>, <code>org.springframework:spring-beans:2.5.6</code>, <code>org.springframework:spring-context:2.5.6</code> 和 <code>org.springframework:spring-context-support:2.5.6</code>, 它们是来自同一项目的不同模块, 因此, 所有这些依赖的版本都是相同的, 而且可以预见, 如果将来需要升级 <code>Spring Framework</code>, 这些依赖的版本会一起升级</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 代码清单5-12 使用Maven属性归类依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用properties元素定义Maven属性, 该例中定义了一个springframework.version子元素, 其值为5.1.5.RELEASE, 有了这个属性定义后, Maven运行的时候会将POM中的所有$&#123;springframework&#125;替换成实际值5.1.5.RELEASE --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">springframework.version</span>&gt;</span>5.1.5.RELEASE<span class="tag">&lt;/<span class="name">springframework.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;springframework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;springframework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;springframework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;springframework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="优化依赖">优化依赖</h3>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以运行如下的命令查看当前项目的已解析依赖</span></span><br><span class="line">λ mvn dependency:list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示了所有project-a的已解析依赖, 同时每个依赖的范围也得以明确标示</span></span><br></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以运行如下命令查看当前项目的依赖树</span></span><br><span class="line">λ mvn dependency:tree</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过依赖树就能很清楚地看到某个依赖是通过哪条传递路径引入的</span></span><br></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 运行如下命令</span></span><br><span class="line">λ mvn dependency:analyze                                                        </span><br><span class="line"></span><br><span class="line"><span class="comment"># Used declared dependencies 意指项目中使用到的, 但是没有显式声明的依赖, 这种依赖意味着潜在的风险, 当前项目直接在使用它们, 而这种依赖是通过直接依赖传递进来的, 当升级直接依赖的时候, 相关传递性依赖的版本也可能发生变化, 这种变化不易察觉, 但是有可能导致当前项目出错</span></span><br><span class="line"><span class="comment"># Unused declared dependencies 意指项目中未使用的, 但显式声明的依赖, 需要注意的是, 对于这样一类依赖, 我们不应该简单地直接删除其声明, 而是应该仔细分析, 由于dependency:analyze只会分析编译主代码和测试代码需要用到的依赖, 一些执行测试和运行时需要的依赖它就发现不了</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven 006 生命周期和插件</title>
    <url>/2018/09/12/maven/006/</url>
    <content><![CDATA[<h1 id="生命周期和插件">生命周期和插件</h1>
<h2 id="生命周期">生命周期</h2>
<p>Maven 的 <strong>生命周期</strong> 就是为了对所有的构建过程进行抽象和统一, Maven 从大量项目和构建工具中学习和反思, 然后总结了一套高度完善的, 易扩展的生命周期, 这个生命周期包含了项目的清理, 初始化, 编译, 测试, 打包, 集成测试, 验证, 部署和站点生成等几乎所有构建步骤</p>
<p>Maven 的生命周期是抽象的, 这意味着生命周期本身不做任何实际的工作, 在 Maven 的设计中, 实际的任务 (如编译源代码) 都交由 <strong>插件</strong> 来完成, Maven 设计了插件机制, 每个构建步骤都可以绑定一个或者多个插件行为, 而且 Maven 为大多数构建步骤编写并绑定了默认插件</p>
<pre class="mermaid">graph LR
title[图 生命周期和插件的关系]
title --> C
style title fill:#FFF,stroke:#FFF
linkStyle 0 stroke:#FFF,stroke-width:0;
A(编译)
B(测试)
C(打包)
D(部署)
E("maven-compiler-plugin")
F("maven-surefire-plugin")
A ==> B
B ==> C
C ==> D
A --> E
B --> F</pre>
<p>Maven 定义的生命周期和插件机制一方面保证了所有 Maven 项目有一致的构建标准, 另一方面又通过默认插件简化和稳定了实际项目的构建, 此外, 该机制还提供了足够的扩展空间, 用户可以通过配置现有插件或者自行编写插件来自定义构建行为</p>
<h3 id="三套生命周期">三套生命周期</h3>
<p>Maven 拥有三套相互独立的生命周期, 它们分别为 <code>clean</code>, <code>default</code> 和 <code>site</code>, <code>clean</code> 生命周期的目的是清理项目, <code>default</code> 生命周期的目的是构建项目, 而 <code>site</code> 生命周期的目的是建立项目站点</p>
<p>每个生命周期包含一些阶段, 这些阶段是有顺序的, 并且后面的阶段依赖于前面的阶段, 较之于生命周期阶段的前后依赖关系, 三套生命周期本身是相互独立的</p>
<h3 id="clean-生命周期">clean 生命周期</h3>
<p><code>clean</code> 生命周期的目的是清理项目, 它包含三个阶段:</p>
<ol type="1">
<li><code>pre-clean</code> 执行一些清理前需要完成的工作;</li>
<li><code>clean</code> 清理上一次构建生成的文件;</li>
<li><code>post-clean</code> 执行一些清理后需要完成的工作</li>
</ol>
<h3 id="default-生命周期">default 生命周期</h3>
<p><code>default</code> 生命周期定义了真正构建时所需要执行的所有步骤, 它是所有生命周期中最核心的部分, 其包含的阶段如下:</p>
<ol type="1">
<li><code>validate</code>;</li>
<li><code>initialize</code>;</li>
<li><code>generate-sources</code>;</li>
<li><code>process-sources</code> 处理项目主资源文件, 一般来说, 是对 <code>src/main/resources</code> 目录的内容进行变量替换等工作后, 复制到项目输出的主 <code>classpath</code> 目录中;</li>
<li><code>generate-resources</code>;</li>
<li><code>process-resources</code>;</li>
<li><code>compile</code> 编译项目的主源码, 一般来说, 是编译 <code>src/main/java</code> 目录下的 Java 文件至项目输出的主 <code>classpath</code> 目录中;</li>
<li><code>process-classes</code>;</li>
<li><code>generate-test-sources</code>;</li>
<li><code>process-test-sources</code> 处理项目测试资源文件, 一般来说, 是对 <code>src/test/resources</code> 目录的内容进行变量替换等工作后, 复制到项目输出的测试 <code>classpath</code> 目录中;</li>
<li><code>generate-test-resourcesprocess-test-resources</code>;</li>
<li><code>test-compile</code> 编译项目的测试代码, 一般来说, 是编译 <code>src/test/java</code> 目录下的 Java 文件至项目输出的测试 <code>classpath</code> 目录中;</li>
<li><code>process-test-classes</code>;</li>
<li><code>test</code> 使用单元测试框架运行测试, 测试代码不会被打包或部署;</li>
<li><code>prepare-package</code>;</li>
<li><code>package</code> 接受编译好的代码, 打包成可发布的格式, 如 <code>JAR</code>;</li>
<li><code>pre-integration-test</code>;</li>
<li><code>integration-test</code>;</li>
<li><code>post-integration-test</code>;</li>
<li><code>verify</code>;</li>
<li><code>install</code> 将包安装到 Maven 本地仓库, 供本地其他 Maven 项目使用;</li>
<li><code>deploy</code> 将最终的包复制到远程仓库, 供其他开发人员和 Maven 项目使用</li>
</ol>
<h3 id="site-生命周期">site 生命周期</h3>
<p><code>site</code> 生命周期的目的是建立和发布项目站点, Maven 能够基于 <code>POM</code> 所包含的信息, 自动生成一个友好的站点, 方便团队交流和发布项目信息, 该生命周期包含如下阶段:</p>
<ol type="1">
<li><code>pre-site</code> 执行一些在生成项目站点之前需要完成的工作;</li>
<li><code>site</code> 生成项目站点文档;</li>
<li><code>post-site</code> 执行一些在生成项目站点之后需要完成的工作;</li>
<li><code>site-deploy</code> 将生成的项目站点发布到服务器上</li>
</ol>
<h3 id="命令行与生命周期">命令行与生命周期</h3>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">λ mvn clean install</span><br><span class="line"><span class="comment"># 该命令调用clean生命周期的clean阶段和default生命周期的install阶段, 实际执行的阶段为clean生命周期的pre-clean, clean阶段, 以及default生命周期的从validate至install的所有阶段</span></span><br><span class="line"><span class="comment"># 该命令结合了两个生命周期, 在执行真正的项目构建之前清理项目是一个很好的实践</span></span><br></pre></td></tr></table></figure>
<h2 id="插件目标">插件目标</h2>
<p>对于插件本身, 为了能够复用代码, 它往往能够完成多个任务, 为每个任务的功能编写一个独立的插件显然是不可取的, 因为这些任务背后有很多可以复用的代码, 因此, 这些功能聚集在一个插件里, 每个功能就是一个 <strong>插件目标</strong></p>
<p>例如 <code>maven-dependency-plugin</code> 能够基于项目依赖完成多个任务, 如:</p>
<ul>
<li><code>dependency:analyze</code> 能够分析项目依赖, 帮助找出潜在的无用依赖;</li>
<li><code>dependency:tree</code> 能够列出项目的依赖树, 帮助分析依赖来源;</li>
<li><code>dependency:list</code> 能够列出项目所有已解析的依赖;</li>
<li>等等</li>
</ul>
<h2 id="插件绑定">插件绑定</h2>
<p>Maven 的生命周期与插件相互绑定, 用以完成实际的构建任务, 具体而言, 是生命周期的阶段与插件的目标相互绑定, 以完成某个具体的构建任务</p>
<h3 id="内置绑定">内置绑定</h3>
<p>为了能让用户几乎不用任何配置就能构建 Maven 项目, Maven 在核心为一些主要的生命周期阶段绑定了很多插件的目标, 当用户通过命令行调用生命周期阶段的时候, 对应的插件目标就会执行相应的任务</p>
<table>
<thead>
<tr class="header">
<th><code>clean</code> 生命周期阶段</th>
<th>插件目标</th>
<th>执行任务</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>clean</code></td>
<td><code>maven-clean-plugin:clean</code></td>
<td>删除项目的输出目录</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 38%" />
<col style="width: 34%" />
<col style="width: 27%" />
</colgroup>
<thead>
<tr class="header">
<th><code>default</code> 生命周期阶段<br>(打包类型: <code>jar</code>)</th>
<th>插件目标</th>
<th>执行任务</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>process-resources</code></td>
<td><code>maven-resources-plugin:resources</code></td>
<td>复制主资源文件至主输出目录</td>
</tr>
<tr class="even">
<td><code>compile</code></td>
<td><code>maven-compiler-plugin:compile</code></td>
<td>编译主代码至主输出目录</td>
</tr>
<tr class="odd">
<td><code>process-test-resources</code></td>
<td><code>maven-resources-plugin:testResources</code></td>
<td>复制测试资源文件至测试输出目录</td>
</tr>
<tr class="even">
<td><code>test-compile</code></td>
<td><code>maven-compiler-plugin:testCompile</code></td>
<td>编译测试代码至测试输出目录</td>
</tr>
<tr class="odd">
<td><code>test</code></td>
<td><code>maven-surefire-plugin:test</code></td>
<td>执行测试用例</td>
</tr>
<tr class="even">
<td><code>package</code></td>
<td><code>maven-jar-plugin:jar</code></td>
<td>创建项目 <code>jar</code> 包</td>
</tr>
<tr class="odd">
<td><code>install</code></td>
<td><code>maven-install-plugin:install</code></td>
<td>将项目输出构件安装到本地仓库</td>
</tr>
<tr class="even">
<td><code>deploy</code></td>
<td><code>maven-deploy-plugin:deploy</code></td>
<td>将项目输出构件部署到远程仓库</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th><code>site</code> 生命周期阶段</th>
<th>插件目标</th>
<th>执行任务</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>site</code></td>
<td><code>maven-site-plugin:site</code></td>
<td>生成项目站点</td>
</tr>
<tr class="even">
<td><code>site-deploy</code></td>
<td><code>maven-site-plugin:deploy</code></td>
<td>将项目站点部署到远程服务器上</td>
</tr>
</tbody>
</table>
<blockquote>
<p>除了默认的打包类型 <code>jar</code> 之外, 常见的打包类型还有 <code>war</code>, <code>pom</code>, <code>maven-plugin</code>, <code>ear</code> 等, 它们的 <code>default</code> 生命周期与插件目标的绑定关系可参阅 Maven 官方文档: <a href="http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html#Built-in_Lifecycle_Bindings">Document</a></p>
</blockquote>
<h3 id="自定义绑定">自定义绑定</h3>
<p>除了内置绑定以外, 用户还能够自己选择将某个插件目标绑定到生命周期的某个阶段上, 这种自定义绑定方式能让 Maven 项目在构建过程中执行更多更富特色的任务</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 自定义绑定插件目标 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- POM的build元素下的plugins子元素中声明插件的使用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 该例中用的是maven-source-plugin --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-source-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- executions下每个execution子元素可以用来配置执行任务 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 该例中配置一个id为attach-sources的任务, 通过phrase配置, 将其绑定到verify生命周期阶段上, 再通过goals配置指定要执行的插件目标 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>attach-sources<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>verify<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar-no-fork<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 运行mvn verify就能看到如下输出:</span></span><br><span class="line">λ mvn verify</span><br><span class="line">[<span class="type">INFO</span>] Scanning <span class="keyword">for</span> projects...</span><br><span class="line">[<span class="type">INFO</span>]</span><br><span class="line">[<span class="type">INFO</span>] ---------------------&lt; com.janz.maven:hello<span class="literal">-world</span> &gt;---------------------</span><br><span class="line">[<span class="type">INFO</span>] Building Hello World Maven Project <span class="number">1.0</span><span class="literal">-SNAPSHOT</span></span><br><span class="line">[<span class="type">INFO</span>] --------------------------------[ <span class="type">jar</span> ]---------------------------------</span><br><span class="line">[<span class="type">INFO</span>]</span><br><span class="line">[<span class="type">INFO</span>] --- maven<span class="literal">-resources</span><span class="literal">-plugin</span>:<span class="number">2.6</span>:resources (default<span class="literal">-resources</span>) <span class="selector-tag">@</span> hello<span class="literal">-world</span> ---</span><br><span class="line">[<span class="type">INFO</span>] <span class="keyword">Using</span> <span class="string">&#x27;UTF-8&#x27;</span> encoding to copy filtered resources.</span><br><span class="line">[<span class="type">INFO</span>] skip non existing resourceDirectory D:\code\hello<span class="literal">-world</span>\src\main\resources</span><br><span class="line">[<span class="type">INFO</span>]</span><br><span class="line">[<span class="type">INFO</span>] --- maven<span class="literal">-compiler</span><span class="literal">-plugin</span>:<span class="number">3.1</span>:compile (default<span class="literal">-compile</span>) <span class="selector-tag">@</span> hello<span class="literal">-world</span> ---</span><br><span class="line">[<span class="type">INFO</span>] Changes detected - recompiling the module!</span><br><span class="line">[<span class="type">INFO</span>] Compiling <span class="number">1</span> source file to D:\code\hello<span class="literal">-world</span>\target\classes</span><br><span class="line">[<span class="type">INFO</span>]</span><br><span class="line">[<span class="type">INFO</span>] --- maven<span class="literal">-resources</span><span class="literal">-plugin</span>:<span class="number">2.6</span>:testResources (default<span class="literal">-testResources</span>) <span class="selector-tag">@</span> hello<span class="literal">-world</span> ---</span><br><span class="line">[<span class="type">INFO</span>] <span class="keyword">Using</span> <span class="string">&#x27;UTF-8&#x27;</span> encoding to copy filtered resources.</span><br><span class="line">[<span class="type">INFO</span>] skip non existing resourceDirectory D:\code\hello<span class="literal">-world</span>\src\test\resources</span><br><span class="line">[<span class="type">INFO</span>]</span><br><span class="line">[<span class="type">INFO</span>] --- maven<span class="literal">-compiler</span><span class="literal">-plugin</span>:<span class="number">3.1</span>:testCompile (default<span class="literal">-testCompile</span>) <span class="selector-tag">@</span> hello<span class="literal">-world</span> ---</span><br><span class="line">[<span class="type">INFO</span>] Changes detected - recompiling the module!</span><br><span class="line">[<span class="type">INFO</span>] Compiling <span class="number">1</span> source file to D:\code\hello<span class="literal">-world</span>\target\<span class="built_in">test-classes</span></span><br><span class="line">[<span class="type">INFO</span>]</span><br><span class="line">[<span class="type">INFO</span>] --- maven<span class="literal">-surefire</span><span class="literal">-plugin</span>:<span class="number">2.12</span>.<span class="number">4</span>:test (default<span class="literal">-test</span>) <span class="selector-tag">@</span> hello<span class="literal">-world</span> ---</span><br><span class="line">[<span class="type">INFO</span>] Surefire report directory: D:\code\hello<span class="literal">-world</span>\target\surefire<span class="literal">-reports</span></span><br><span class="line"></span><br><span class="line">-------------------------------------------------------</span><br><span class="line"> T E S T S</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">Running com.HelloWorldTest</span><br><span class="line">Tests run: <span class="number">1</span>, Failures: <span class="number">0</span>, Errors: <span class="number">0</span>, Skipped: <span class="number">0</span>, Time elapsed: <span class="number">0.034</span> sec</span><br><span class="line"></span><br><span class="line">Results :</span><br><span class="line"></span><br><span class="line">Tests run: <span class="number">1</span>, Failures: <span class="number">0</span>, Errors: <span class="number">0</span>, Skipped: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">[<span class="type">INFO</span>]</span><br><span class="line">[<span class="type">INFO</span>] --- maven<span class="literal">-jar</span><span class="literal">-plugin</span>:<span class="number">2.4</span>:jar (default<span class="literal">-jar</span>) <span class="selector-tag">@</span> hello<span class="literal">-world</span> ---</span><br><span class="line">[<span class="type">INFO</span>] Building jar: D:\code\hello<span class="literal">-world</span>\target\hello<span class="literal">-world</span><span class="literal">-1</span>.<span class="number">0</span><span class="literal">-SNAPSHOT</span>.jar</span><br><span class="line">[<span class="type">INFO</span>]</span><br><span class="line">[<span class="type">INFO</span>] --- maven<span class="literal">-shade</span><span class="literal">-plugin</span>:<span class="number">1.2</span>.<span class="number">1</span>:shade (default) <span class="selector-tag">@</span> hello<span class="literal">-world</span> ---</span><br><span class="line">[<span class="type">INFO</span>] Replacing original artifact with shaded artifact.</span><br><span class="line">[<span class="type">INFO</span>] Replacing D:\code\hello<span class="literal">-world</span>\target\hello<span class="literal">-world</span><span class="literal">-1</span>.<span class="number">0</span><span class="literal">-SNAPSHOT</span>.jar with D:\code\hello<span class="literal">-world</span>\target\hello<span class="literal">-world</span><span class="literal">-1</span>.<span class="number">0</span><span class="literal">-SNAPSHOT</span><span class="literal">-shaded</span>.jar</span><br><span class="line">[<span class="type">INFO</span>]</span><br><span class="line">[<span class="type">INFO</span>] --- maven<span class="literal">-source</span><span class="literal">-plugin</span>:<span class="number">2.1</span>.<span class="number">1</span>:jar<span class="literal">-no</span><span class="literal">-fork</span> (attach<span class="literal">-sources</span>) <span class="selector-tag">@</span> hello<span class="literal">-world</span> ---</span><br><span class="line">[<span class="type">INFO</span>] Building jar: D:\code\hello<span class="literal">-world</span>\target\hello<span class="literal">-world</span><span class="literal">-1</span>.<span class="number">0</span><span class="literal">-SNAPSHOT</span><span class="literal">-sources</span>.jar</span><br><span class="line">[<span class="type">INFO</span>] ------------------------------------------------------------------------</span><br><span class="line">[<span class="type">INFO</span>] BUILD SUCCESS</span><br><span class="line">[<span class="type">INFO</span>] ------------------------------------------------------------------------</span><br><span class="line">[<span class="type">INFO</span>] Total time: <span class="number">3.740</span> s</span><br><span class="line">[<span class="type">INFO</span>] Finished at: <span class="number">2018</span><span class="literal">-11</span><span class="literal">-05T14</span>:<span class="number">39</span>:<span class="number">58</span>+<span class="number">08</span>:<span class="number">00</span></span><br><span class="line">[<span class="type">INFO</span>] ------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行verify生命周期阶段的时候, maven-source-plugin:jar-no-fork会得以执行, 它会创建一个以-sources.jar结尾的源码文件包</span></span><br></pre></td></tr></table></figure>
<p>有时候, 即使不通过 <code>phase</code> 元素配置生命周期阶段, 插件目标也能够绑定到生命周期中去, 出现这种现象的原因是, 有很多插件的目标在编写时已经定义了默认绑定阶段</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用maven-help-plugin查看插件详细信息, 了解插件目标的默认绑定阶段, 运行命令如下</span></span><br><span class="line">λ mvn help:describe <span class="literal">-Dplugin</span>=org.apache.maven.plugins:maven<span class="literal">-source</span><span class="literal">-plugin</span>:<span class="number">2.1</span>.<span class="number">1</span> <span class="literal">-Ddetail</span></span><br><span class="line">[<span class="type">INFO</span>] Scanning <span class="keyword">for</span> projects...</span><br><span class="line">[<span class="type">INFO</span>]</span><br><span class="line">[<span class="type">INFO</span>] ---------------------&lt; com.janz.maven:hello<span class="literal">-world</span> &gt;---------------------</span><br><span class="line">[<span class="type">INFO</span>] Building Hello World Maven Project <span class="number">1.0</span><span class="literal">-SNAPSHOT</span></span><br><span class="line">[<span class="type">INFO</span>] --------------------------------[ <span class="type">jar</span> ]---------------------------------</span><br><span class="line">[<span class="type">INFO</span>]</span><br><span class="line">[<span class="type">INFO</span>] --- maven<span class="literal">-help</span><span class="literal">-plugin</span>:<span class="number">3.1</span>.<span class="number">0</span>:describe (default<span class="literal">-cli</span>) <span class="selector-tag">@</span> hello<span class="literal">-world</span> ---</span><br><span class="line">[<span class="type">INFO</span>] org.apache.maven.plugins:maven<span class="literal">-source</span><span class="literal">-plugin</span>:<span class="number">2.1</span>.<span class="number">1</span></span><br><span class="line"></span><br><span class="line">Name: Maven Source Plugin</span><br><span class="line">Description: The Maven <span class="number">2</span> Source Plugin creates a JAR archive of the source</span><br><span class="line">  files of the current project.</span><br><span class="line"><span class="built_in">Group</span> Id: org.apache.maven.plugins</span><br><span class="line">Artifact Id: maven<span class="literal">-source</span><span class="literal">-plugin</span></span><br><span class="line">Version: <span class="number">2.1</span>.<span class="number">1</span></span><br><span class="line">Goal Prefix: source</span><br><span class="line"></span><br><span class="line">This plugin has <span class="number">6</span> goals:</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">source:jar<span class="literal">-no</span><span class="literal">-fork</span></span><br><span class="line">  Description: This goal bundles all the sources into a jar archive. This</span><br><span class="line">    goal functions the same as the jar goal but does not fork the build and is</span><br><span class="line">    suitable <span class="keyword">for</span> attaching to the build lifecycle.</span><br><span class="line">  Implementation: org.apache.maven.plugin.source.SourceJarNoForkMojo</span><br><span class="line">  Language: java</span><br><span class="line">  Bound to phase: package</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[<span class="type">INFO</span>] ------------------------------------------------------------------------</span><br><span class="line">[<span class="type">INFO</span>] BUILD SUCCESS</span><br><span class="line">[<span class="type">INFO</span>] ------------------------------------------------------------------------</span><br><span class="line">[<span class="type">INFO</span>] Total time: <span class="number">3.685</span> s</span><br><span class="line">[<span class="type">INFO</span>] Finished at: <span class="number">2018</span><span class="literal">-11</span><span class="literal">-05T14</span>:<span class="number">45</span>:<span class="number">09</span>+<span class="number">08</span>:<span class="number">00</span></span><br><span class="line">[<span class="type">INFO</span>] ------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment"># 该命令输出对应插件的详细信息, 在输出信息中, 能够看到关于目标jar-no-fork的信息</span></span><br><span class="line"><span class="comment"># Bound to phase: package表示该目标默认绑定的生命周期是package, 也就是说当用户配置使用maven-source-plugin的jar-no-fork目标的时候, 如果不指定phase参数, 该目标就会被绑定到package阶段</span></span><br></pre></td></tr></table></figure>
<p>当多个插件目标绑定到同一个阶段的时候, 这些插件声明的先后顺序决定了目标的执行顺序</p>
<h2 id="插件配置">插件配置</h2>
<p>几乎所有 Maven 插件的目标都有一些可配置的参数, 用户可以通过命令行和 <code>POM</code> 配置等方式来配置这些参数</p>
<h3 id="命令行插件配置">命令行插件配置</h3>
<p>很多插件目标的参数都支持从命令行配置, 用户可以在 Maven 命令中使用 <code>-D</code> 参数, 并伴随一个参数键=参数值的形式, 来配置插件目标的参数,</p>
<blockquote>
<p>参数 <code>-D</code> 是 Java 自带的, 其功能是通过命令行设置一个 Java 系统属性, Maven 简单地重用了该参数, 在准备插件的时候检查系统属性, 便实现了插件参数的配置</p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 例如, maven-surefire-plugin提供了一个maven.test.skip参数, 当其值为true的时候, 就会跳过执行测试:</span></span><br><span class="line">λ mvn install <span class="literal">-D</span> maven.test.skip=true</span><br><span class="line">[<span class="type">INFO</span>] --- maven<span class="literal">-surefire</span><span class="literal">-plugin</span>:<span class="number">2.12</span>.<span class="number">4</span>:test (default<span class="literal">-test</span>) <span class="selector-tag">@</span> hello<span class="literal">-world</span> ---</span><br><span class="line">[<span class="type">INFO</span>] Tests are skipped.</span><br></pre></td></tr></table></figure>
<h3 id="pom-中插件全局配置">POM 中插件全局配置</h3>
<p>并不是所有的插件参数都适合从命令行配置, 有些参数的值从项目创建到项目发布都不会改变, 或者说很少改变, 对于这种情况, 在 <code>POM</code> 文件中一次性配置就显然比重复在命令行输入要方便, 用户可以在声明插件的时候, 对此插件进行一个全局的配置, 也就是说, 所有该基于该插件目标的任务, 都会使用这些配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在POM中对插件进行全局配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.5<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.5<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 旧版本maven需要配置compile基于Java 1.5 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 不管绑定到compile阶段的maven-compiler-plugin:compile任务, 还是绑定到test-compiler阶段的maven-compiler-plugin:testCompiler任务, 就都能够使用该配置, 基于Java 1.5版本进行编译 --&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="pom-中插件任务配置">POM 中插件任务配置</h3>
<p>除了为插件配置全局的参数, 用户还可以为某个插件任务配置特定的参数</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在POM中对插件进行任务配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-antrun-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>ant-validate<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>validate<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>run<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">tasks</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">echo</span>&gt;</span>I′m bound to validate phase.<span class="tag">&lt;/<span class="name">echo</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">tasks</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>ant-verify<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>verify<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>run<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">tasks</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">echo</span>&gt;</span>I′m bound to verify phase.<span class="tag">&lt;/<span class="name">echo</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">tasks</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- maven-antrun-plugin有一个目标run, 可以用来在Maven中调用Ant任务 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 将maven-antrun-plugin:run绑定到多个生命周期阶段上, 再加以不同的配置, 就可以让Maven在不同的生命阶段执行不同的任务 --&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="获取插件信息">获取插件信息</h2>
<h3 id="在线插件信息">在线插件信息</h3>
<p>基本上所有主要的 Maven 插件都来自 Apache 和 Codehaus</p>
<ul>
<li>由于 Maven 本身是属于 Apache 软件基金会的, 因此它有很多官方的插件, 它们具有非常好的稳定性, <a href="http://maven.apache.org/plugins/index.html">列表</a>, <a href="http://repo1.maven.org/maven2/org/apache/maven/plugins/">下载</a>, 单击某个插件的链接便可以得到进一步的信息;</li>
<li>除了 Apache 上的官方插件之外, 托管于 Codehaus 上的 Mojo 项目也提供了大量了 Maven 插件, <a href="http://mojo.codehaus.org/plugins.html">列表</a>, <a href="http://repository.codehaus.org/org/codehaus/mojo/">下载</a>, 需要注意的是, 这些插件的文档和可靠性相对较差, 在使用时如果遇到问题, 往往只能自己去看源代码</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以maven-surefire-plugin为例, 可以通过在命令行传入maven.test.skip参数来跳过测试执行, 而执行测试的插件目标是surefire:test, 访问其文档http://maven.apache.org/plugins/maven-surefire-plugin/test-mojo.html, 可以找到目标参数skip</span></span><br><span class="line"></span><br><span class="line">skip:</span><br><span class="line"><span class="built_in">Set</span> this to <span class="string">&quot;true&quot;</span> to bypass unit tests entirely. Its use is NOT RECOMMENDED, especially <span class="keyword">if</span> you enable it <span class="keyword">using</span> the <span class="string">&quot;maven.test.skip&quot;</span> property, because maven.test.skip disables both running the tests and compiling the tests. Consider <span class="keyword">using</span> the skipTests parameter instead.</span><br><span class="line"></span><br><span class="line">- <span class="built_in">Type</span>: boolean</span><br><span class="line">- Required: No</span><br><span class="line">- User Property: maven.test.skip</span><br><span class="line">- Default: false</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令行参数是由该插件参数的表达式(User Property)决定的, surefire:test skip参数的表达式为maven.test.skip, 它表示可以在命令行以-D maven.test.skip=true的方式配置该目标, 并不是所有插件目标参数都有表达式, 也就是说, 一些插件目标参数只能在POM中配置</span></span><br></pre></td></tr></table></figure>
<h3 id="使用-maven-help-plugin-描述插件">使用 maven-help-plugin 描述插件</h3>
<p>除了访问在线的插件文档之外, 还可以借助 <code>maven-help-plugin</code> 来获取插件的详细信息</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用maven-help-plugin获取插件信息</span></span><br><span class="line">[<span class="type">INFO</span>] Scanning <span class="keyword">for</span> projects...</span><br><span class="line">[<span class="type">INFO</span>]</span><br><span class="line">[<span class="type">INFO</span>] ---------------------&lt; com.janz.maven:hello<span class="literal">-world</span> &gt;---------------------</span><br><span class="line">[<span class="type">INFO</span>] Building Hello World Maven Project <span class="number">1.0</span><span class="literal">-SNAPSHOT</span></span><br><span class="line">[<span class="type">INFO</span>] --------------------------------[ <span class="type">jar</span> ]---------------------------------</span><br><span class="line">[<span class="type">INFO</span>]</span><br><span class="line">[<span class="type">INFO</span>] --- maven<span class="literal">-help</span><span class="literal">-plugin</span>:<span class="number">3.1</span>.<span class="number">0</span>:describe (default<span class="literal">-cli</span>) <span class="selector-tag">@</span> hello<span class="literal">-world</span> ---</span><br><span class="line">[<span class="type">INFO</span>] org.apache.maven.plugins:maven<span class="literal">-compiler</span><span class="literal">-plugin</span>:<span class="number">2.1</span></span><br><span class="line"></span><br><span class="line">Name: Maven Compiler Plugin</span><br><span class="line">Description: The Compiler Plugin is used to compile the sources of your</span><br><span class="line">  project.</span><br><span class="line"><span class="built_in">Group</span> Id: org.apache.maven.plugins</span><br><span class="line">Artifact Id: maven<span class="literal">-compiler</span><span class="literal">-plugin</span></span><br><span class="line">Version: <span class="number">2.1</span></span><br><span class="line">Goal Prefix: compiler</span><br><span class="line"></span><br><span class="line">This plugin has <span class="number">3</span> goals:</span><br><span class="line"></span><br><span class="line">compiler:compile</span><br><span class="line">  Description: Compiles application sources</span><br><span class="line"></span><br><span class="line">compiler:help</span><br><span class="line">  Description: Display help information on maven<span class="literal">-compiler</span><span class="literal">-plugin</span>.</span><br><span class="line">    Call</span><br><span class="line">     mvn compiler:help <span class="literal">-Ddetail</span>=true <span class="literal">-Dgoal</span>=&lt;goal<span class="literal">-name</span>&gt;</span><br><span class="line">    to display <span class="keyword">parameter</span> details.</span><br><span class="line"></span><br><span class="line">compiler:testCompile</span><br><span class="line">  Description: Compiles application test sources.</span><br><span class="line"></span><br><span class="line"><span class="keyword">For</span> more information, run <span class="string">&#x27;mvn help:describe [...] -Ddetail&#x27;</span></span><br><span class="line"></span><br><span class="line">[<span class="type">INFO</span>] ------------------------------------------------------------------------</span><br><span class="line">[<span class="type">INFO</span>] BUILD SUCCESS</span><br><span class="line">[<span class="type">INFO</span>] ------------------------------------------------------------------------</span><br><span class="line">[<span class="type">INFO</span>] Total time: <span class="number">1.177</span> s</span><br><span class="line">[<span class="type">INFO</span>] Finished at: <span class="number">2018</span><span class="literal">-11</span><span class="literal">-05T14</span>:<span class="number">48</span>:<span class="number">42</span>+<span class="number">08</span>:<span class="number">00</span></span><br><span class="line">[<span class="type">INFO</span>] ------------------------------------------------------------------------     </span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标前缀(Goal Prefix), 其作用是方便在命令行直接运行插件</span></span><br><span class="line"><span class="comment"># 在描述插件的时候, 还可以省去版本信息, 让Maven自动获取最新版本来进行表述, 例如</span></span><br><span class="line">λ mvn help:describe <span class="literal">-Dplugin</span>=org.apache.maven.plugins:maven<span class="literal">-compiler</span><span class="literal">-plugin</span></span><br><span class="line"><span class="comment"># 进一步简化, 可以使用插件目标前缀替换坐标, 例如</span></span><br><span class="line">λ mvn help:describe <span class="literal">-Dplugin</span>=compiler</span><br><span class="line"><span class="comment"># 如果想仅仅描述某个插件目标的信息, 可以加上goal参数</span></span><br><span class="line">λ mvn help:describe <span class="literal">-Dplugin</span>=compiler <span class="literal">-Dgoal</span>=compile</span><br><span class="line"><span class="comment"># 如果想让maven-help-plugin输出更详细的信息, 可以加上detail参数</span></span><br><span class="line">λ mvn help:describe <span class="literal">-Dplugin</span>=compiler <span class="literal">-Dgoal</span>=compile <span class="literal">-Ddetail</span></span><br></pre></td></tr></table></figure>
<h3 id="从命令行调用插件">从命令行调用插件</h3>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果在命令行运行mvn-h来显示mvn命令帮助, 就可以看到如下的信息</span></span><br><span class="line">λ mvn <span class="literal">-h</span></span><br><span class="line"></span><br><span class="line">usage: mvn [<span class="type">options</span>] [&lt;<span class="type">goal</span>(<span class="type">s</span>)&gt;] [&lt;<span class="type">phase</span>(<span class="type">s</span>)&gt;]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 该信息告诉了我们mvn命令的基本用法, options表示可用的选项, 后面可以添加一个或者多个goal和phase, 它们分别是指插件目标和生命周期阶段</span></span><br></pre></td></tr></table></figure>
<p>可以通过 <code>mvn</code> 命令激活生命周期阶段, 从而执行那些绑定在生命周期阶段上的插件目标, 但 Maven 还支持直接从命令行调用插件目标, Maven 支持这种方式是因为有些任务不适合绑定在生命周期上</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 例如maven-help-plugin:describe, 我们不需要在构建项目的时候去描述插件信息</span></span><br><span class="line">λ mvn help:describe <span class="literal">-Dplugin</span>=compiler</span><br><span class="line">λ mvn org.apache.maven.plugins:maven<span class="literal">-help</span><span class="literal">-plugin</span>:<span class="number">2.1</span>:describe <span class="literal">-Dplugin</span>=compiler</span><br><span class="line"><span class="comment"># 这两条命令的效果基本是一样的, 但显然前面的命令更简洁, 更容易记忆和使用</span></span><br><span class="line"><span class="comment"># Maven引入了目标前缀的概念, help是maven-help-plugin的目标前缀, 有了插进前缀, Maven就能找到对应的artifactId</span></span><br></pre></td></tr></table></figure>
<h2 id="插件解析机制">插件解析机制</h2>
<p>为了方便用户使用和配置插件, Maven 不需要用户提供完整的插件坐标信息, 就可以解析得到正确的插件, Maven 的这一特性是一把双刃剑, 虽然它简化了插件的使用和配置, 可一旦插件的行为出现异常, 用户就很难快速定位到出问题的插件构件</p>
<h3 id="插件仓库">插件仓库</h3>
<p>与依赖构件一样, 插件构件同样基于坐标存储在 Maven 仓库中, 在需要的时候, Maven 会从本地仓库寻找插件, 如果不存在, 则从远程插件仓库查找, 找到插件之后, 再下载到本地仓库使用</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 代码清单7-7 Maven内置的插件仓库配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven Plugin Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo1.maven.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>never<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="插件的默认-groupid">插件的默认 groupId</h3>
<p>在 <code>POM</code> 中配置插件的时候, 如果该插件是 Maven 的官方插件 (即如果其 <code>groupId</code> 为 <code>org.apache.maven.plugins</code>) 就可以省略 <code>groupId</code> 配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 代码清单7-8 配置官方插件和省略groupId --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.5<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.5<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>不推荐使用 Maven 的这一机制, 虽然这么做可以省略一些配置, 但这样的配置会让团队中不熟悉 Maven 的成员感到费解, 况且能省略的配置也就仅仅一行而已</p>
</blockquote>
<h3 id="解析插件版本">解析插件版本</h3>
<p>首先, Maven 在超级 <code>POM</code> 中为所有核心插件设定了版本, 超级 <code>POM</code> 是所有 Maven 项目的父 <code>POM</code>, 所有项目都继承这个超级 <code>POM</code> 的配置, 因此, 即使用户不加任何配置, Maven 使用核心插件的时候, 它们的版本就已经确定了, 这些插件包括 <code>maven-clean-plugin</code>, <code>maven-compiler-plugin</code>, <code>maven-surefire-plugin</code> 等</p>
<p>如果用户使用某个插件时没有设定版本, 而这个插件又不属于核心插件的范畴, Maven 就会去检查所有仓库中可用的版本, 然后做出选择, Maven 遍历本地仓库和所有远程插件仓库, 将该路径下的仓库元数据归并后, 就能计算出 <code>latest</code> 和 <code>release</code> 的值</p>
<blockquote>
<p>依赖 Maven 解析插件版本其实是不推荐的做法, 即使 Maven 3 将版本解析到最新的非快照版, 也还是会有潜在的不稳定性</p>
</blockquote>
<h3 id="解析插件前缀">解析插件前缀</h3>
<p>插件前缀与 <code>groupId:artifactId</code> 是一一对应的, 这种匹配关系存储在仓库元数据中, Maven 在解析插件仓库元数据的时候, 会默认使用 <code>org.apache.maven.plugins</code> 和 <code>org.codehaus.mojo</code> 两个 <code>groupId</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 也可以通过配置settings.xml让Maven检查其他groupId上的插件仓库元数据 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginGroups</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginGroup</span>&gt;</span>com.your.plugins<span class="tag">&lt;/<span class="name">pluginGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginGroups</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 基于该配置, Maven还会检查com/your/plugins/maven-metadata.xml --&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 代码清单7-10 插件仓库元数据 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">metadata</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven Clean Plugin<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prefix</span>&gt;</span>clean<span class="tag">&lt;/<span class="name">prefix</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-clean-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven Compiler Plugin<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prefix</span>&gt;</span>compiler<span class="tag">&lt;/<span class="name">prefix</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven Dependency Plugin<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prefix</span>&gt;</span>dependency<span class="tag">&lt;/<span class="name">prefix</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-dependency-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">metadata</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 上述内容是从中央仓库的org.apache.maven.plugins groupId下插件仓库元数据中截取的一些片段, 从这段数据中就能看到:</span></span><br><span class="line"><span class="comment">maven-clean-plugin的前缀为clean, </span></span><br><span class="line"><span class="comment">maven-compiler-plugin的前缀为compiler, </span></span><br><span class="line"><span class="comment">maven-dependency-plugin的前缀为dependency --&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven 007 测试</title>
    <url>/2018/09/16/maven/007/</url>
    <content><![CDATA[<h1 id="测试">测试</h1>
<p>Maven 的重要职责之一就是自动运行 <strong>单元测试</strong>, 它通过 <code>maven-surefire-plugin</code> 与主流的单元测试框架 JUnit 3, JUnit 4 以及 TestNG 集成, 并且能够自动生成丰富的结果报告</p>
<h2 id="maven-surefire-plugin-简介">maven-surefire-plugin 简介</h2>
<p>Maven 本身并不是一个单元测试框架, Java 世界中主流的单元测试框架为 <a href="http://www.junit.org/">JUnit</a> 和 <a href="http://testng.org/">TestNG</a>, Maven 所做的只是在构建执行到特定生命周期阶段的时候, 通过插件来执行 JUnit 或者 TestNG 的测试用例, 这一插件就是 <code>maven-surefire-plugin</code>, 可以称之为 <strong>测试运行器 (Test Runner)</strong>, 它能很好地兼容 JUnit 3, JUnit 4 以及 TestNG</p>
<p>在默认情况下, <code>maven-surefire-plugin</code> 的 <code>test</code> 目标会自动执行测试源码路径 (默认为 <code>src/test/java/</code>) 下所有符合一组命名模式的测试类, 这组模式为:</p>
<ul>
<li><code>**/Test*.java</code> 任何子目录下所有命名以 <code>Test</code> 开头的 Java 类;</li>
<li><code>**/*Test.java</code> 任何子目录下所有命名以 <code>Test</code> 结尾的 Java 类;</li>
<li><code>**/*TestCase.java</code> 任何子目录下所有命名以 <code>TestCase</code> 结尾的 Java 类</li>
</ul>
<h2 id="跳过测试">跳过测试</h2>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 要跳过Maven测试, 在命令行加入参数skipTests就可以了, 例如:</span></span><br><span class="line">λ mvn package <span class="literal">-DskipTests</span></span><br><span class="line">[<span class="type">INFO</span>] --- maven<span class="literal">-surefire</span><span class="literal">-plugin</span>:<span class="number">2.12</span>.<span class="number">4</span>:test (default<span class="literal">-test</span>) <span class="selector-tag">@</span> hello<span class="literal">-world</span> ---</span><br><span class="line">[<span class="type">INFO</span>] Tests are skipped.</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置插件跳过测试运行 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">skipTests</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skipTests</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这是不推荐的做法, 如果配置POM让项目长时间的跳过测试, 则还要测试代码做什么呢 --&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 有时候用户不仅仅想跳过测试运行, 还想临时性地跳过测试代码的编译, Maven也允许你这么做, 但记住这是不推荐的:</span></span><br><span class="line">λ mvn package <span class="literal">-Dmaven</span>.test.skip=true</span><br><span class="line">[<span class="type">INFO</span>] --- maven<span class="literal">-resources</span><span class="literal">-plugin</span>:<span class="number">2.6</span>:testResources (default<span class="literal">-testResources</span>) <span class="selector-tag">@</span> hello<span class="literal">-world</span> ---</span><br><span class="line">[<span class="type">INFO</span>] Not copying test resources</span><br><span class="line">[<span class="type">INFO</span>]</span><br><span class="line">[<span class="type">INFO</span>] --- maven<span class="literal">-compiler</span><span class="literal">-plugin</span>:<span class="number">3.1</span>:testCompile (default<span class="literal">-testCompile</span>) <span class="selector-tag">@</span> hello<span class="literal">-world</span> ---</span><br><span class="line">[<span class="type">INFO</span>] Not compiling test sources</span><br><span class="line">[<span class="type">INFO</span>]</span><br><span class="line">[<span class="type">INFO</span>] --- maven<span class="literal">-surefire</span><span class="literal">-plugin</span>:<span class="number">2.12</span>.<span class="number">4</span>:test (default<span class="literal">-test</span>) <span class="selector-tag">@</span> hello<span class="literal">-world</span> ---</span><br><span class="line">[<span class="type">INFO</span>] Tests are skipped.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数maven.test.skip同时控制了maven-compiler-plugin和maven-surefire-plugin两个插件的行为, 测试代码编译跳过了, 测试运行也跳过了</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置插件跳过测试编译和运行 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">skip</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skip</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">skip</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skip</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="动态指定要运行的测试用例">动态指定要运行的测试用例</h2>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果只想运行HelloWorldTest, 可以使用如下命令:</span></span><br><span class="line">λ mvn test <span class="literal">-Dtest</span>=HelloWorldTest</span><br><span class="line">[<span class="type">INFO</span>] Scanning <span class="keyword">for</span> projects...</span><br><span class="line">[<span class="type">INFO</span>]</span><br><span class="line">[<span class="type">INFO</span>] ---------------------&lt; com.janz.maven:hello<span class="literal">-world</span> &gt;---------------------</span><br><span class="line">[<span class="type">INFO</span>] Building Hello World Maven Project <span class="number">1.0</span><span class="literal">-SNAPSHOT</span></span><br><span class="line">[<span class="type">INFO</span>] --------------------------------[ <span class="type">jar</span> ]---------------------------------</span><br><span class="line">[<span class="type">INFO</span>]</span><br><span class="line">[<span class="type">INFO</span>] --- maven<span class="literal">-resources</span><span class="literal">-plugin</span>:<span class="number">2.6</span>:resources (default<span class="literal">-resources</span>) <span class="selector-tag">@</span> hello<span class="literal">-world</span> ---</span><br><span class="line">[<span class="type">INFO</span>] <span class="keyword">Using</span> <span class="string">&#x27;UTF-8&#x27;</span> encoding to copy filtered resources.</span><br><span class="line">[<span class="type">INFO</span>] skip non existing resourceDirectory D:\code\hello<span class="literal">-world</span>\src\main\resources</span><br><span class="line">[<span class="type">INFO</span>]</span><br><span class="line">[<span class="type">INFO</span>] --- maven<span class="literal">-compiler</span><span class="literal">-plugin</span>:<span class="number">3.1</span>:compile (default<span class="literal">-compile</span>) <span class="selector-tag">@</span> hello<span class="literal">-world</span> ---</span><br><span class="line">[<span class="type">INFO</span>] Nothing to compile - all classes are up to date</span><br><span class="line">[<span class="type">INFO</span>]</span><br><span class="line">[<span class="type">INFO</span>] --- maven<span class="literal">-resources</span><span class="literal">-plugin</span>:<span class="number">2.6</span>:testResources (default<span class="literal">-testResources</span>) <span class="selector-tag">@</span> hello<span class="literal">-world</span> ---</span><br><span class="line">[<span class="type">INFO</span>] <span class="keyword">Using</span> <span class="string">&#x27;UTF-8&#x27;</span> encoding to copy filtered resources.</span><br><span class="line">[<span class="type">INFO</span>] skip non existing resourceDirectory D:\code\hello<span class="literal">-world</span>\src\test\resources</span><br><span class="line">[<span class="type">INFO</span>]</span><br><span class="line">[<span class="type">INFO</span>] --- maven<span class="literal">-compiler</span><span class="literal">-plugin</span>:<span class="number">3.1</span>:testCompile (default<span class="literal">-testCompile</span>) <span class="selector-tag">@</span> hello<span class="literal">-world</span> ---</span><br><span class="line">[<span class="type">INFO</span>] Nothing to compile - all classes are up to date</span><br><span class="line">[<span class="type">INFO</span>]</span><br><span class="line">[<span class="type">INFO</span>] --- maven<span class="literal">-surefire</span><span class="literal">-plugin</span>:<span class="number">2.12</span>.<span class="number">4</span>:test (default<span class="literal">-test</span>) <span class="selector-tag">@</span> hello<span class="literal">-world</span> ---</span><br><span class="line">[<span class="type">INFO</span>] Surefire report directory: D:\code\hello<span class="literal">-world</span>\target\surefire<span class="literal">-reports</span></span><br><span class="line"></span><br><span class="line">-------------------------------------------------------</span><br><span class="line"> T E S T S</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">Running com.HelloWorldTest</span><br><span class="line">Tests run: <span class="number">1</span>, Failures: <span class="number">0</span>, Errors: <span class="number">0</span>, Skipped: <span class="number">0</span>, Time elapsed: <span class="number">0.031</span> sec</span><br><span class="line"></span><br><span class="line">Results :</span><br><span class="line"></span><br><span class="line">Tests run: <span class="number">1</span>, Failures: <span class="number">0</span>, Errors: <span class="number">0</span>, Skipped: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">[<span class="type">INFO</span>] ------------------------------------------------------------------------</span><br><span class="line">[<span class="type">INFO</span>] BUILD SUCCESS</span><br><span class="line">[<span class="type">INFO</span>] ------------------------------------------------------------------------</span><br><span class="line">[<span class="type">INFO</span>] Total time: <span class="number">1.132</span> s</span><br><span class="line">[<span class="type">INFO</span>] Finished at: <span class="number">2018</span><span class="literal">-11</span><span class="literal">-05T14</span>:<span class="number">55</span>:<span class="number">32</span>+<span class="number">08</span>:<span class="number">00</span></span><br><span class="line">[<span class="type">INFO</span>] ------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里test参数的值是测试用例的类名, 这行命令的效果就是只有HelloWorldTest这一个测试类得到运行</span></span><br></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># maven-surefire-plugin的test参数还支持高级一些的赋值方式, 能让用户更灵活地指定需要运行的测试用例, 例如:</span></span><br><span class="line">λ mvn test <span class="literal">-Dtest</span>=Hello*Test</span><br><span class="line"><span class="comment"># 星号可以匹配零个或多个字符, 上述命令会运行项目中所有类名以Hello开头, Test结尾的测试类</span></span><br></pre></td></tr></table></figure>
<p><code>test</code> 参数的值必须匹配一个或者多个测试类, 如果 <code>maven-surefire-plugin</code> 找不到任何匹配的测试类, 就会报错并导致构建失败</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据错误提示可以加上-DfailIfNoTests=false, 告诉maven-surefire-plugin即使没有任何测试也不要报错:</span></span><br><span class="line">λ mvn test <span class="literal">-Dtest</span> <span class="literal">-DfailIfNoTests</span>=false</span><br><span class="line"><span class="comment"># 可以发现, 实际上使用命令行参数-Dtest-DfailIfNoTests=false是另外一种跳过测试的方法</span></span><br></pre></td></tr></table></figure>
<h2 id="包含与排除测试用例">包含与排除测试用例</h2>
<p><code>maven-surefire-plugin</code> 允许用户通过额外的配置来自定义包含一些其他测试类, 或者排除一些符合默认命名模式的测试类</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 自动运行以Tests结尾的测试类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*Tests.java<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 上述代码清单中使用了**/*Tests.java来匹配所有以Tests结尾的Java类, 两个星**号用来匹配任意路径, 一个星号*匹配除路径风格符外的0个或者多个字符 --&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 排除运行测试类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/*ServiceTest.java<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/TempDaoTest.java<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 上述代码清单排除了所有以ServiceTest结尾的测试类, 以及一个名为TempDaoTest的测试类 --&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="测试报告">测试报告</h2>
<h3 id="基本的测试报告">基本的测试报告</h3>
<p>默认情况下, <code>maven-surefire-plugin</code> 会在项目的 <code>target/surefire-reports</code> 目录下生成两种格式的错误报告:</p>
<ul>
<li>简单文本格式;</li>
<li>与 JUnit 兼容的 <code>XML</code> 格式</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># TXT的内容十分简单, 这样的报告对于获得信息足够了, XML格式的测试报告主要是为了支持工具的解析, 例如Eclipse的JUnit插件</span></span><br><span class="line">λ <span class="built_in">cat</span> target\surefire<span class="literal">-reports</span>\com.HelloWorldTest.txt</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">Test <span class="built_in">set</span>: com.HelloWorldTest</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">Tests run: <span class="number">1</span>, Failures: <span class="number">0</span>, Errors: <span class="number">0</span>, Skipped: <span class="number">0</span>, Time elapsed: <span class="number">0.031</span> sec</span><br></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 错误报告会是这样, 说明了哪个测试方法失败, 哪个断言失败以及具体的堆栈信息, 用户可以据此快速地寻找失败原因</span></span><br><span class="line">λ <span class="built_in">cat</span> target\surefire<span class="literal">-reports</span>\com.HelloWorldTest.txt</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">Test <span class="built_in">set</span>: com.HelloWorldTest</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">Tests run: <span class="number">1</span>, Failures: <span class="number">1</span>, Errors: <span class="number">0</span>, Skipped: <span class="number">0</span>, Time elapsed: <span class="number">0.034</span> sec &lt;&lt;&lt; FAILURE!</span><br><span class="line">testSayHello(com.HelloWorldTest)  Time elapsed: <span class="number">0.005</span> sec  &lt;&lt;&lt; FAILURE!</span><br><span class="line">junit.framework.AssertionFailedError: test is null</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<h3 id="测试覆盖率报告">测试覆盖率报告</h3>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用户可以使用简单的命令为Maven项目生成测试覆盖率报告</span></span><br><span class="line">λ mvn cobertura:cobertura</span><br><span class="line"><span class="comment"># 接着打开项目目录target/site/cobertura/下的index.html文件, 就能看到测试覆盖率报告, 单击具体的类, 还能看到精确到行的覆盖率报告</span></span><br></pre></td></tr></table></figure>
<h2 id="运行testng测试">运行TestNG测试</h2>
<p><strong>TestNG</strong> 是 Java 社区中除 JUnit 之外另一个流行的单元测试框架, NG 是 Next Generation 的缩写, 译为下一代, TestNG 在 JUnit 的基础上增加了很多特性, 读者可以访问其站点 <a href="http://testng.org/">TestNG</a> 获取更多信息</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 加入TestNG依赖 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 与JUnit类似, TestNG的依赖范围应为test --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.testng<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>testng<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th>JUnit 类</th>
<th>TestNG 类</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>org.junit.Test</code></td>
<td><code>org.testng.annotations.Test</code></td>
<td>标注方法为测试方法</td>
</tr>
<tr class="even">
<td><code>org.junit.Assert</code></td>
<td><code>org.testng.Assert</code></td>
<td>检查测试结果</td>
</tr>
<tr class="odd">
<td><code>org.junit.Before</code></td>
<td><code>org.testng.annotations.BeforeMethod</code></td>
<td>标注方法在每个测试方法之前运行</td>
</tr>
<tr class="even">
<td><code>org.junit.After</code></td>
<td><code>org.testng.annotations.AfterMethod</code></td>
<td>标注方法在每个测试方法之后运行</td>
</tr>
<tr class="odd">
<td><code>org.junit.BeforeClass</code></td>
<td><code>org.testng.annotations.BeforeClass</code></td>
<td>标注方法在所有测试方法之前运行</td>
</tr>
<tr class="even">
<td><code>org.junit.AfterClass</code></td>
<td><code>org.testng.annotations.AfterClass</code></td>
<td>标注方法在所有测试方法之后运行</td>
</tr>
</tbody>
</table>
<p>TestNG 允许用户使用一个名为 <code>testng.xml</code> 的文件来配置想要运行的测试集合</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- TestNG的testng.xml --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置只运行HelloWorldTest --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">suite</span> <span class="attr">name</span>=<span class="string">&quot;Suite1&quot;</span> <span class="attr">verbose</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">test</span> <span class="attr">name</span>=<span class="string">&quot;Regression1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">classes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;com.HelloWorldTest&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">classes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">suite</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置maven-surefire-plugin使用testng.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">suiteXmlFiles</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">suiteXmlFile</span>&gt;</span>testng.xml<span class="tag">&lt;/<span class="name">suiteXmlFile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">suiteXmlFiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>TestNG 较 JUnit 的一大优势在于它支持测试组的概念</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 如下的注解会将测试方法加入到两个测试组util和medium中 */</span></span><br><span class="line"><span class="meta">@Test(groups = &#123;&quot;util&quot;, &quot;medium&quot;&#125;)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置maven-surefire-plugin运行TestNG测试组 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置运行一个或者多个TestNG测试组 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groups</span>&gt;</span>util,medium<span class="tag">&lt;/<span class="name">groups</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="重用测试代码">重用测试代码</h2>
<p>在命令行运行 <code>mvn package</code> 的时候, Maven 会将项目的主代码及资源文件打包, 将其安装或部署到仓库之后, 这些代码就能为他人使用, 从而实现 Maven 项目级别的重用, 默认的打包行为是不会包含测试代码的, 因此在使用外部依赖的时候, 其构件一般都不会包含测试代码</p>
<p>在项目内部重用某个模块的测试代码是很常见的需求, 可能某个底层模块的测试代码中包含了一些常用的测试工具类, 或者一些高质量的测试基类供继承</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 打包测试代码 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 通过配置maven-jar-plugin将测试类打包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>test-jar<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 依赖测试包构件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.juvenxu.mvnbook.account<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>account-email<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">type</span>&gt;</span>test-jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 上述依赖声明中有一个特殊的元素type, 所有测试包构件都使用特殊的test-jar打包类型, 需要注意的是, 这一类型的依赖同样都使用test依赖范围 --&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven 008 灵活的构建</title>
    <url>/2018/11/05/maven/008/</url>
    <content><![CDATA[<h1 id="灵活的构建">灵活的构建</h1>
<h2 id="maven-属性">Maven 属性</h2>
<p>Maven 为了支持构建的灵活性, 内置了三大特性, 即 <strong>属性</strong>, <strong>Profile</strong> 和 <strong>资源过滤</strong></p>
<p>Maven 属性分为 6 类, 分别为:</p>
<ul>
<li><p><strong>内置属性</strong> 主要有两个常用内置属性:</p>
<ul>
<li><code>$&#123;basedir&#125;</code> 表示项目根目录, 即包含 <code>pom.xml</code> 文件的目录;</li>
<li><code>$&#123;version&#125;</code> 表示项目版本;</li>
</ul></li>
<li><p><strong>POM 属性</strong> 用户可以使用该类属性引用 POM 文件中对应元素的值, 常用的 POM 属性包括:</p>
<ul>
<li><code>$&#123;project.build.sourceDirectory&#125;</code> 项目的主源码目录, 默认为<code>src/main/java/</code>;</li>
<li><code>$&#123;project.build.testSourceDirectory&#125;</code> 项目的测试源码目录, 默认为 <code>src/test/java/</code>;</li>
<li><code>$&#123;project.build.directory&#125;</code> 项目构建输出目录, 默认为 <code>target/</code>;</li>
<li><code>$&#123;project.outputDirectory&#125;</code> 项目主代码编译输出目录, 默认为 <code>target/classes/</code>;</li>
<li><code>$&#123;project.testOutputDirectory&#125;</code> 项目测试代码编译输出目录, 默认为 <code>target/test-classes/</code>;</li>
<li><code>$&#123;project.groupId&#125;</code> 项目的 <code>groupId</code>;</li>
<li><code>$&#123;project.artifactId&#125;</code> 项目的 <code>artifactId</code>;</li>
<li><code>$&#123;project.version&#125;</code> 项目的 <code>version</code>, 与 <code>$&#123;version&#125;</code> 等价;</li>
<li><code>$&#123;project.build.finalName&#125;</code> 项目打包输出文件的名称, 默认为 <code>$&#123;project.artifactId&#125;-$&#123;project.version&#125;</code></li>
</ul></li>
<li><p><strong>自定义属性</strong> 用户可以在 POM 的 <code>&lt;properties&gt;</code> 元素下自定义 Maven 属性, 例如</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">my.prop</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">my.prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在 POM 中其他地方使用 <code>$&#123;my.prop&#125;</code> 的时候会被替换成 <code>hello</code>;</p></li>
<li><p><strong>Settings 属性</strong> 与 POM 属性同理, 用户使用以 <code>settings.</code> 开头的属性引用 <code>settings.xml</code> 文件中 XML 元素的值, 如常用的 <code>$&#123;settings.localRepository&#125;</code> 指向用户本地仓库的地址;</p></li>
<li><p><strong>Java 系统属性</strong> 所有 Java 系统属性都可以使用 Maven 属性引用, 例如 <code>$&#123;user.home&#125;</code> 指向了用户目录, 用户可以使用 <code>mvn help:system</code> 查看所有的 Java 系统属性;</p></li>
<li><p><strong>环境变量属性</strong> 所有环境变量都可以使用以 <code>env.</code> 开头的 Maven 属性引用, 例如 <code>$&#123;env.JAVA_HOME&#125;</code> 指代了 <code>JAVA_HOME</code> 环境变量的值, 用户可以使用 <code>mvn help:system</code> 查看所有的环境变量</p></li>
</ul>
<blockquote>
<p>Maven 属性默认只有在 POM 中才会被解析, 也就是说, <code>$&#123;my.prop&#125;</code> 放到 POM 中会变成 <code>hello</code>, 但是如果放到 <code>src/main/resources/</code> 目录下的文件中, 构建的时候它将仍然还是 <code>$&#123;my.prop&#125;</code></p>
</blockquote>
<p>资源文件的处理其实是 <code>maven-resources-plugin</code> 做的事情, 它默认的行为只是将项目主资源文件复制到主代码编译输出目录中, 将测试资源文件复制到测试代码编译输出目录中, 不过只要通过一些简单的 POM 配置, 该插件就能够解析资源文件中的 Maven 属性, 即开启 <strong>资源过滤</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 为主资源目录开启过滤 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="maven-profile">Maven Profile</h2>
<p>为了能让构建在各个环境下方便地移植, Maven 引入了 <code>profile</code> 的概念, <code>profile</code> 能够在构建的时候修改 POM 的一个子集, 或者添加额外的配置元素, 用户可以使用很多方式激活 <code>profile</code>, 以实现构建在不同环境下的移植</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 基于开发环境和测试环境的profile --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">db.driver</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">db.driver</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">db.url</span>&gt;</span>jdbc:mysql://localhost:3306/test<span class="tag">&lt;/<span class="name">db.url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">db.username</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">db.username</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">db.password</span>&gt;</span>dev-pwd<span class="tag">&lt;/<span class="name">db.password</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>test<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">db.driver</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">db.driver</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">db.url</span>&gt;</span>jdbc:mysql://192.168.1.100:3306/test<span class="tag">&lt;/<span class="name">db.url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">db.username</span>&gt;</span>test<span class="tag">&lt;/<span class="name">db.username</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">db.password</span>&gt;</span>test-pwd<span class="tag">&lt;/<span class="name">db.password</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="激活-profile">激活 profile</h3>
<ol type="1">
<li><p>命令行激活</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用户可以使用mvn命令行参数-P加上profile的id来激活profile, 多个id之间以逗号分隔, 例如, 下面的命令激活了dev-x和dev-y两个profile:</span></span><br><span class="line">λ mvn clean install <span class="literal">-Pdev</span><span class="literal">-x</span>,dev<span class="literal">-y</span></span><br></pre></td></tr></table></figure></li>
<li><p>settings 文件显式激活</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- settings文件显式激活profile --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 如果用户希望某个profile默认一直处于激活状态, 就可以配置settings.xml文件的activeProfiles元素, 表示其配置的profile对于所有项目都处于激活状态 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>dev-x<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>系统属性激活</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 某系统属性存在且值确定时激活profile --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 当某系统属性test存在, 且值等于x的时候激活profile --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>test<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>x<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 用户可以在命令行声明系统属性, 因此这也是一种从命令行激活profile的方法, 例如: --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- mvn clean install -Dtest=x --&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>操作系统环境激活</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 基于操作系统环境激活profile --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">os</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>Windows XP<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">family</span>&gt;</span>Windows<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">arch</span>&gt;</span>x86<span class="tag">&lt;/<span class="name">arch</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.2600<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">os</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>文件存在与否激活</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 基于文件存在与否激活profile --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">file</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">missing</span>&gt;</span>x.properties<span class="tag">&lt;/<span class="name">missing</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exists</span>&gt;</span>y.properties<span class="tag">&lt;/<span class="name">exists</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>默认激活</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 默认激活profile --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是, 如果 POM 中有任何一个 <code>profile</code> 通过以上其他任意一种方式被激活了, 所有的默认激活配置都会失效</p>
</blockquote></li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># maven-help-plugin提供了一个目标帮助用户了解当前激活的profile</span></span><br><span class="line">λ mvn help:active<span class="literal">-profiles</span></span><br><span class="line"><span class="comment"># maven-help-plugin还有另外一个目标用来列出当前所有的profile</span></span><br><span class="line">λ mvn help:all<span class="literal">-profiles</span></span><br></pre></td></tr></table></figure>
<h3 id="profile-的种类">profile 的种类</h3>
<p>根据具体的需要, 可以在以下位置声明 <code>profile</code>:</p>
<ul>
<li><strong>pom.xml</strong> 很显然, <code>pom.xml</code> 中声明的 <code>profile</code> 只对当前项目有效;</li>
<li><strong>用户settings.xml</strong> 用户目录下 <code>.m2/settings.xml</code> 中的 <code>profile</code> 对本机上该用户所有的 Maven 项目有效;</li>
<li><strong>全局settings.xml</strong> Maven 安装目录下 <code>conf/settings.xml</code> 中的 <code>profile</code> 对本机上所有的 Maven 项目有效;</li>
<li><strong>profiles.xml(Maven 2)</strong> 还可以在项目根目录下使用一个额外的 <code>profiles.xml</code> 文件来声明 <code>profile</code>, 不过该特性已经在 Maven 3 中被移除, 建议用户将这类 <code>profile</code> 移到 <code>settings.xml</code> 中</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- POM中的profile可使用的元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span><span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span><span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">reporting</span>&gt;</span><span class="tag">&lt;/<span class="name">reporting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">defaultGoal</span>&gt;</span><span class="tag">&lt;/<span class="name">defaultGoal</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">testResources</span>&gt;</span><span class="tag">&lt;/<span class="name">testResources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span><span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- POM外部的profile可使用的元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span><span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="web-资源过滤">Web 资源过滤</h2>
<p>在 Web 项目中, 资源文件同样位于 <code>src/main/resources/</code> 目录下, 它们经处理后会位于 <code>WAR</code> 包的 <code>WEB-INF/classes</code> 目录下, 这也是 Java 代码编译打包后的目录, 也就是说, 这类资源文件在打包过后位于应用程序的 <code>classpath</code> 中, Web 项目中还有另外一类资源文件, 默认它们的源码位于 <code>src/main/webapp/</code> 目录, 经打包后位于 <code>WAR</code> 包的根目录</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 针对不同客户web资源的profile --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>client-a<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">client.logo</span>&gt;</span>a.jpg<span class="tag">&lt;/<span class="name">client.logo</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">client.theme</span>&gt;</span>red<span class="tag">&lt;/<span class="name">client.theme</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>client-b<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">client.logo</span>&gt;</span>b.jpg<span class="tag">&lt;/<span class="name">client.logo</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">client.theme</span>&gt;</span>blue<span class="tag">&lt;/<span class="name">client.theme</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 为web资源目录src/main/webapp/开启过滤 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-war-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1-beta-1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">webResources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/webapp<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.css<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.js<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">webResources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven 009 构建Web应用</title>
    <url>/2018/11/27/maven/009/</url>
    <content><![CDATA[<h1 id="构建-web-应用">构建 Web 应用</h1>
<h2 id="web项目">Web项目</h2>
<h3 id="web项目的目录结构">Web项目的目录结构</h3>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一个典型的WAR文件会有如下目录结构:</span></span><br><span class="line">war/</span><br><span class="line">├─META<span class="literal">-INF</span>/</span><br><span class="line">├─WEB<span class="literal">-INF</span>/</span><br><span class="line">│  ├─classes/</span><br><span class="line">│  │  ├─ServletA.class</span><br><span class="line">│  │  ├─config.properties</span><br><span class="line">│  │  ├─lib/</span><br><span class="line">│  │  └─xxx.jar</span><br><span class="line">│  └─web.xml</span><br><span class="line">├─img/</span><br><span class="line">├─css/</span><br><span class="line">├─js/</span><br><span class="line">├─index.html</span><br><span class="line">└─sample.jsp</span><br></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一个典型的Web项目的Maven目录结构如下:</span></span><br><span class="line">project/</span><br><span class="line">├─pom.xml</span><br><span class="line">└─src/</span><br><span class="line">   ├─main/</span><br><span class="line">   │  ├─java/</span><br><span class="line">   │  │  └─ServletA.java</span><br><span class="line">   │  ├─resources/</span><br><span class="line">   │  │  └─config.properties</span><br><span class="line">   │  └─webapp/</span><br><span class="line">   │     ├─WEB<span class="literal">-INF</span>/</span><br><span class="line">   │     │  └─web.xml</span><br><span class="line">   │     ├─img/</span><br><span class="line">   │     ├─css/</span><br><span class="line">   │     ├─js/</span><br><span class="line">   │     ├─index.html</span><br><span class="line">   │     └─sample.jsp</span><br><span class="line">   └─test/</span><br><span class="line">       ├─java/</span><br><span class="line">       └─resources/</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有一点需要注意的是, <code>WAR</code> 包中有一个 <code>lib</code> 目录包含所有依赖 <code>JAR</code> 包, 但 <code>Maven</code> 项目结构中没有这样一个目录, 这是因为依赖都配置在 <code>POM</code> 中, Maven 在用 <code>WAR</code> 方式打包的时候会根据 <code>POM</code> 的配置从本地仓库复制相应的 <code>JAR</code> 文件</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 显式指定Web项目的打包方式为war --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.janz.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果不显式地指定packaging, Maven会使用默认的jar打包方式, 从而导致无法正确打包Web项目 --&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="使用jetty-maven-plugin进行测试">使用jetty-maven-plugin进行测试</h2>
<p>传统的 Web 测试方法要求我们编译, 测试, 打包及部署, 这往往会消耗数 10 秒至数分钟的时间, <code>jetty-maven-plugin</code> 能够帮助我们节省时间, 它能够周期性地检查项目内容, 发现变更后自动更新到内置的 Jetty Web 容器中, 换句话说, 它帮我们省去了打包和部署的步骤</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置jetty-maven-plugin --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mortbay.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetty-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.1.6.v20100715<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scanIntervalSeconds</span>&gt;</span>10<span class="tag">&lt;/<span class="name">scanIntervalSeconds</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">webAppConfig</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">contextPath</span>&gt;</span>/test<span class="tag">&lt;/<span class="name">contextPath</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">webAppConfig</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- jetty被eclipse收购后, 新版本配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetty-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.4.12.v20180830<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scanIntervalSeconds</span>&gt;</span>10<span class="tag">&lt;/<span class="name">scanIntervalSeconds</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">webAppConfig</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">contextPath</span>&gt;</span>/test<span class="tag">&lt;/<span class="name">contextPath</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">webAppConfig</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- jetty-maven-plugin并不是官方的Maven插件, 为了能在命令行直接运行mvn jetty:run, 用户需要配置settings.xml如下, 新版本无需此配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginGroups</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginGroup</span>&gt;</span>org.mortbay.jetty<span class="tag">&lt;/<span class="name">pluginGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginGroups</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># jetty-maven-plugin会启动Jetty, 并且默认监听本地的8080端口, 并将当前项目部署到容器中, 同时它还会根据用户配置扫描代码改动</span></span><br><span class="line"><span class="comment"># 如果希望使用其他端口, 可以添加jetty.port参数, 例如:</span></span><br><span class="line">λ mvn jetty:run <span class="literal">-Djetty</span>.port=<span class="number">9999</span></span><br><span class="line"><span class="comment"># 可以打开浏览器通过地址http://localhost:9999/test/访问</span></span><br></pre></td></tr></table></figure>
<h2 id="使用cargo实现自动化部署">使用Cargo实现自动化部署</h2>
<p>Cargo 是一组帮助用户操作 Web 容器的工具, 它能够帮助用户实现自动化部署, 而且它几乎支持所有的 Web 容器, 如 Tomcat, JBoss, Jetty 和 Glassfish 等, Cargo 通过 <code>cargo-maven2-plugin</code> 提供了 Maven 集成, Maven 用户可以使用该插件将 Web 项目部署到 Web 容器中</p>
<h3 id="部署至本地web容器">部署至本地Web容器</h3>
<p>Cargo 支持两种本地部署的方式, 分别为 <code>standalone</code> 模式和 <code>existing</code> 模式:</p>
<ul>
<li>在 <code>standalone</code> 模式中, Cargo 会从 Web 容器的安装目录复制一份配置到用户指定的目录, 然后在此基础上部署应用, 每次重新构建的时候, 这个目录都会被清空, 所有配置被重新生成;</li>
<li>在 <code>existing</code> 模式中, 用户需要指定现有的 Web 容器配置目录, 然后 Cargo 会直接使用这些配置并将应用部署到其对应的位置</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用standalone模式部署应用至本地Web容器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.cargo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cargo-maven2-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">container</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">containerId</span>&gt;</span>tomcat6x<span class="tag">&lt;/<span class="name">containerId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">home</span>&gt;</span>D:\cmd\apache-tomcat-6.0.29<span class="tag">&lt;/<span class="name">home</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">container</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>standalone<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">home</span>&gt;</span>$&#123;project.build.directory&#125;/tomcat6x<span class="tag">&lt;/<span class="name">home</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用existing模式部署应用至本地Web容器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.cargo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cargo-maven2-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">container</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">containerId</span>&gt;</span>tomcat6x<span class="tag">&lt;/<span class="name">containerId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">home</span>&gt;</span>D:\cmd\apache-tomcat-6.0.29<span class="tag">&lt;/<span class="name">home</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">container</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">type</span>&gt;</span>existing<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">home</span>&gt;</span>D:\cmd\apache-tomcat-6.0.29<span class="tag">&lt;/<span class="name">home</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="部署至远程web容器">部署至远程Web容器</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 部署应用至远程Web容器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.cargo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cargo-maven2-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">container</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">containerId</span>&gt;</span>tomcat6x<span class="tag">&lt;/<span class="name">containerId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">type</span>&gt;</span>remote<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">container</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">type</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">cargo.remote.username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">cargo.remote.username</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">cargo.remote.password</span>&gt;</span>admin123<span class="tag">&lt;/<span class="name">cargo.remote.password</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">cargo.tomcat.manager.url</span>&gt;</span>http://localhost:8080/manager<span class="tag">&lt;/<span class="name">cargo.tomcat.manager.url</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven 010 项目站点</title>
    <url>/2018/12/03/maven/010/</url>
    <content><![CDATA[<h1 id="生成项目站点">生成项目站点</h1>
<h2 id="项目站点">项目站点</h2>
<p>POM 可以包含各种项目信息, 如项目描述, 版本控制系统地址, 缺陷跟踪系统地址, 许可证信息, 开发者信息等, 用户可以让 Maven 自动生成一个 <strong>Web 站点</strong>, 以 Web 的形式发布这些信息</p>
<h3 id="配置">配置</h3>
<p>项目 <code>pom.xml</code> 中添加配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Maven 3用户必须使用3.x版本的maven-site-plugin, 例如 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-site-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Maven 2用户则应该使用maven-site-plugin最新的2.x版本, 例如 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-site-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>配置了正确版本的 <code>maven-site-plugin</code> 之后, 在项目下运行 <code>mvn site</code> 就能直接生成一个最简单的站点</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">λ mvn site</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行完毕后, 可以在项目的target/site/目录下找到Maven生成的站点文件, 包括dependencies.html, dependency-convergence.html, index.html等文件和css, image文件夹</span></span><br></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">λ mvn site:stage <span class="literal">-DstagingDirectory</span>=D:\tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># stage目标将站点预发布至本地临时目录, 需要配置distributionManagement/site信息</span></span><br></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">λ tree target\site /F</span><br><span class="line">D:.</span><br><span class="line">├─dependencies.html</span><br><span class="line">├─dependency<span class="literal">-info</span>.html</span><br><span class="line">├─index.html</span><br><span class="line">├─plugin<span class="literal">-management</span>.html</span><br><span class="line">├─plugins.html</span><br><span class="line">├─project<span class="literal">-info</span>.html</span><br><span class="line">├─summary.html</span><br><span class="line">├─css</span><br><span class="line">└─images</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 选择性的生成项目信息报告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">reporting</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-project-info-reports-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">reportSets</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">reportSet</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">reports</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!-- 配置需要生成的信息 --&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">report</span>&gt;</span>dependencies<span class="tag">&lt;/<span class="name">report</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">report</span>&gt;</span>project-team<span class="tag">&lt;/<span class="name">report</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">report</span>&gt;</span>issue-tracking<span class="tag">&lt;/<span class="name">report</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">report</span>&gt;</span>license<span class="tag">&lt;/<span class="name">report</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;/<span class="name">reports</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">reportSet</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">reportSets</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">reporting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="站点信息">站点信息</h3>
<p>在默认情况下 Maven 生成的站点包含了很多项目信息链接, 这其实是由一个名为 <code>maven-project-info-reports-plugin</code> 的插件生成的, 在 Maven 3 中, 该插件的配置内置在 <code>maven-site-plugin</code> 中, 而在 Maven 2 中, 该插件的配置内置在核心源码中</p>
<p>该插件会基于 <code>POM</code> 配置生成下列项目信息报告:</p>
<ul>
<li><strong>关于(about)</strong> 项目描述;</li>
<li><strong>持续集成(Continuous Integration)</strong> 项目持续集成服务器信息;</li>
<li><strong>依赖(Dependencies)</strong> 项目依赖信息, 包括传递性依赖, 依赖图, 依赖许可证以及依赖文件的大小, 所包含的类数目等;</li>
<li><strong>依赖收敛(Dependency Convergence)</strong> 只针对多模块项目生成, 提供一些依赖健康状况分析, 如各模块使用的依赖版本是否一致, 项目中是否有 SNAPSHOT 依赖;</li>
<li><strong>依赖管理(Dependency Management)</strong> 基于项目的依赖管理配置生成的报告;</li>
<li><strong>问题追踪(Issue Tracking)</strong> 项目的问题追踪系统信息;</li>
<li><strong>邮件列表(Mailing Lists)</strong> 项目的邮件列表信息;</li>
<li><strong>插件管理(Plugin Management)</strong> 项目所使用插件的列表;</li>
<li><strong>项目许可证(Project License)</strong> 项目许可证信息;</li>
<li><strong>项目概述(Project Summary)</strong> 项目概述包括坐标, 名称, 描述等;</li>
<li><strong>项目团队(Project Team)</strong> 项目团队信息;</li>
<li><strong>源码仓库(Source Repository)</strong> 项目的源码仓库信息</li>
</ul>
<p>Maven 不会凭空生成信息, 只有用户在 <code>POM</code> 中提供了相关配置后, 站点才有可能包含这些信息的报告</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 包含完整项目信息的POM --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.janz.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project-site<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>project-site<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">url</span>&gt;</span>http://xxx.com<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">description</span>&gt;</span>project-site<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 源码仓库信息 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">scm</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">connection</span>&gt;</span>scm:http://svn.xxx.com/project-site<span class="tag">&lt;/<span class="name">connection</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">developerConnection</span>&gt;</span>scm:http//svn.xxx.com/project-site<span class="tag">&lt;/<span class="name">developerConnection</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">url</span>&gt;</span>http://svn.xxx.com/project-site<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">scm</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 持续集成服务器信息 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">ciManagement</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">system</span>&gt;</span>Hudson<span class="tag">&lt;/<span class="name">system</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">url</span>&gt;</span>http://ci.xxx.com/project-site<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">ciManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 项目成员团队信息 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">developers</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">developer</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">id</span>&gt;</span>janz<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">name</span>&gt;</span>janz<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">email</span>&gt;</span>janz@xxx.com<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">timezone</span>&gt;</span>8<span class="tag">&lt;/<span class="name">timezone</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">developer</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">developers</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 问题追踪系统信息 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">issueManagement</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">system</span>&gt;</span>JIRA<span class="tag">&lt;/<span class="name">system</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">url</span>&gt;</span>http://jira.xxx.com/project-site<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">issueManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 许可证信息 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">licenses</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">license</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">name</span>&gt;</span>Apache License, Version 2.0<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.apache.org/licenses/LICENSE-2.0<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">license</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">licenses</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-site-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">site</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">id</span>&gt;</span>project-site<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">url</span>&gt;</span>http://xxx.com/sites/app<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">site</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="项目报告插件">项目报告插件</h2>
<p>除了默认的项目信息报告, Maven 社区还提供了大量报告插件, 只要稍加配置, 用户就能让 Maven 自动生成各种内容丰富的报告</p>
<h3 id="javadocs">JavaDocs</h3>
<p><code>maven-javadoc-plugin</code> 使用 JDK 的 javadoc 工具, 基于项目的源代码生成 JavaDocs 文档</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">reporting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-javadoc-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">reporting</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 聚合项目无须额外配置就能在聚合项目的站点中得到包含所有模块的JavaDocs --&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="source-xref">Source Xref</h3>
<p><code>maven-jxr-plugin</code> 能够以 Web 页面的形式将 Java 源代码展现出来</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">reporting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jxr-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">aggregate</span>&gt;</span>true<span class="tag">&lt;/<span class="name">aggregate</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">reporting</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 聚合项目需要额外添加aggregate配置 --&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="checkstyle">CheckStyle</h3>
<p>CheckStyle 是一个用来帮助 Java 开发人员遵循编码规范的工具, 能根据一套规则自动检查 Java 代码，使得团队能够方便地定义自己的编码规范, 要让 Maven 在站点中生成 CheckStyle 报告, 只需要配置 <code>maven-checkstyle-plugin</code></p>
<p><code>maven-checkstyle-plugin</code> 内置了四种规则:</p>
<ul>
<li><code>config/sun_checks.xml</code> Sun 定义的编码规范 (默认值);</li>
<li><code>config/maven_checks.xml</code> Maven 社区定义的编码规范;</li>
<li><code>config/turbine_checks.xml</code> Turbine 定义的编码规范;</li>
<li><code>config/avalon_checks.xml</code> Avalon 定义的编码规范</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">reporting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-checkstyle-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 配置非默认编码规范 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configLocation</span>&gt;</span>config/maven_checks.xml<span class="tag">&lt;/<span class="name">configLocation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">reporting</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="pmd">PMD</h3>
<p>PMD 是一款强大的 Java 源代码分析工具, 它能够寻找代码中的问题, 包括潜在的 bug, 无用代码, 可优化代码, 重复代码以及过于复杂的表达式</p>
<p>PMD 包含了大量的分析规则, PMD 默认使用的规则为 <code>rulesets/basic.xml</code>, <code>rulesets/unusedcode.xml</code> 和 <code>rulesets/importss.xml</code>, 要使用其他的规则, 可以配置 <code>maven-pmd-plugin</code> 插件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">reporting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-pmd-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.11.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 配置非默认分析规则 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">rulesets</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">ruleset</span>&gt;</span>rulesets/braces.xml<span class="tag">&lt;/<span class="name">ruleset</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">ruleset</span>&gt;</span>rulesets/naming.xml<span class="tag">&lt;/<span class="name">ruleset</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">ruleset</span>&gt;</span>rulesets/strings.xml<span class="tag">&lt;/<span class="name">ruleset</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">rulesets</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 聚合项目配置 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">aggregate</span>&gt;</span>true<span class="tag">&lt;/<span class="name">aggregate</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">reporting</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="changelog">ChangeLog</h3>
<p><code>maven-changelog-plugin</code> 能够基于版本控制系统中就近的变更记录生成三份变更报告, 它们分别为:</p>
<ul>
<li><code>Change Log</code> 基于提交的变更报告, 包括每次提交的日期, 文件, 作者, 注释等信息;</li>
<li><code>Developer Activity</code> 基于作者的变更报告, 包括作者列表以及每个作者相关的提交次数和涉及文件数目;</li>
<li><code>File Activity</code> 基于文件的变更报告, 包括变更的文件列表及每个文件的变更次数</li>
</ul>
<blockquote>
<p>想要生成项目的变更报告, 首先需要配置正确的SCM信息</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">reporting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-changelog-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 默认情况下生成最近30天的变更记录, 修改配置 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>range<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">range</span>&gt;</span>60<span class="tag">&lt;/<span class="name">range</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">reporting</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="cobertura">Cobertura</h3>
<p>Maven 通过 <code>cobertura-maven-plugin</code> 生成项目测试覆盖率报告, 可以看到每个包, 每个类的代码行覆盖率和分支覆盖率, 单击具体的类还能看到该类代码的具体覆盖情况</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">reporting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.mojo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cobertura-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">reporting</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="部署站点">部署站点</h2>
<h3 id="国际化">国际化</h3>
<p>要生成正确的本地化的 Maven 站点, 用户首先需要确保项目所有的源码, 包括 <code>pom.xml</code>, <code>site.xml</code> 以及自定义页面等, 都以 <code>UTF-8</code> 编码保存</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置maven-site-plugin使用UTF-8编码读取所有源码及文档, 并且同样以UTF-8编码呈现站点html站点 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置当地语言为简体中文zh_CN --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-site-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">locales</span>&gt;</span>zh_CN<span class="tag">&lt;/<span class="name">locales</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="部署">部署</h3>
<p>为了方便团队和用户得到必要的项目信息, 需要将 Maven 站点部署到服务器上, Maven 支持多种协议部署站点, 包括 FTP, SCP 和 DAV</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置基于DAV协议的站点部署 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">site</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>project-site<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>dav:http://xxx.com/sites/app<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">site</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- FTP,SCP配置类似 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 认证信息配置在settings.xml, 参考依赖部署认证配置 --&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven 011 版本管理</title>
    <url>/2018/12/16/maven/011/</url>
    <content><![CDATA[<h1 id="版本管理">版本管理</h1>
<p>[TOC]</p>
<h2 id="版本管理-1">版本管理</h2>
<p><strong>版本管理</strong> 是指项目整体版本的演变过程管理, 如从 <code>1.0-SNAPSHOT</code> 到 <code>1.0</code>, 再到 <code>1.1-SNAPSHOT</code></p>
<p>理想的发布版本应当对应了项目某个时刻比较稳定的状态, 这包括源代码的状态以及构建的状态, 因此这个时候项目的构建应当满足以下的条件:</p>
<ul>
<li>所有自动化测试应当全部通过, 毫无疑问, 失败的测试代表了需要修复的问题, 因此发布版本之前应该确保所有测试都能得以正确执行;</li>
<li>项目没有配置任何快照版本的依赖, 快照版本的依赖意味着不同时间的构建可能会引入不同内容的依赖, 这显然不能保证多次构建能够生成同样的结果;</li>
<li>项目没有配置任何快照版本的插件, 快照版本的插件配置可能会在不同时间引入不同内容的 Maven 插件, 从而影响 Maven 的行为, 破坏构建的稳定性;</li>
<li>项目所包含的代码已经全部提交到版本控制系统中, 项目已经发布了, 可源代码却不在版本控制系统中, 甚至丢失了, 这意味着项目丢失了某个时刻的状态, 因此这种情况必须避免, 版本发布的时候必须确保所有的源代码都已经提交了</li>
</ul>
<h3 id="maven的版本号定义约定">Maven的版本号定义约定</h3>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Maven 的版本号定义约定是这样的:</span></span><br><span class="line">&lt;主版本&gt;.&lt;次版本&gt;.&lt;增量版本&gt;-&lt;里程碑版本&gt;</span><br></pre></td></tr></table></figure>
<p>主版本和次版本之间, 以及次版本和增量版本之间用点号分隔, 里程碑版本之前用连字号分隔, 下面解释其中每一个部分的意义:</p>
<ul>
<li><strong>主版本</strong> 表示了项目的重大架构变更;</li>
<li><strong>次版本</strong> 表示较大范围的功能增加和变化, 及 Bug 修复;</li>
<li><strong>增量版本</strong> 一般表示重大 Bug 的修复;</li>
<li><strong>里程碑版本</strong> 顾名思义, 这往往指某一个版本的里程碑</li>
</ul>
<blockquote>
<p>对于主版本, 次版本和增量版本来说, 比较是基于数字的, 因此 <code>1.5 &gt; 1.4 &gt; 1.3.11 &gt; 1.3.9</code>, 而对于里程碑版本, Maven 则只进行简单的字符串比较, 因此会得到 <code>1.2-beta-3 &gt; 1.2-beta-11</code> 的结果, 这一点需要留意</p>
</blockquote>
<h2 id="版本控制">版本控制</h2>
<p><strong>版本控制</strong> 是指借助版本控制工具 (如 Subversion) 追踪代码的每一个变更</p>
<p>使用版本控制工具时都会遇到主干 (trunk), 标签 (tag) 和分支 (branch) 的概念:</p>
<ul>
<li><strong>主干</strong> 项目开发代码的主体, 是从项目开始直到当前都处于活动的状态, 从这里可以获得项目最新的源代码以及几乎所有的变更历史;</li>
<li><strong>分支</strong> 从主干的某个点分离出来的代码拷贝, 通常可以在不影响主干的前提下在这里进行重大 Bug 的修复, 或者做一些实验性质的开发, 如果分支达到了预期的目的, 通常发生在这里的变更会被合并 (merge) 到主干中;</li>
<li><strong>标签</strong> 用来标识主干或者分支的某个点的状态, 以代表项目的某个稳定状态, 这通常就是版本发布时的状态</li>
</ul>
<h2 id="自动化版本发布">自动化版本发布</h2>
<p><code>Maven Release Plugin</code> 提供了自动化版本发布的功能, 只要提供一些必要的信息, 它就能帮我们完成发布所涉及的操作</p>
<p><code>Maven Release Plugin</code> 主要有三个目标, 它们分别为:</p>
<ul>
<li><code>release:prepare</code> 准备版本发布, 依次执行下列操作:
<ul>
<li>检查项目是否有未提交的代码;</li>
<li>检查项目是否有快照版本依赖;</li>
<li>根据用户的输入将快照版本升级为发布版;</li>
<li>将 <code>POM</code> 中的 SCM 信息更新为标签地址;</li>
<li>基于修改后的 <code>POM</code> 执行 Maven 构建;</li>
<li>提交 <code>POM</code> 变更;</li>
<li>基于用户输入为代码打标签;</li>
<li>将代码从发布版升级为新的快照版;</li>
<li>提交 <code>POM</code> 变更</li>
</ul></li>
<li><code>release:rollback</code> 回退 <code>release:prepare</code> 所执行的操作, 将 <code>POM</code> 回退至 <code>release:prepare</code> 之前的状态, 并提交, 需要注意的是, 该步骤不会删除 <code>release:prepare</code> 生成的标签, 因此用户需要手动删除;</li>
<li><code>release:perform</code> 执行版本发布, 签出 <code>release:prepare</code> 生成的标签中的源代码, 并在此基础上执行 <code>mvn deploy</code> 命令打包并部署构件至仓库</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置maven-release-plugin --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-release-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 标签的基础目录 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">tagBase</span>&gt;</span>http://xxx.com/tags<span class="tag">&lt;/<span class="name">tagBase</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置SCM --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">scm</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- connection表示只读的scm地址 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">connection</span>&gt;</span>scm:svn:http://xxx.com/project<span class="tag">&lt;/<span class="name">connection</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- developerConnection表示可写的scm地址 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">developerConnection</span>&gt;</span>scm:svn:http://xxx.com/project<span class="tag">&lt;/<span class="name">developerConnection</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- url表示可以在浏览器中访问的scm地址 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">url</span>&gt;</span>http://xxx.com/project<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">scm</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>connection</code> 和 <code>developerConnection</code> 必须以 <code>scm</code> 开头, 冒号之后的部分表示版本控制工具类型 (这里是 <code>svn</code>), Maven 还支持 <code>cvs</code>, <code>git</code> 等, 接下来才是实际的 <code>scm</code> 地址</p>
</blockquote>
<blockquote>
<p>系统必须要提供 <code>svn</code> 命令行工具, Maven 需要 <code>svn</code> 命令行工具执行相关操作, 而无法使用图形化工具, 如 <code>TortoiseSVN</code></p>
</blockquote>
<blockquote>
<p><code>POM</code> 必须配置了可用的部署仓库, 因为 <code>release:perform</code> 会执行 <code>deploy</code></p>
</blockquote>
<h2 id="自动化创建分支">自动化创建分支</h2>
<h2 id="gpg签名">GPG签名</h2>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven 012 Nexus私服</title>
    <url>/2019/02/20/maven/012/</url>
    <content><![CDATA[<h1 id="nexus-私服">Nexus 私服</h1>
<p>有三种专门的 Maven 仓库管理软件可以用来帮助大家建立私服:</p>
<ol type="1">
<li><p>Apache 基金会的 Archiva;</p></li>
<li><p>JFrog 的 Artifactory;</p></li>
<li><p>Sonatype 的 Nexus</p></li>
</ol>
<p>其中, Archiva 是开源的, 而 Artifactory 和 Nexus 的核心也是开源的</p>
<h2 id="nexus-简介">Nexus 简介</h2>
<p><strong>Nexus</strong> 分为开源版和专业版, 其中开源版本基于 <code>GPLv3</code> 许可证, 其特性足以满足大部分 Maven 用户的需要</p>
<p>以下是一些 Nexus 开源版本的特性:</p>
<ul>
<li>较小的内存占用 (最少仅为 28 MB);</li>
<li>基于 ExtJS 的友好界面;</li>
<li>基于 Restlet 的完全 REST API;</li>
<li>支持代理仓库, 宿主仓库和仓库组基于文件系统, 不需要数据库;</li>
<li>支持仓库索引和搜索;</li>
<li>支持从界面上传 Maven 构件;</li>
<li>细粒度的安全控制</li>
</ul>
<h2 id="安装-nexus">安装 Nexus</h2>
<p>Nexus 是典型的 Java Web 应用, 它有两种安装包, 一种是包含 Jetty 容器的 <code>Bundle</code> 包, 另一种是不包含 Web 容器的 <code>war</code> 包</p>
<h3 id="下载-nexus">下载 Nexus</h3>
<p>Nexus 下载地址 <a href="https://www.sonatype.com/download-oss-sonatype">Download</a></p>
<h3 id="bundle-方式安装-nexus">Bundle 方式安装 Nexus</h3>
<p>Nexus 的 <code>Bundle</code> 自带了 Jetty 容器, 因此用户不需要额外的 Web 容器就能直接启动 Nexus, 首先将 <code>Bundle</code> 文件解压, 这时就会得到如下两个子目录:</p>
<ul>
<li><code>nexus-webapp-1.7.2/</code> 该目录包含了 Nexus 运行所需要的文件, 如启动脚本, 依赖 <code>jar</code> 包等;</li>
<li><code>sonatype-work/</code> 该目录包含 Nexus 生成的配置文件, 日志文件, 仓库文件等</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入根目录的bin目录下, 执行nexus.exe /run运行</span></span><br><span class="line">λ <span class="built_in">cd</span> nexus<span class="literal">-3</span>.<span class="number">13.0</span><span class="literal">-01</span>\bin\</span><br><span class="line">λ nexus.exe /run</span><br><span class="line">-------------------------------------------------</span><br><span class="line"></span><br><span class="line">Started Sonatype Nexus OSS <span class="number">3.13</span>.<span class="number">0</span><span class="literal">-01</span></span><br><span class="line"></span><br><span class="line">-------------------------------------------------</span><br><span class="line"><span class="comment"># 浏览器访问http://127.0.0.1:8081/</span></span><br></pre></td></tr></table></figure>
<h3 id="登录-nexus">登录 Nexus</h3>
<p>Nexus 拥有全面的权限控制功能, 默认的 Nexus 访问都是匿名的, 而匿名用户仅包含一些最基本的权限, 要全面学习和管理 Nexus, 就必须以管理员方式登录, 可以单击界面右上角的 <kbd>Log In</kbd> 进行登录, Nexus 的默认管理员用户名和密码为 <code>admin/admin123</code></p>
<h2 id="nexus-的仓库与仓库组">Nexus 的仓库与仓库组</h2>
<p>作为 Maven 仓库服务软件, <strong>仓库</strong> 自然是 Nexus 中最重要的概念, Nexus 包含了各种类型的仓库概念, 包括 <strong>代理仓库</strong>, <strong>宿主仓库</strong> 和 <strong>仓库组</strong> 等, 每一种仓库都提供了丰富实用的配置参数, 方便用户根据需要进行定制</p>
<pre class="mermaid">graph LR
title[图 各种类型的Nexus仓库]
title --> E
style title fill:#FFF,stroke:#FFF
linkStyle 0 stroke:#FFF,stroke-width:0;
A(Maven)
B(宿主仓库A)
C(宿主仓库B)
D(代理仓库A)
E(代理仓库B)
F(远程仓库X)
G(远程仓库Y)
H{仓库组}
A --> B
A --> H
A --> E
H --> C
H --> D
D --> F
E --> G</pre>
<h2 id="配置-maven-从-nexus-下载构件">配置 Maven 从 Nexus 下载构件</h2>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 代码清单9-1 在POM中配置Nexus仓库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://127.0.0.1:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">releases</span>&gt;</span><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span><span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span><span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://127.0.0.1:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">releases</span>&gt;</span><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span><span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span><span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样的配置只对当前 Maven 项目有效, 在实际应用中, 往往想要通过一次配置就能让本机所有的 Maven 项目都使用自己的 Maven 私服, Maven 的 <code>setting.xml</code> 文件中的配置对所有本机 Maven 项目有效</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 代码清单9-2 在settings.xml中配置Nexus仓库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 配置了id为nexus的profile, 这个profile包含了相关的仓库配置 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://127.0.0.1:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">releases</span>&gt;</span><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span><span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span><span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://127.0.0.1:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">releases</span>&gt;</span><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span><span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span><span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 将nexus这个profile激活, 这样当执行Maven构建的时候, 激活的profile会将仓库配置应用到项目中去 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 代码清单9-3 配置镜像让Maven只使用私服 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://127.0.0.1:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="部署构件至-nexus">部署构件至 Nexus</h2>
<p>对于另一类 Nexus 仓库, 宿主仓库来说, 它们的主要作用是储存组织内部的, 或者一些无法从公共仓库中获得的第三方构件, 供大家下载使用, 用户可以配置 Maven 自动部署构件至 Nexus 的宿主仓库, 也可以通过界面手动上传构件</p>
<h3 id="使用-maven-部署构件至-nexus">使用 Maven 部署构件至 Nexus</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 代码清单9-4 配置Maven部署构件至Nexus --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus Releases Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://127.0.0.1:8081/repository/maven-releases/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus Snapshots Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://127.0.0.1:8081/repository/maven-snapshots/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 代码清单9-5 为部署构件至Nexus配置认证信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">&lt;!-- Nexus的仓库对于匿名用户是只读的, 为了能够部署构件, 还需要配置认证信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">password</span>&gt;</span>*****<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">password</span>&gt;</span>*****<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="手动部署第三方构件至-nexus">手动部署第三方构件至 Nexus</h3>
<p>某些 Java <code>Jar</code> 文件, 由于许可证的因素, 它们无法公开地放在公共仓库中, 此外, 还有大量的小型开源项目, 它们没有把自己的构件分发到中央仓库中, 也没有维护自己的仓库, 因此也无法从公共仓库获得, 这个时候就需要将这类构件手动下载到本地, 然后通过 Nexus 的界面上传到私服中</p>
<h2 id="nexus-的权限管理">Nexus 的权限管理</h2>
<h3 id="nexus-的访问控制模型">Nexus 的访问控制模型</h3>
<p>Nexus 是基于权限 (Privilege) 做访问控制的, 服务器的每一个资源都有相应的权限来控制, 因此用户执行特定的操作时就必须拥有必要的权限, 管理员必须以角色 (Role) 的方式将权限赋予 Nexus 用户</p>
<p>Nexus 预定义了两个用户, 这两个用户对应了两个权限级别:</p>
<ul>
<li><strong><code>admin</code></strong> 该用户拥有对 Nexus 服务的完全控制, 默认密码为 <code>admin123</code>;</li>
<li><strong><code>anonymous</code></strong> 该用户对应了所有未登录的匿名用户, 它们可以浏览仓库并进行搜索</li>
</ul>
<p>Nexus 预定义的一些常用且重要的角色包括:</p>
<ul>
<li><strong><code>UI: Basic UI Privileges</code></strong> 包含了访问 Nexus 界面必须的最基本的权限;</li>
<li><strong><code>UI: Repository Browser</code></strong> 包含了浏览仓库页面所需要的权限;</li>
<li><strong><code>UI: Search</code></strong> 包含了访问快速搜索栏及搜索页面所需要的权限;</li>
<li><strong><code>Repo: All Repositories (Read)</code></strong> 给予用户读取所有仓库内容的权限, 没有仓库的读权限, 用户将无法在仓库页面上看到实际的仓库内容, 也无法使用 Maven 从仓库下载构件;</li>
<li><strong><code>Repo: All Repositories (Full Control)</code></strong> 给予用户完全控制所有仓库内容的权限, 用户不仅可以浏览, 下载构件, 还可以部署构件及删除仓库内容</li>
</ul>
<h3 id="为项目分配独立的仓库">为项目分配独立的仓库</h3>
<p>在组织内部, 如果所有项目都部署快照及发布版构件至同样的仓库, 就会存在潜在的冲突及安全问题, 我们不想让项目 A 的部署影响到项目 B, 反之亦然, 解决的方法就是为每个项目分配独立的仓库, 并且只将仓库的部署, 修改和删除权限赋予该项目的成员, 其他用户只能读取, 下载和搜索该仓库的内容</p>
<h2 id="nexus-的调度任务">Nexus 的调度任务</h2>
<p>Nexus 提供了一系列可配置的调度任务来方便用户管理系统, 用户可以设定这些任务运行的方式, 例如每天, 每周, 手动等, 调度任务会在适当的时候在后台运行, 当然, 用户还是能够在界面观察它们的状态的</p>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 001 简介</title>
    <url>/2018/08/29/spring/001/</url>
    <content><![CDATA[<h1 id="spring-简介">Spring 简介</h1>
<h2 id="定义">定义</h2>
<p><strong>Spring</strong> 是一个开源框架, 是为了解决企业级应用开发的复杂性而创建的, 使用 Spring 可以让简单的 JavaBean 实现之前只有 EJB 才能完成的事情, 但 Spring 不仅仅局限于服务器端开发, 任何 Java 应用都能在简单性, 可测试性和松耦合等方面从 Spring 中获益</p>
<p>Spring 采取了以下 4 种关键策略降低 Java 开发的复杂性:</p>
<ul>
<li>基于 POJO 的轻量级和最小侵入性编程;</li>
<li>通过依赖注入和面向接口实现松耦合;</li>
<li>基于切面和惯例进行声明式编程;</li>
<li>通过切面和模板减少样板式代码</li>
</ul>
<h2 id="框架">框架</h2>
<p>在 Spring 4.0 中, <strong>Spring 框架</strong> 的发布版本包括了 20 个不同的模块, 每个模块会有 3 个 JAR 文件 (二进制类库, 源码的 JAR 文件以及 JavaDoc 的 JAR 文件), 这些模块依据其所属的功能可以划分为 6 类不同的功能</p>
<ol type="1">
<li>Spring 核心容器
<ul>
<li>Beans</li>
<li>Core</li>
<li>Context</li>
<li>Expression</li>
<li>Context support</li>
</ul></li>
<li>面向切面编程
<ul>
<li>AOP</li>
<li>Aspects</li>
</ul></li>
<li>数据访问与集成
<ul>
<li>JDBC</li>
<li>Transaction</li>
<li>ORM</li>
<li>OXM</li>
<li>Messaging</li>
<li>JMS</li>
</ul></li>
<li>Web 与远程调用
<ul>
<li>Web</li>
<li>Web servlet</li>
<li>Web portlet</li>
<li>WebSocket</li>
</ul></li>
<li>Instrumentation
<ul>
<li>Instrument</li>
<li>Instrument Tomcat</li>
</ul></li>
<li>测试
<ul>
<li>Test</li>
</ul></li>
</ol>
<h2 id="容器">容器</h2>
<p>在基于 Spring 的应用中, 应用对象生存于 <strong>Spring 容器(container)</strong> 中, Spring 容器负责创建对象, 装配它们, 配置它们并管理它们的整个生命周期</p>
<p>Spring 容器并不是只有一个, Spring 自带了多个容器实现, 可以归为两种不同的类型:</p>
<ul>
<li><code>BeanFactory(org.springframework.beans.factory.BeanFactory)</code> 最简单的容器, 提供基本的 DI 支持;</li>
<li><code>ApplicationContext(org.springframework.context.ApplicationContext)</code> 基于 <code>BeanFactory</code> 构建, 并提供应用框架级别的服务</li>
</ul>
<blockquote>
<p>虽然可以在 <code>BeanFactory</code> 和 <code>ApplicationContext</code> 之间任选一种, 但 <code>BeanFactory</code> 对大多数应用来说往往太低级了, 因此, <code>ApplicationContext</code> 要比 <code>BeanFactory</code> 更受欢迎</p>
</blockquote>
<h2 id="应用上下文">应用上下文</h2>
<p>Spring 通过 <strong>应用上下文(Application Context)</strong> 装载 bean 的定义并把它们组装起来, Spring 应用上下文全权负责对象的创建和组装</p>
<p>Spring 自带了多种类型的应用上下文, 下面罗列几个:</p>
<ul>
<li><code>AnnotationConfigApplicationContext</code> 从一个或多个基于 Java 的配置类中加载 Spring 应用上下文;</li>
<li><code>AnnotationConfigWebApplicationContext</code> 从一个或多个基于 Java 的配置类中加载 Spring Web 应用上下文;</li>
<li><code>ClassPathXmlApplicationContext</code> 从类路径下的一个或多个 XML 配置文件中加载上下文定义, 把应用上下文的定义文件作为类资源;</li>
<li><code>FileSystemXmlapplicationcontext</code> 从文件系统下的一个或多个 XML 配置文件中加载上下文定义;</li>
<li><code>XmlWebApplicationContext</code> 从 Web 应用下的一个或多个 XML 配置文件中加载上下文定义。</li>
</ul>
<pre class="mermaid">graph TB
title[图 bean在Spring容器中的生命周期过程]
title --> A
style title fill:#FFF,stroke:#FFF
linkStyle 0 stroke:#FFF,stroke-width:0;
A((实例化))
B(填充属性)
C(调用BeanNameAware的setBeanName方法)
D(调用BeanFactoryAware的setBeanFactory方法)
E(调用ApplicationContextAware的setApplicationContext方法)
F(调用BeanPostProcessor的预初始化方法)
G(调用InitializingBean的afterPropertiesSet方法)
H(调用自定义初始化方法)
I(调用BeanPostProcessor的初始化方法)
J(bean可以使用了)
K((容器关闭))
L(调用DisposableBean的destory方法)
M(调用自定义的销毁方法)
A --> B
B --> C
C --> D
D --> E
E --> F
F --> G
G --> H
H --> I
I --> J
J --> K
K --> L
L --> M</pre>
<h2 id="装配">装配</h2>
<p>在 Spring 中, 对象无需自己查找或创建与其所关联的其他对象, 相反, 容器负责把需要相互协作的对象引用赋予各个对象, 创建对象之间协作关系的行为通常称为 <strong>装配(wiring)</strong>, 这也是 <strong>依赖注入(DI)</strong> 的本质</p>
<p>Spring 提供了三种主要的装配机制:</p>
<ul>
<li>在 XML 中进行显示配置;</li>
<li>在 Java 中进行显示配置;</li>
<li>隐式的 bean 发现机制和自动装配</li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 002 自动化装配</title>
    <url>/2019/04/06/spring/002/</url>
    <content><![CDATA[<h1 id="自动化装配">自动化装配</h1>
<p>Spring 从两个角度来实现自动化装配:</p>
<ul>
<li><strong>组件扫描(component scanning)</strong> Spring 会自动发现应用上下文中所创建的 bean;</li>
<li><strong>自动装配(autowiring)</strong> Spring 自动满足 bean 之间的依赖</li>
</ul>
<h2 id="组件扫描">组件扫描</h2>
<p>组件扫描默认是不启用的, 需要显式配置</p>
<h3 id="javaconfig-配置">JavaConfig 配置</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 启用组件扫描 */</span></span><br><span class="line"><span class="keyword">package</span> com.janz.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 默认@ComponentScan会扫描与配置类相同的包及子包</span></span><br><span class="line"><span class="comment">// value/basePackages属性可以指定不同的包</span></span><br><span class="line"><span class="comment">// basePackageClasses属性可以指定包中所包含的类或接口</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &quot;com.janz.spring&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="xml-配置">XML 配置</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过XML启用组件扫描 --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- base-package属性指定包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.janz.spring&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="自动装配">自动装配</h2>
<h3 id="示例">示例</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 可被发现的bean */</span></span><br><span class="line"><span class="keyword">package</span> com.janz.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @Component注解表明这个类会作为组件类, 并告知Spring要为这个类创建bean</span></span><br><span class="line"><span class="comment">// Spring会根据类名为其指定一个ID, 这个bean所给定的ID为sgtPeppers, 也就是将类名的第一个字母变为小写</span></span><br><span class="line"><span class="comment">// @Component(value = &quot;xxx&quot;)可为bean自定义ID</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SgtPeppers</span> <span class="keyword">implements</span> <span class="title">CompactDisc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String title = <span class="string">&quot;Sgt. Pepper&#x27;s Lonely Hearts Club Band&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String artist = <span class="string">&quot;The Beatles&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Playing &quot;</span> + title + <span class="string">&quot; by &quot;</span> + artist);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 注入装配的bean */</span></span><br><span class="line"><span class="keyword">package</span> com.janz.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayer</span> <span class="keyword">implements</span> <span class="title">MediaPlayer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CompactDisc cd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @Autowired注解表明当Spring创建CDPlayer bean的时候, 会通过这个构造器来进行实例化并且会传入一个可设置给CompactDisc类型的bean</span></span><br><span class="line">    <span class="comment">// @Autowired注解不仅可以能够用在构造器上, 还能用在属性的Setter方法上</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CDPlayer</span><span class="params">(CompactDisc cd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cd = cd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cd.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不管是构造器, Setter方法还是其他的方法, Spring都会尝试满足方法参数上所声明的依赖, 假如有且只有一个bean匹配依赖需求的话, 那么这个bean将会被装配进来</span></span><br><span class="line"><span class="comment">// 如果没有匹配的bean, 那么在应用上下文创建的时候, Spring会抛出一个异常</span></span><br><span class="line"><span class="comment">// 如果有多个bean都能满足依赖关系的话, Spring会抛出一个异常, 表明没有明确指定要选择哪个bean进行自动装配</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 为了避免异常的出现, 可以将@Autowired的required属性设置为false */</span></span><br><span class="line"><span class="meta">@Autowired(required = false)</span></span><br><span class="line"><span class="comment">// 将required属性设置为false时, Spring会尝试执行自动装配, 如果没有匹配的bean的话, Spring将会让这个bean处于未装配的状态, 这需要谨慎对待, 如果在代码中没有进行null检查的话, 这个处于未装配状态的属性有可能会出现NullPointerException</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Spring 支持将 <code>@Name</code> 作为 <code>@Component</code> 注解的替代方案, 两者之间有一些细微的差异, 但是在大多数场景中, 它们是可以互相替换的</p>
</blockquote>
<blockquote>
<p>Spring 同时支持 <code>@Inject</code> 和 <code>@Autowired</code>, 在大多数场景下, 它们都是可以互相替换的</p>
</blockquote>
<h3 id="测试">测试</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* JUnit测试 */</span></span><br><span class="line"><span class="keyword">package</span> com.janz.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Rule;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.contrib.java.lang.system.SystemOutRule;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="comment">// 读取Java代码配置</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = CDPlayerConfig.class)</span></span><br><span class="line"><span class="comment">// 读取XML配置</span></span><br><span class="line"><span class="comment">// @ContextConfiguration(locations = &quot;classpath:cd-player-config.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Rule</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> SystemOutRule rule = <span class="keyword">new</span> SystemOutRule().enableLog();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CompactDisc cd;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MediaPlayer player;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cdShouldNotBeNull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Assert.assertNotNull(cd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        player.play();</span><br><span class="line">        Assert.assertEquals(<span class="string">&quot;Playing Sgt. Pepper&#x27;s Lonely Hearts Club Band by The Beatles\r\n&quot;</span>, rule.getLog());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在测试代码中使用 <code>System.out.println()</code> 是稍微有点棘手的事情, 因此, 该样例中使用了 <code>SystemOutRule</code>, 这是来源于 <a href="https://stefanbirkner.github.io/system-rules/index.html">System Rules</a> 库的一个 <code>JUnit</code> 规则, 该规则能够基于控制台的输出编写断言</p>
</blockquote>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 003 显式装配</title>
    <url>/2019/04/07/spring/003/</url>
    <content><![CDATA[<h1 id="显式装配">显式装配</h1>
<p>尽管在很多场景下通过组件扫描和自动装配实现 Spring 的自动化装配是更为推荐的方式, 但有时候自动化配置的方案行不通, 比如想要将第三方库的组件装配到应用中, 在这种情况下是没有办法在它的类上添加 <code>@Component</code> 和 <code>@Autowired</code> 注解的, 因此就需要显式配置 Spring</p>
<h2 id="javaconfig-装配">JavaConfig 装配</h2>
<p>创建配置类的关键在于为其添加 <code>@Configuration</code> 注解, 该注解表明这个类是一个配置类, 该类应该包含在 Spring 应用上下文中如何创建 bean 的细节</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* JavaConfig配置 */</span></span><br><span class="line"><span class="keyword">package</span> com.janz.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @Bean注解会告诉Spring这个方法将会返回一个对象, 该对象要注册为Spring应用上下文中的bean</span></span><br><span class="line">    <span class="comment">// @Bean(name = &quot;xxx&quot;)可以设置成一个不同的名字</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompactDisc <span class="title">sgtPeppers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SgtPeppers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器注入 方法1: 引用创建bean的方法实现注入</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MediaPlayer <span class="title">cdPlayer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CDPlayer(sgtPeppers());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造器注入 方法2: 通过参数实现注入</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MediaPlayer <span class="title">cdPlayer2</span><span class="params">(CompactDisc compactDisc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CDPlayer(compactDisc);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 属性注入</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MediaPlayer <span class="title">cdPlayer3</span><span class="params">(CompactDisc compactDisc)</span> </span>&#123;</span><br><span class="line">        CDPlayer2 player = <span class="keyword">new</span> CDPlayer2();</span><br><span class="line">        player.setCompactDisc(compactDisc);</span><br><span class="line">        <span class="keyword">return</span> player;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为 <code>sgtPeppers()</code> 方法上添加了 <code>@Bean</code> 注解, Spring 将会拦截所有对它的调用, 并确保直接返回该方法所创建的bean, 而不是每次都对其进行实际的调用</p>
</blockquote>
<h2 id="xml-装配">XML 装配</h2>
<p>创建 XML 配置文件, 要以 <code>&lt;beans&gt;</code> 元素为根</p>
<blockquote>
<p>创建和管理 Spring XML 配置文件的一种简便方式是使用 <a href="https://spring.io/tools">Spring Tool Suite</a>, 能够创建 Spring XML配置文件, 并且可以选择可用的配置命名空间, 能够在很大程度上确保 Spring XML 配置的合法性</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- XML装配 --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:c</span>=<span class="string">&quot;http://www.springframework.org/schema/c&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 声明bean, 如果没有明确给定ID, 这个bean将会根据全限定类名来进行命名, 如com.janz.spring.SgtPeppers#0, 其中#0是一个计数的形式, 用来区分相同类型的其他bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;compactDisc&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.janz.spring.SgtPeppers&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用constructor-arg注入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cdPlayer&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.janz.spring.CDPlayer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;cd&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;compactDisc&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用c-注入, 有以下两种方式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cdPlayer2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.janz.spring.CDPlayer&quot;</span> <span class="attr">c:cd-ref</span>=<span class="string">&quot;compactDisc&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cdPlayer3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.janz.spring.CDPlayer&quot;</span> <span class="attr">c:_0-ref</span>=<span class="string">&quot;compactDisc&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="构造器注入">构造器注入</h3>
<h4 id="注入-bean-引用">注入 bean 引用</h4>
<p>具体到构造器注入, 有两种基本的配置方案可供选择:</p>
<ul>
<li><code>&lt;constructor-arg&gt;</code> 元素</li>
<li>使用 Spring 3.0 所引入的 <code>c-</code> 命名空间</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过Spring的c-命名空间将bean引用注入到构造器参数中 --&gt;</span></span><br><span class="line">     c      :        cd-ref       = &quot;compactDisc&quot;</span><br><span class="line">------------ ---------- ---------- --------------</span><br><span class="line">c-命名空间前缀 构造器参数名 注入bean引用 要注入的bean的ID</span><br><span class="line"><span class="comment">&lt;!-- 参数名可以使用参数在整个参数列表中的位置信息替代 --&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="注入字面量">注入字面量</h4>
<p>装配字面量与装配引用的区别在于去掉了 <code>ref</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- constructor-arg元素进行注入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;blankDisc&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.janz.spring.BlankDisc&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;title&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Sgt. Pepper&#x27;s Lonely Hearts Club Band&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;artist&quot;</span> <span class="attr">value</span>=<span class="string">&quot;The Beatles&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- c-命名空间进行注入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;blankDisc2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.janz.spring.BlankDisc&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">c:title</span>=<span class="string">&quot;Sgt. Pepper&#x27;s Lonely Hearts Club Band&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">c:artist</span>=<span class="string">&quot;The Beatles&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="注入集合">注入集合</h4>
<p>在装配集合方面, <code>&lt;constructor-arg&gt;</code> 比 <code>c-</code> 命名空间的属性更有优势, 使用 <code>c-</code> 命名空间注入集合见 <code>util-</code> 命名空间</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用list元素声明一个列表 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.janz.spring.BlankDisc2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;title&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Sgt. Pepper&#x27;s Lonely Hearts Club Band&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;artist&quot;</span> <span class="attr">value</span>=<span class="string">&quot;The Beatles&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;tracks&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>Sgt. Pepper&#x27;s Lonely Hearts Club Band<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>With a Little Help from My Friends<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- other tracks omitted for brevity --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- value元素用来指定列表中的每个元素, 与之类似, 可以使用ref元素替代value实现bean引用列表 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 可以按照同样的方式使用set和map元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>Sgt. Pepper&#x27;s Lonely Hearts Club Band<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>With a Little Help from My Friends<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;track1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Sgt. Pepper&#x27;s Lonely Hearts Club Band&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;track2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;With a Little Help from My Friends&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注入null --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="属性注入">属性注入</h3>
<p>属性注入有两种基本的配置方案可供选择:</p>
<ul>
<li><code>property</code> 元素;</li>
<li><code>p-</code> 命名空间</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 属性注入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.janz.spring.CDPlayer2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;compactDisc&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;compactDisc&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.janz.spring.CDPlayer2&quot;</span> <span class="attr">p:compactDisc-ref</span>=<span class="string">&quot;compactDisc&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- bean引用/字面量/集合注入参照构造器注入, 格式基本一样 --&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过Spring的p-命名空间将bean引用注入到属性中 --&gt;</span></span><br><span class="line">     p      : compactDisc-ref       = &quot;compactDisc&quot;</span><br><span class="line">------------ ------------ ---------- --------------</span><br><span class="line">p-命名空间前缀     属性名    注入bean引用 要注入的bean的ID</span><br></pre></td></tr></table></figure>
<h3 id="util-命名空间">util 命名空间</h3>
<table>
<thead>
<tr class="header">
<th>元素</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>&lt;util:constant&gt;</code></td>
<td>引用某个类型的 <code>public</code> <code>static</code> 域, 并将其暴露为 bean</td>
</tr>
<tr class="even">
<td><code>&lt;util:list&gt;</code></td>
<td>创建一个 <code>java.util.List</code> 类型的 bean, 其中包含值或引用</td>
</tr>
<tr class="odd">
<td><code>&lt;util:map&gt;</code></td>
<td>创建一个 <code>java.util.Map</code> 类型的 bean, 其中包含值或引用</td>
</tr>
<tr class="even">
<td><code>&lt;util:properties&gt;</code></td>
<td>创建一个 <code>java.util.Properties</code> 类型的 bean</td>
</tr>
<tr class="odd">
<td><code>&lt;util:property-path&gt;</code></td>
<td>引用一个 bean 的属性 (或内嵌属性), 并将其暴露为 bean</td>
</tr>
<tr class="even">
<td><code>&lt;util:set&gt;</code></td>
<td>创建一个 <code>java.util.Set</code> 类型的 bean, 其中包含值或引用</td>
</tr>
</tbody>
</table>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 借助util:list, 将tracks声明到单独的bean, 再像其他的bean那样注入参数中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:list</span> <span class="attr">id</span>=<span class="string">&quot;trackList&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>Sgt. Pepper&#x27;s Lonely Hearts Club Band<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>The Beatles<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.janz.spring.BlankDisc2&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">c:title</span>=<span class="string">&quot;Sgt. Pepper&#x27;s Lonely Hearts Club Band&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">c:artist</span>=<span class="string">&quot;The Beatles&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">c:tracks-ref</span>=<span class="string">&quot;trackList&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="导入和混合配置">导入和混合配置</h2>
<p>Spring 在自动装配时, 它并不在意要装配的 bean 来自哪里, 不管它是在 JavaConfig 或 XML 中声明的还是通过组件扫描获取到的</p>
<h3 id="javaconfig-导入其他配置">JavaConfig 导入其他配置</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* JavaConfig导入其他配置 */</span></span><br><span class="line"><span class="keyword">package</span> com.janz.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Import;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ImportResource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// @Import注解导入其他JavaConfig配置</span></span><br><span class="line"><span class="meta">@Import(value = xxx.class)</span></span><br><span class="line"><span class="comment">// @ImportResource注解导入其他XML配置</span></span><br><span class="line"><span class="meta">@ImportResource(value = &quot;xxx&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="xml导入其他配置">XML导入其他配置</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- XML导入其他配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 导入其他XML配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;xxx&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 导入其他JavaConfig配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;xxxConfig&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 004 高级装配</title>
    <url>/2019/04/08/spring/004/</url>
    <content><![CDATA[<h1 id="高级装配">高级装配</h1>
<h2 id="坏境与-profile">坏境与 profile</h2>
<p>在开发软件的时候, 有一个很大的挑战就是将应用程序从一个环境迁移到另外一个环境, Spring 为环境相关的 bean 所提供的解决方案与构建时的方案没有太大的差别, Spring 引入了 bean profile 的功能, 要使用 profile, 首先要将所有不同的 bean 定义整理到一个或多个 profile 之中, 在将应用部署到每个环境时, 要确保对应的 profile 处于激活(active) 的状态</p>
<h3 id="java-配置">Java 配置</h3>
<p>在 Java 配置中, 可以使用 <code>@Profile</code> 注解指定某个 bean 属于哪个 profile, 没有指定 profile 的 bean 始终都会被创建, 与激活哪儿 profile 没有关系</p>
<blockquote>
<p>在 Spring 3.1 中, 只能在类级别上使用 <code>@Profile</code> 注解, 不过, 从 Spring 3.2 开始, 也可以在方法级别上使用 <code>@Profile</code> 注解, 与 <code>@Bean</code> 注解一同使用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类级别使用@profile</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// @Profile注解应用在类级别上, 会告诉Spring这个配置类中的bean只有在devprofile激活时才会创建, 如果devprofile没有激活的话, 那么带有@Bean注解的方法都会被忽略掉</span></span><br><span class="line"><span class="meta">@Profile(&quot;dev&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DevConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Knight <span class="title">knight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DamselRescuingKnight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Profile(&quot;prod&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProdConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Knight <span class="title">knight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BraveKnight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法级别使用@Profile</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KnightConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile(&quot;dev&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Knight <span class="title">knight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DamselRescuingKnight();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile(&quot;prod&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Knight <span class="title">braveKnight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BraveKnight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="xml-配置">XML 配置</h3>
<p>可以通过 <code>&lt;beans&gt;</code> 元素的 <code>profile</code> 属性, 在 XML 中配置 profile bean</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 多配置文件, 每个文件定义一个profile --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">profile</span>=<span class="string">&quot;dev&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;knight&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.janz.spring.knights.DamselRescuingKnight&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以在根 <code>&lt;beans&gt;</code> 元素中嵌套定义 <code>&lt;beans&gt;</code> 元素, 而不是为每个环境都创建一个 profile XML 文件, 这能够将所有的 profile bean 定义放到同一个 XML 文件中</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 单配置文件, 定义多个profile --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">&quot;dev&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.janz.spring.knights.DamselRescuingKnight&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">&quot;prod&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.janz.spring.knights.BraveKnight&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="激活-profile">激活 profile</h3>
<p>Spring 在确定哪个 profile 处于激活状态时, 需要依赖两个独立的属性</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.profiles.active</span></span><br><span class="line"><span class="attr">spring.profiles.default</span></span><br><span class="line"><span class="comment"># 如果设置了spring.profiles.active属性的话, 那么它的值就会用来确定哪个profile是激活的, 但如果没有设置spring.profiles.active属性的话, 那Spring将会查找spring.profiles.default的值</span></span><br><span class="line"><span class="comment"># 如果spring.profiles.active和spring.profiles.default均没有设置的话, 那就没有激活的profile, 因此只会创建那些没有定义在profile中的bean</span></span><br><span class="line"><span class="comment"># 同时激活多个profile可以通过列出多个profile名称, 并以逗号分隔来实现</span></span><br></pre></td></tr></table></figure>
<p>有多种方式来设置这两个属性:</p>
<ul>
<li>作为 <code>DispatcherServlet</code> 的初始化参数;</li>
<li>作为 Web 应用的上下文参数;</li>
<li>作为 JNDI 条目;</li>
<li>作为环境变量;</li>
<li>作为 JVM 的系统属性;</li>
<li>在集成测试类上, 使用 <code>@ActiveProfiles</code> 注解设置</li>
</ul>
<h3 id="测试">测试</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 使用@ActiveProfiles激活devprofile */</span></span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ActiveProfiles(value = &#123;&quot;dev&quot;&#125;)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123;KnightConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KnightTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Rule</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> SystemOutRule rule = <span class="keyword">new</span> SystemOutRule().enableLog();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Knight knight;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        knight.embarkOnQuest();</span><br><span class="line">        Assert.assertEquals(<span class="string">&quot;Embarking on quest to rescue the damsel!\r\n&quot;</span>, rule.getLog());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="条件化的-bean">条件化的 bean</h2>
<p>Spring 4 引入了一个新的 <code>@Conditional</code> 注解, 它可以用到带有 <code>@Bean</code> 注解的方法上, 如果给定的条件计算结果为 <code>true</code>, 就会创建这个 bean, 否则的话, 这个 bean 会被忽略</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 条件化的配置bean */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MagicConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">// @Conditional给定了一个class, 该类实现了Condition接口, 如果matches()返回true, 那么就会创建带有@Conditional注解的bean, 否则就不会创建bean</span></span><br><span class="line">    <span class="meta">@Conditional(MagicExistsCondition.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Magic <span class="title">magic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MagicBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 自定义条件类 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MagicExistsCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        Environment env = context.getEnvironment();</span><br><span class="line">        <span class="keyword">return</span> env.containsProperty(<span class="string">&quot;magic&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 本例中, matches方法通过给定的ConditionContext对象进而得到Environment对象, 并使用这个对象检查环境中是否存在名为magic的环境属性</span></span><br></pre></td></tr></table></figure>
<h3 id="conditioncontext">ConditionContext</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ConditionContext是一个接口, 大致如下 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConditionContext</span> </span>&#123; </span><br><span class="line">    <span class="function">BeanDefinitionRegistry <span class="title">getRegistry</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ConfigurableListableBeanFactory <span class="title">getBeanFactory</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Environment <span class="title">getEnvironment</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ResourceLoader <span class="title">getResourceLoader</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ClassLoader <span class="title">getClassLoader</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>借助 <code>getRegistry()</code> 返回的 <code>BeanDefinitionRegistry</code> 检查 bean 定义;</li>
<li>借助 <code>getBeanFactory()</code> 返回的 <code>ConfigurableListableBeanFactory</code> 检查 bean 是否存在, 甚至探查 bean 的属性;</li>
<li>借助 <code>getEnvironment()</code> 返回的 <code>Environment</code> 检查环境变量是否存在以及它的值是什么;</li>
<li>读取并探查 <code>getResourceLoader()</code> 返回的 <code>ResourceLoader</code> 所加载的资源;</li>
<li>借助 <code>getClassLoader()</code> 返回的 <code>ClassLoader</code> 加载并检查类是否存在</li>
</ul>
<h3 id="annotatedtypemetadata">AnnotatedTypeMetadata</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* AnnotatedTypeMetadata能够检查带有@Bean注解的方法上还有什么其他的注解 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AnnotatedTypeMetadata</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAnnotated</span><span class="params">(String annotationType)</span></span>;</span><br><span class="line">    <span class="function">Map&lt;String, Object&gt; <span class="title">getAnnotationAttributes</span><span class="params">(String annotationType)</span></span>;</span><br><span class="line">    <span class="function">Map&lt;String, Object&gt; <span class="title">getAnnotationAttributes</span><span class="params">(String annotationType, <span class="keyword">boolean</span> classValuesAsString)</span></span>;</span><br><span class="line">    <span class="function">MultiValueMap&lt;String, Object&gt; <span class="title">getAllAnnotationAttributes</span><span class="params">(String annotationType)</span></span>;</span><br><span class="line">    <span class="function">MultiValueMap&lt;String, Object&gt; <span class="title">getAllAnnotationAttributes</span><span class="params">(String annotationType, <span class="keyword">boolean</span> classValuesAsString)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>借助 <code>isAnnotated()</code> 方法, 能够判断带有 <code>@Bean</code> 注解的方法是不是还有其他特定的注解;</li>
<li>借助其他那些方法, 能够检查 <code>@Bean</code> 注解的方法上其他注解的属性</li>
</ul>
<h3 id="测试-1">测试</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="comment">// env.properties中声明magic属性</span></span><br><span class="line"><span class="meta">@TestPropertySource(value = &#123;&quot;classpath:env.properties&quot;&#125;)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = MagicConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MagicTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Magic magic;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">magicNotNull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Assert.assertNotNull(magic);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="处理自动装配的歧义性">处理自动装配的歧义性</h2>
<p>自动装配能够提供很大的帮助, 因为它会减少装配应用程序组件时所需要的显式配置的数量, 不过, 仅有一个 bean 匹配所需的结果时, 自动装配才是有效的, 如果不仅有一个 bean 能够匹配结果的话, 这种歧义性会阻碍 Spring 自动装配属性, 构造器参数或方法参数</p>
<p>当确实发生歧义性的时候, Spring 提供了多种可选方案来解决这样的问题:</p>
<ul>
<li>可以将可选 bean 中的某一个设为首选 (primary) 的 bean;</li>
<li>使用限定符 (qualifier) 来帮助 Spring 将可选 bean 的范围缩小到只有一个 bean</li>
</ul>
<h3 id="首选-bean">首选 bean</h3>
<p>如果标示了两个或更多的首选 bean, Spring 无法从多个首选的 bean 中做出选择, 那实际上也就是没有首选 bean 了</p>
<p>在 Spring 中, 可以通过 <code>@Primary</code> 来表达首选的方案, <code>@Primary</code> 能够与 <code>@Component</code> 组合用在组件扫描的 bean 上, 也可以与 <code>@Bean</code> 组合用在 Java 配置的 bean 声明中</p>
<h4 id="自动化配置">自动化配置</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* @Component注解的bean声明为首选的bean */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IceCream</span> <span class="keyword">implements</span> <span class="title">Dessert</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="javaconfig-配置">JavaConfig 配置</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 显式配置的bean声明为首选的bean */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Dessert <span class="title">iceCream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IceCream();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="xml-配置-1">XML 配置</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- bean元素有一个primary属性用来指定首选的bean --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.janz.spring.desserts.IceCream&quot;</span> <span class="attr">primary</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.janz.spring.desserts.Cake&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.janz.spring.desserts.Cookies&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="限定符">限定符</h3>
<p><code>@Qualifier</code> 注解是使用限定符的主要方式, 它可以与 <code>@Autowired</code> 和 <code>@Inject</code> 协同使用, 在注入的时候指定想要注入进去的是哪个 bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 将Cake注入到dessert bean*/</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;cake&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Dessert dessert;</span><br><span class="line"><span class="comment">// 指定的限定符与要注入的bean的名称是紧耦合的, bean名称可以通过@Component(value=&quot;xxx&quot;)修改</span></span><br></pre></td></tr></table></figure>
<h3 id="测试-2">测试</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123;DessertConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DessertTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Dessert dessert;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;cake&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Dessert dessert2;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dessertNotNull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Assert.assertEquals(<span class="string">&quot;com.janz.spring.desserts.IceCream&quot;</span>, dessert.getClass().getName());</span><br><span class="line">        Assert.assertEquals(<span class="string">&quot;com.janz.spring.desserts.Cake&quot;</span>, dessert2.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="bean-的作用域">bean 的作用域</h2>
<p>Spring 定义了多种作用域, 可以基于这些作用域创建 bean, 包括:</p>
<ul>
<li><strong>单例(Singleton)</strong> 在整个应用中, 只创建 bean 的一个实例;</li>
<li><strong>原型(Prototype)</strong> 每次注入或者通过 Spring 应用上下文获取的时候, 都会创建一个新的 bean 实例;</li>
<li><strong>会话(Session)</strong> 在 Web 应用中, 为每个会话创建一个 bean 实例;</li>
<li><strong>请求(Request)</strong> 在 Web 应用中, 为每个请求创建一个 bean 实例</li>
</ul>
<h3 id="单例和原型">单例和原型</h3>
<p>在默认情况下, Spring 应用上下文中所有 bean 都是作为以单例的形式创建的, 如果选择其他的作用域, 要使用 <code>@Scope</code> 注解, 它可以与 <code>@Component</code> 或 <code>@Bean</code> 一起使用</p>
<h4 id="自动化配置-1">自动化配置</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 类上使用@Scope, 声明为原型bean */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> <span class="keyword">implements</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="javaconfig-配置-1">JavaConfig 配置</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* @Bean上使用@Scope */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Service <span class="title">orderService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> OrderService();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="xml-配置-2">XML 配置</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- bean元素的scope属性设置作用域 --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.janz.spring.service.OrderService&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="会话和请求">会话和请求</h3>
<p><code>@Scope</code> 同时还有一个 <code>proxyMode</code> 属性, 这个属性解决了将会话或请求作用域的 bean 注入到单例 bean 中所遇到的问题</p>
<blockquote>
<p>因为单例 bean 会在 Spring 应用上下文加载的时候创建, 当它创建的时候, 会话或请求作用域的 bean 此时并不存在, Spring 并不会注入实际的会话或请求作用域的类, Spring 会注入一个代理, 这个代理会暴露与类相同的方法, 当实际调用时, 代理会对其进行懒解析并将调用委托给会话或请求作用域内真正的 bean</p>
</blockquote>
<pre class="mermaid">graph LR
title[图 作用域代理能够延迟注入请求和会话作用域的bean]
title --> A
style title fill:#FFF,stroke:#FFF
linkStyle 0 stroke:#FFF,stroke-width:0;
A(单例bean)
B(接口 作用域代理)
C(接口 会话/请求作用域的bean)
D(接口 会话/请求作用域的bean)
B --注入到--> A
B -.委托给.- C
B -.委托给.- D</pre>
<h4 id="自动化配置-2">自动化配置</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(value = WebApplicationContext.SCOPE_SESSION, proxyMode = ScopedProxyMode.INTERFACES)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoreService</span> <span class="keyword">implements</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="javaconfig-配置-2">JavaConfig 配置</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope(value = WebApplicationContext.SCOPE_SESSION, proxyMode = ScopedProxyMode.INTERFACES)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Service <span class="title">storeService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StoreService();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// proxyMode属性被设置成了ScopedProxyMode.INTERFACES, 这表明这个代理要实现Service接口, 并将调用委托给实现bean</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建基于接口的代理</span></span><br><span class="line">proxyMode = ScopedProxyMode.INTERFACES</span><br><span class="line"><span class="comment">// 创建基于类的代理</span></span><br><span class="line">proxyMode = ScopedProxyMode.TARGET_CLASS</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果基于接口而不是类的话, Spring 就没有办法创建基于接口的代理了, 此时, 它使用 CGLib 来生成基于类的代理</p>
</blockquote>
<h4 id="xml-配置-3">XML 配置</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;storeService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.janz.spring.service.StoreService&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;session&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:scoped-proxy</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">aop:scoped-proxy元素是与@Scope注解的proxyMode属性功能相同的XML配置元素, 它会告诉Spring为bean创建一个作用域代理, 默认情况下, 它会使用CGLib创建目标类的代理, 可以将proxy-target-class属性设置为false, 进而要求它生成基于接口的代理</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="运行时值注入">运行时值注入</h2>
<p>Spring 提供了两种在运行时求值的方式:</p>
<ul>
<li>属性占位符 (Property placeholder);</li>
<li>Spring 表达式语言 (SpEL)</li>
</ul>
<h3 id="属性占位符">属性占位符</h3>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># app.properties文件</span></span><br><span class="line"><span class="meta">disc.title</span>=<span class="string">Sgt. Peppers Lonely Hearts Club Band</span></span><br><span class="line"><span class="meta">disc.artist</span>=<span class="string">The Beatles</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>属性文件可以通过 <code>@PropertySource("classpath:app.properties")</code> 加载到 Spring 的 <code>Environment</code> 中</p>
</blockquote>
<h4 id="自动化配置-3">自动化配置</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="comment">// 声明属性源</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:app.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlankDisc</span> <span class="keyword">implements</span> <span class="title">CompactDisc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String artist;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 占位符的形式为使用&quot;$&#123;...&#125;&quot;包装的属性名称, 使用@Value注解配置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlankDisc</span><span class="params">(<span class="meta">@Value(&quot;$&#123;disc.title&#125;&quot;)</span> String title, <span class="meta">@Value(&quot;$&#123;disc.artist&#125;&quot;)</span> String artist)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">        <span class="keyword">this</span>.artist = artist;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getArtist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> artist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="javaconfig-配置-3">JavaConfig 配置</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 使用@PropertySource注解和Environment */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Environment env;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从Spring 3.1开始, PropertySourcesPlaceholderConfigurer能够基于Spring Environment及其属性源来解析占位符</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PropertySourcesPlaceholderConfigurer <span class="title">placeholderConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PropertySourcesPlaceholderConfigurer();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompactDisc <span class="title">blankDisc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检索属性值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BlankDisc2(env.getProperty(<span class="string">&quot;disc.title&quot;</span>), env.getProperty(<span class="string">&quot;disc.artist&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="xml-配置-4">XML 配置</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 解析属性占位符 --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:c</span>=<span class="string">&quot;http://www.springframework.org/schema/c&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- context:property-placeholder元素会生成PropertySourcesPlaceholderConfigurer bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;blankDisc3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.janz.spring.disc.BlankDisc&quot;</span> <span class="attr">c:title</span>=<span class="string">&quot;$&#123;disc.title&#125;&quot;</span> <span class="attr">c:artist</span>=<span class="string">&quot;$&#123;disc.artist&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="测试-3">测试</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123;AutoConfig.class, JavaConfig.class, XmlConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CompactDisc blankDisc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CompactDisc blankDisc2;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CompactDisc blankDisc3;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">discEquals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Assert.assertEquals(<span class="string">&quot;Sgt. Peppers Lonely Hearts Club Band&quot;</span>, blankDisc.getTitle());</span><br><span class="line">        Assert.assertEquals(<span class="string">&quot;The Beatles&quot;</span>, blankDisc.getArtist());</span><br><span class="line"></span><br><span class="line">        Assert.assertEquals(<span class="string">&quot;Sgt. Peppers Lonely Hearts Club Band&quot;</span>, blankDisc2.getTitle());</span><br><span class="line">        Assert.assertEquals(<span class="string">&quot;The Beatles&quot;</span>, blankDisc2.getArtist());</span><br><span class="line"></span><br><span class="line">        Assert.assertEquals(<span class="string">&quot;Sgt. Peppers Lonely Hearts Club Band&quot;</span>, blankDisc3.getTitle());</span><br><span class="line">        Assert.assertEquals(<span class="string">&quot;The Beatles&quot;</span>, blankDisc3.getArtist());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="spring-表达式语言">Spring 表达式语言</h3>
<p>Spring 3 引入了 <strong>Spring 表达式语言 (Spring Expression Language, SpEL)</strong>, 它能够以一种强大和简洁的方式将值装配到 bean 属性和构造器参数中, 在这个过程中所使用的表达式会在运行时计算得到值</p>
<p>SpEl 拥有很多特性:</p>
<ul>
<li>使用 bean 的 ID 来引用 bean;</li>
<li>调用方法和访问对象的属性;</li>
<li>对值进行算术, 关系和逻辑运算;</li>
<li>正则表达式匹配;</li>
<li>集合操作</li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 005 AOP</title>
    <url>/2019/04/12/spring/005/</url>
    <content><![CDATA[<h1 id="spring-aop">Spring AOP</h1>
<h2 id="面向切面编程">面向切面编程</h2>
<p>在软件开发中, 散布于应用中多处的功能被称为 <strong>横切关注点(cross-cutting concern)</strong>, 通常来讲, 这些横切关注点从概念上是与应用的业务逻辑相分离的, 但是往往会直接嵌入到应用的业务逻辑之中, 把这些横切关注点与业务逻辑相分离正是面向切面编程 (AOP) 所要解决的问题</p>
<blockquote>
<p>如果要重用通用功能的话, 最常见的面向对象技术是继承(inheritance) 或委托(delegation), 但是如果在整个应用中都是用相同的基类, 继承往往会导致一个脆弱的对象体系, 而使用委托可能需要对委托对象进行复杂的调用</p>
</blockquote>
<p>横切关注点可以被模块化为特殊的类, 这些类被称为 <strong>切面(aspect)</strong>, 这样做有偶两个好处:</p>
<ul>
<li>每个关注点都集中于一个地方, 而不是分散到多处代码中;</li>
<li>服务模块更简洁, 因为它们只包含主要关注点(或核心功能)的代码, 而次要关注点的代码被转移到切面中了</li>
</ul>
<pre class="mermaid">graph TB
title["图 在一个或多个连接点上, 可以把切面的功能(通知)织入到程序的执行过程中"]
title --> A
style title fill:#FFF,stroke:#FFF
linkStyle 0 stroke:#FFF,stroke-width:0;

A(通知)
B(连接点)
C(连接点)
D(...)
A --切点--> B
A --切点--> C
A --切点--> D
subgraph 程序执行过程
B
C
D
end</pre>
<h3 id="通知">通知</h3>
<p><strong>通知(advice)</strong> 定义了切面是什么以及何时使用, 除了描述切面要完成的工作, 通知还解决了何时执行这个工作的问题</p>
<p>Spring 切面可以应用 5 种类型的通知:</p>
<ul>
<li><strong>前置通知(before)</strong> 在目标方法被调用之前调用通知功能;</li>
<li><strong>后置通知(after)</strong> 在目标方法完成之后调用通知, 此时不会关心方法的输出是什么;</li>
<li><strong>返回通知(after-returning)</strong> 在目标方法成功执行之后调用通知;</li>
<li><strong>异常通知(after-throwing)</strong> 在目标方法抛出异常后调用通知;</li>
<li><strong>环绕通知(around)</strong> 通知包裹了被通知的方法, 在被通知的方法调用之前和调用之后执行自定义的行为</li>
</ul>
<h3 id="连接点">连接点</h3>
<p><strong>连接点(join point)</strong> 是在应用执行过程中能够插入切面的一个点, 这个点可以是调用方法时, 抛出异常时, 甚至修改一个字段时, 切面代码可以利用这些点插入到应用的正常流程之中, 并添加新的行为</p>
<h3 id="切点">切点</h3>
<p><strong>切点(poincut)</strong> 的定义会匹配通知所要织入的一个或多个连接点, 我们通常使用明确的类和方法名称, 或是利用正则表达式定义所匹配的类和方法名称来指定这些切点, 有些 AOP 框架允许我们创建动态的切点, 可以根据运行时的决策 (比如方法的参数值) 来决定是否应用通知</p>
<h3 id="切面">切面</h3>
<p><strong>切面(aspect)</strong> 是通知和切点的结合, 通知和切点共同定义了切面的全部内容 (它是什么, 在何时何何处完成其功能)</p>
<h3 id="引入">引入</h3>
<p><strong>引入(introduction)</strong> 允许向现有的类添加新方法或属性</p>
<h3 id="织入">织入</h3>
<p><strong>织入(weaving)</strong> 是把切面应用到目标对象并创建新的代理对象的过程, 切面在指定的连接点被织入到目标对象中, 在目标对象的生命周期里有多个点可以进行织入:</p>
<ul>
<li><strong>编译期</strong> 切面在目标类编译时被织入, 这种方式需要特殊的编译器, AspectJ 的织入编译器就是以这种方式织入切面的;</li>
<li><strong>类加载期</strong> 切面在目标类加载到 JVM 时被织入, 这种方式需要特殊的类加载器(ClassLoader), 它可以在目标类被引入应用之前增强该目标类的字节码, AspectJ 5 的加载时织入(load-time weaving, LTW) 就支持以这种方式织入切面;</li>
<li><strong>运行期</strong> 切面在应用运行的某个时刻被织入, 一般情况下, 在织入切面时, AOP 容器会为目标对象动态地创建一个代理对象, Spring AOP 就是以这种方式织入切面的</li>
</ul>
<h2 id="spring-对-aop-的支持">Spring 对 AOP 的支持</h2>
<p>Spring 提供了 4 种类型的 AOP 支持:</p>
<ul>
<li>基于代理的经典 Spring AOP;</li>
<li><code>@AspectJ</code> 注解驱动的切面 (JavaConfig 方式);</li>
<li>纯 POJO 切面 (XML 方式);</li>
<li>注入式 AspectJ 切面 (适用于 Spring 各版本)</li>
</ul>
<h3 id="注解驱动的切面">注解驱动的切面</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 在JavaConfig中启用AspectJ注解的自动代理 */</span></span><br><span class="line"><span class="keyword">package</span> com.janz.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 启用AspectJ自动代理</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaConfig</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- XML中启用AspectJ注解的自动代理 --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.janz.spring&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 启用AspectJ自动代理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="编写切点">编写切点</h4>
<p>在 Spring AOP 中, 要使用 AspectJ 的切点表达式语言来定义切点, 最重要的一点是 Spring 仅支持 AspectJ 切点指示器(pointcut designator) 的一个子集</p>
<table>
<thead>
<tr class="header">
<th>AspectJ 指示器</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>arg()</code></td>
<td>限制连接点匹配参数为指定类型的执行方法</td>
</tr>
<tr class="even">
<td><code>@args()</code></td>
<td>限制连接点匹配参数由指定注解标注的执行方法</td>
</tr>
<tr class="odd">
<td><code>execution()</code></td>
<td>用于匹配是连接点的执行方法</td>
</tr>
<tr class="even">
<td><code>this()</code></td>
<td>限制连接点匹配 AOP 代理的 bean 引用为指定类型的类</td>
</tr>
<tr class="odd">
<td><code>target</code></td>
<td>限制连接点匹配目标对象为指定类型的类</td>
</tr>
<tr class="even">
<td><code>@target()</code></td>
<td>限制连接点匹配特定的执行对象, 这些对象对应的类要具有特定类型的注解</td>
</tr>
<tr class="odd">
<td><code>within()</code></td>
<td>限制连接点匹配指定的类型</td>
</tr>
<tr class="even">
<td><code>@within()</code></td>
<td>限制连接点匹配指定注解所标注的类型 (当使用 Spring AOP 时, 方法定义在由指定的注解所标注的类里)</td>
</tr>
<tr class="odd">
<td><code>@annotation</code></td>
<td>限定匹配带有指定注解的连接点</td>
</tr>
</tbody>
</table>
<blockquote>
<p>在 Spring 中尝试使用 AspectJ 其他指示器时, 将会抛出 <code>IllegalArgumentException</code> 异常</p>
</blockquote>
<blockquote>
<p>注意 Spring 支持的指示器中只有 <code>execution</code> 指示器是实际执行匹配的, 而其他的指示器都是用来限制匹配的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 编写Performance的perform()方法触发的通知 */</span></span><br><span class="line">  execution (     *      com.janz.spring.Performance.perform(    ..    ))</span><br><span class="line">------------- ---------- --------------------------- ------- ----------</span><br><span class="line">在方法执行时触发 返回任意类型         方法所属的类            方法   使用任意参数</span><br></pre></td></tr></table></figure>
<p>可以使用 <code>&amp;&amp;</code> 操作符来标识与( <code>and</code> ) 关系, <code>||</code> 操作符来标识或( <code>or</code> ) 关系, <code>!</code> 操作符来标识非( <code>not</code> ) 关系</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 使用within()指示器限制切点范围 */</span></span><br><span class="line">execution(* com.janz.spring.Performance.perform(..)) &amp;&amp; within(com.janz.spring.*)</span><br><span class="line"><span class="comment">/* bean()使用bean ID或bean名称作为参数来限制切点只匹配特定的bean */</span></span><br><span class="line">execution(* com.janz.spring.Performance.perform(..)) <span class="function">and <span class="title">bean</span><span class="params">(<span class="string">&#x27;film&#x27;</span>)</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为 <code>&amp;</code> 在 XML 中 有特殊含义, 所以在 Spring 的 XML 配置里面描述切点时, 可以使用 <code>and</code> 来代替 <code>&amp;&amp;</code>, 同样, <code>or</code> 和 <code>not</code> 可以分别用来代替 <code>||</code> 和 <code>!</code></p>
</blockquote>
<h4 id="定义切面">定义切面</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 观看演出的切面 */</span></span><br><span class="line"><span class="keyword">package</span> com.janz.spring.advice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @Aspect注解表明这是一个切面</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audience</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 表演之前</span></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.janz.spring.Performance.perform(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeSeats</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Taking seats&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 表演之后</span></span><br><span class="line">    <span class="meta">@AfterReturning(&quot;execution(* com.janz.spring.Performance.perform(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CLAP CLAP CLAP!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 表演失败之后</span></span><br><span class="line">    <span class="meta">@AfterThrowing(&quot;execution(* com.janz.spring.Performance.perform(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demandRefund</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Demanding a refund&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring 使用 AspectJ 注解来声明通知方法</p>
<table>
<thead>
<tr class="header">
<th>注解</th>
<th>通知</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>@After</code></td>
<td>通知方法会在目标方法返回或抛出异常后调用</td>
</tr>
<tr class="even">
<td><code>@AfterReturning</code></td>
<td>通知方法会在目标方法返回后调用</td>
</tr>
<tr class="odd">
<td><code>@AfterThrowing</code></td>
<td>通知方法会在目标方法抛出异常后调用</td>
</tr>
<tr class="even">
<td><code>@Around</code></td>
<td>通知方法会将目标方法封装起来</td>
</tr>
<tr class="odd">
<td><code>@Before</code></td>
<td>通知方法会在目标方法调用之前执行</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 通过@Pointcut注解声明频繁使用的切点表达式 */</span></span><br><span class="line"><span class="keyword">package</span> com.janz.spring.advice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audience2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义命名的切点</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.janz.spring.Performance.perform(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performance</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 环绕通知</span></span><br><span class="line">    <span class="meta">@Around(&quot;performance()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watchPerformance</span><span class="params">(ProceedingJoinPoint point)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Taking seats&quot;</span>);</span><br><span class="line">            point.proceed();</span><br><span class="line">            System.out.println(<span class="string">&quot;CLAP CLAP CLAP!!!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Demanding a refund&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 处理通知中的参数 */</span></span><br><span class="line"><span class="keyword">package</span> com.janz.spring.advice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audience3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; actCounts = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.janz.spring.Performance.perform(int)) &amp;&amp; args(actNumber)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actPlayed</span><span class="params">(<span class="keyword">int</span> actNumber)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在放映前计数</span></span><br><span class="line">    <span class="meta">@Before(&quot;actPlayed(actNumber)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countAct</span><span class="params">(<span class="keyword">int</span> actNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="keyword">this</span>.getCounts(actNumber);</span><br><span class="line">        actCounts.put(actNumber, ++count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCounts</span><span class="params">(<span class="keyword">int</span> actNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> actCounts.containsKey(actNumber) ? actCounts.get(actNumber) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="切面引入">切面引入</h4>
<p>在 Spring 中, 切面只是实现了它们所包装 bean 相同接口的代理, 如果除了实现这些接口, 代理也能暴露新接口的话, 那切面所通知的 bean 看起来像是实现了新的接口, 即便底层实现类并没有实现这些接口也无所谓</p>
<pre class="mermaid">graph TB
title["图 代理拦截调用并委托给实现该方法的其他对象"]
title --> A
style title fill:#FFF,stroke:#FFF
linkStyle 0 stroke:#FFF,stroke-width:0;

A[调用者]
B[被通知的bean]
C[引入的代理]
subgraph 代理
B
C
end
A -.现有的方法.-> B
A -.被引入的方法.-> C</pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 借助AOP的引入功能创建切面 */</span></span><br><span class="line"><span class="keyword">package</span> com.janz.spring.advice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.janz.spring.Encoreable;</span><br><span class="line"><span class="keyword">import</span> com.janz.spring.subject.EncoreableImpl;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EncoreableIntroducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeclareParents(value = &quot;com.janz.spring.Performance+&quot;, defaultImpl = EncoreableImpl.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Encoreable encoreable;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// @DeclareParents注解所标注的静态属性指明了要引入的接口</span></span><br><span class="line"><span class="comment">// value属性指定了哪种类型的bean要引入该接口, 本例中为实现Performance接口的类(标记符后面的+表示为Performance接口的子类型, 而不是接口本身)</span></span><br><span class="line"><span class="comment">// defaultImpl属性指定了为引入功能提供实现的类</span></span><br></pre></td></tr></table></figure>
<h3 id="xml-中声明切面">XML 中声明切面</h3>
<h4 id="定义切面-1">定义切面</h4>
<p>Spring 的 AOP 配置元素能够以非侵入性的方式声明切面</p>
<table>
<thead>
<tr class="header">
<th>AOP 配置元素</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>&lt;aop:advisor&gt;</code></td>
<td>定义 AOP 通知器</td>
</tr>
<tr class="even">
<td><code>&lt;aop:after&gt;</code></td>
<td>定义 AOP 后置通知</td>
</tr>
<tr class="odd">
<td><code>&lt;aop:after-returning&gt;</code></td>
<td>定义 AOP 返回通知</td>
</tr>
<tr class="even">
<td><code>&lt;aop:after-throwing&gt;</code></td>
<td>定义 AOP 异常通知</td>
</tr>
<tr class="odd">
<td><code>&lt;aop:around&gt;</code></td>
<td>定义 AOP 环绕通知</td>
</tr>
<tr class="even">
<td><code>&lt;aop:aspect&gt;</code></td>
<td>定义一个切面</td>
</tr>
<tr class="odd">
<td><code>&lt;aop:aspect-autoproxy&gt;</code></td>
<td>启用 <code>@AspectJ</code> 注解驱动的切面</td>
</tr>
<tr class="even">
<td><code>&lt;aop:before&gt;</code></td>
<td>定义一个 AOP 前置通知</td>
</tr>
<tr class="odd">
<td><code>&lt;aop:config&gt;</code></td>
<td>顶层的 AOP 配置元素, 大多数的 <code>&lt;aop:*&gt;</code> 元素必须包含在 <code>&lt;aop:config&gt;</code> 元素内</td>
</tr>
<tr class="even">
<td><code>&lt;aop:declare-parents&gt;</code></td>
<td>以透明的方式为被通知的对象引入额外的接口</td>
</tr>
<tr class="odd">
<td><code>&lt;aop:pointcut&gt;</code></td>
<td>定义一个切点</td>
</tr>
</tbody>
</table>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过XML将无注解的Audience声明为切面 --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;audience&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.janz.spring.advice.Audience&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;audience&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;takeSeats&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.janz.spring.Performance.perform())&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;applause&quot;</span></span></span><br><span class="line"><span class="tag">                                 <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.janz.spring.Performance.perform())&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after-returning</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;demandRefund&quot;</span></span></span><br><span class="line"><span class="tag">                                <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.janz.spring.Performance.perform())&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after-throwing</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义切点用于复用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;audience&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.janz.spring.advice.Audience&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;performance&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.janz.spring.Performance.perform())&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:pointcut</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;audience&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;takeSeats&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;performance&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;applause&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;performance&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after-returning</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;demandRefund&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;performance&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after-throwing</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置参数化的切面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;film&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.janz.spring.subject.Film&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;audience3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.janz.spring.advice.Audience3&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;audience3&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointcut&quot;</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">expression</span>=<span class="string">&quot;execution(* com.janz.spring.Performance.perform(int)) and args(actNumber)&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span> <span class="attr">method</span>=<span class="string">&quot;countAct&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="切面引入-1">切面引入</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置XML实现引入功能 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;film&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.janz.spring.subject.Film&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;encoreableDelegate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.janz.spring.subject.EncoreableImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用default-impl注入接口默认实现</span></span><br><span class="line"><span class="comment">        &lt;aop:declare-parents types-matching=&quot;com.janz.spring.Performance+&quot;</span></span><br><span class="line"><span class="comment">                             implement-interface=&quot;com.janz.spring.Encoreable&quot;</span></span><br><span class="line"><span class="comment">                             default-impl=&quot;com.janz.spring.subject.EncoreableImpl&quot;/&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用delegate-ref注入实现bean --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:declare-parents</span> <span class="attr">types-matching</span>=<span class="string">&quot;com.janz.spring.Performance+&quot;</span></span></span><br><span class="line"><span class="tag">                             <span class="attr">implement-interface</span>=<span class="string">&quot;com.janz.spring.Encoreable&quot;</span></span></span><br><span class="line"><span class="tag">                             <span class="attr">delegate-ref</span>=<span class="string">&quot;encoreableDelegate&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="注入-aspectj-切面">注入 AspectJ 切面</h3>
<p>虽然 Spring AOP 能够满足许多应用的切面需求, 但是与 AspectJ 相比, Spring AOP 是一个功能比较弱的 AOP 解决方案, AspectJ 提供了 Spring AOP 所不能支持的许多类型的切点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 使用AspectJ实现表演的评论员 */</span></span><br><span class="line"><span class="keyword">package</span> com.janz.spring.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.janz.spring.CriticismEngine;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AspectJ切面使用aspect关键字, 文件后缀为.aj</span></span><br><span class="line"><span class="keyword">public</span> aspect CriticAspect &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义切点</span></span><br><span class="line">    <span class="function">pointcut <span class="title">performance</span><span class="params">()</span>: <span class="title">execution</span><span class="params">(* com.janz.spring.Performance.perform(..)</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表演结束时发表评论</span></span><br><span class="line">    after(): performance()&#123;</span><br><span class="line">        System.out.println(criticismEngine.getCriticism());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CriticismEngine criticismEngine;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCriticismEngine</span><span class="params">(CriticismEngine criticismEngine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.criticismEngine = criticismEngine;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通常情况下, Spring bean 由 Spring 容器初始化, 但是 AspectJ 切面是由 AspectJ 在运行期创建的, 因此 Spring 不能负责创建 <code>CriticAspect</code>, 所有的 AspectJ 切面都提供了一个静态的 <code>aspectOf()</code> 方法, 该方法返回切面的一个单例, 所以为了获得切面的实例, 必须使用 <code>aspectOf()</code> 方法而不是调用构造器方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 配置文件 */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CriticAspect <span class="title">criticAspect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过Aspect切面的aspectOf()函数获取实例</span></span><br><span class="line">        CriticAspect criticAspect = CriticAspect.aspectOf();</span><br><span class="line">        criticAspect.setCriticismEngine(criticismEngine());</span><br><span class="line">        <span class="keyword">return</span> criticAspect;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 如果使用XML配置, 则通过factory-method属性指定aspectOf --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.janz.spring.aspect.CriticAspect&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;aspectOf&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;criticismEngine&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;criticismEngine&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="ajc">AJC</h4>
<p>使用 AspectJ 切面的项目需要使用 <a href="https://www.eclipse.org/aspectj/">AJC</a> 编译, 可以通过构建工具 Maven 配置, 相关用例见 <a href="http://www.mojohaus.org/aspectj-maven-plugin/index.html">aspectj-maven-plugin</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Maven配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjrt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.mojo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectj-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>test-compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 006 Web</title>
    <url>/2019/05/06/spring/006/</url>
    <content><![CDATA[<h1 id="spring-web">Spring Web</h1>
<h2 id="spring-mvc">Spring MVC</h2>
<p><strong>Spring MVC</strong> 基于模型-视图-控制器(Model-View-Controller, MVC) 模式实现, 它能够构建像 Spring 框架那样灵活和松耦合的 Web 应用程序</p>
<p>请求会将信息带到很多站点, 并生产期望的结果</p>
<pre class="mermaid">graph LR
A(请求)
B[DispatcherServlet]
C[处理器映射]
D[控制器]
E[模型及逻辑视图名]
F[视图解释器]
G[视图]
H(响应)
A --1--> B
B --2--> C
B --3--> D
D --4--> E
E --> B
B --5--> F
B --6--> G
G --7--> H</pre>
<h3 id="dispatcherservlet">DispatcherServlet</h3>
<p><code>DispatcherServlet</code> 是 Spring MVC 的核心, 在这里请求会第一次接触到框架, 它要负责将请求路由到其他的组件之中</p>
<blockquote>
<p>按照传统的方式, 像 <code>DispatcherServlet</code> 这样的 Servlet 会配置在 <code>web.xml</code> 文件中, 这个文件会放到应用的 WAR 包里面, 但是, 借助于 Servlet3 规范和 Spring 3.1 的功能增强, 可以使用 Java 代码将 <code>DispatcherServlet</code> 配置在 Servlet 容器中</p>
</blockquote>
<blockquote>
<p>在 Servlet 3.0 环境中, 容器会在类路径中查找实现 <code>javax.servlet.ServletContainerInitializer</code> 接口的类, 如果能发现的话, 就会用它来配置 Servlet 容器, Spring 提供了这个接口的实现, 名为 <code>SpringServletContainerInitializer</code>, 这个类反过来又会查找实现 <code>WebApplicationInitializer</code> 的类并将配置任务交给它来完成, Spring 3.2 引入了一个便利的 <code>WebApplicationInitializer</code> 基础实现, 也就是 <code>AbstractAnnotationConfigDispatcherServletInitializer</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置DispatcherServlet</span></span><br><span class="line"><span class="keyword">package</span> com.janz.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.janz.spring.config.RootConfig;</span><br><span class="line"><span class="keyword">import</span> com.janz.spring.config.WebConfig;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebAppInitializer</span> <span class="keyword">extends</span> <span class="title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="comment">// 将一个或多个路径映射到DispatcherServlet上</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class&lt;?&gt;[]&#123;RootConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="comment">// 指定配置类</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class&lt;?&gt;[]&#123;WebConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// getServletConfigClasses 方法返回的带有@Configuration注解的类将会用来定义DispatcherServlet应用上下文中的bean, 一般加载包含Web组件的bean, 如控制器, 视图解析器以及处理器映射</span></span><br><span class="line"><span class="comment">// getRootConfigClasses方法返回的带有@Configuration注解的类将会用来配置ContextLoaderListener创建的应用上下文中的bean, 这些bean通常是驱动应用后端的中间层和数据层组件</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Spring MVC 配置</span></span><br><span class="line"><span class="keyword">package</span> com.janz.spring.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ViewResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.EnableWebMvc;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.view.InternalResourceViewResolver;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 启用Spring MVC</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置JSP视图解析器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ViewResolver <span class="title">viewResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        InternalResourceViewResolver resolver = <span class="keyword">new</span> InternalResourceViewResolver();</span><br><span class="line">        resolver.setPrefix(<span class="string">&quot;/views/&quot;</span>);</span><br><span class="line">        resolver.setSuffix(<span class="string">&quot;.jsp&quot;</span>);</span><br><span class="line">        resolver.setExposeContextBeansAsAttributes(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> resolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置静态资源的处理</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> </span>&#123;</span><br><span class="line">        configurer.enable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过调用DefaultServletHandlerConfigurer的enable()方法, 将对静态资源的请求转发到Servlet容器中默认的Servlet上, 而不是使用DispatcherServlet本身来处理此类请求</span></span><br></pre></td></tr></table></figure>
<h2 id="controller">Controller</h2>
<h3 id="简单请求">简单请求</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 简单的控制器 */</span></span><br><span class="line"><span class="keyword">package</span> com.janz.spring.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明为一个控制器</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeController</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理对&quot;/home&quot;的GET请求</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/home&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">home</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;home&quot;</span>; <span class="comment">// 视图名为home</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据配置ViewResolver的方式, 视图名为home将会解析为/WEB-INF/views/home.jsp路径的JSP</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>@Controller</code> 和 <code>@Component</code> 注解所实现的效果是一样的, 但是在表意性上可能会差一些</p>
</blockquote>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;!-- 简单的JSP --&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> session=<span class="string">&quot;false&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;HOME&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Welcome to website&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 测试代码 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeControllerTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHome</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">&quot;/home&quot;</span>))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.view().name(<span class="string">&quot;home&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="请求参数">请求参数</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 接受请求的输入 */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeController</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理url参数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/home/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">param1</span><span class="params">(<span class="meta">@PathVariable</span> String id)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;param: &quot;</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;home&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理query参数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/home/id&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">param2</span><span class="params">(<span class="meta">@RequestParam</span> String id)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;param: &quot;</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;home&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理form参数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/home&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">param3</span><span class="params">(<span class="meta">@RequestParam</span> String id)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;param: &quot;</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;home&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理body参数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/home/id&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">param4</span><span class="params">(<span class="meta">@RequestBody</span> String id)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;param: &quot;</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;home&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 测试代码 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeControllerTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testParam</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// url</span></span><br><span class="line">        mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">&quot;/home/123&quot;</span>))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.view().name(<span class="string">&quot;home&quot;</span>));</span><br><span class="line">        <span class="comment">// query</span></span><br><span class="line">        mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">&quot;/home/id&quot;</span>).param(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;123&quot;</span>))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.view().name(<span class="string">&quot;home&quot;</span>));</span><br><span class="line">        <span class="comment">// form</span></span><br><span class="line">        mockMvc.perform(MockMvcRequestBuilders.post(<span class="string">&quot;/home&quot;</span>).param(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;123&quot;</span>))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.view().name(<span class="string">&quot;home&quot;</span>));</span><br><span class="line">        <span class="comment">// body</span></span><br><span class="line">        mockMvc.perform(MockMvcRequestBuilders.post(<span class="string">&quot;/home/id&quot;</span>)</span><br><span class="line">                .contentType(MediaType.APPLICATION_JSON).content(<span class="string">&quot;123&quot;</span>))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.view().name(<span class="string">&quot;home&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模型数据">模型数据</h3>
<p>在方法中给定一个 <code>Model</code> 作为参数, 方法就能将获取到的结果填充到模型中, 它会传递给视图, 这样数据就能渲染到客户端了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 使用模型传递数据 */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BrandController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/brands&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">brands</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果调用addAttribute方法并且不指定key, 那么key会根据值的对象类型推断确定, 在本例中, 因为它是一个List&lt;Brand&gt;, 因此键会推断为brandList</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;brandList&quot;</span>, Collections.singletonList(Brand.of(<span class="string">&quot;brandName&quot;</span>)));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;brand&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 简化方案</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/brand&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Brand&gt; <span class="title">brands</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 没有显式设定模型, 当处理器方法返回对象或集合时, 这个值会放到模型中, 模型的key会根据其类型推断得出, 本例中为brandList</span></span><br><span class="line">        <span class="comment">// 视图名称会根据请求路径推断得出, 这个方法根据/brand得到视图名称为brand</span></span><br><span class="line">        <span class="keyword">return</span> Collections.singletonList(Brand.of(<span class="string">&quot;brandName&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor(staticName = &quot;of&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Brand</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;!-- JSP中使用JSTL(JavaServer Pages Standard Tag Library)渲染模型中的数据 --&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%@ taglib uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> prefix=<span class="string">&quot;c&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;brand List&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;c:forEach items=<span class="string">&quot;$&#123;brandList&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;brand&quot;</span> varStatus=<span class="string">&quot;status&quot;</span>&gt;</span><br><span class="line">    &lt;li id=<span class="string">&quot;brand_$&#123;status.index&#125;&quot;</span>&gt;</span><br><span class="line">        &lt;c:out value=<span class="string">&quot;$&#123;brand.name&#125;&quot;</span>/&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 测试代码 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BrandControllerTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testList</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">&quot;/brand&quot;</span>))</span><br><span class="line">                .andDo(MockMvcResultHandlers.print())</span><br><span class="line">                .andExpect(MockMvcResultMatchers.view().name(<span class="string">&quot;brand&quot;</span>))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.model().attributeExists(<span class="string">&quot;brandList&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重定向">重定向</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 使用redirect重定向 */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重定向到&quot;/&quot;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/index&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 <code>InternalResourceViewResolver</code> 看到视图格式中的 <code>redirect:</code> 前缀时, 就知道要将其解析为重定向的规则, 而不是视图的名称</p>
<p>除了 <code>redirect:</code>, <code>InternalResourceViewResolver</code> 还能识别 <code>forward</code> 前缀, 当它发现视图格式中以 <code>forward:</code> 作为前缀时, 请求将会前往指定的 URL 路径, 而不再是重定向</p>
<h3 id="校验">校验</h3>
<p>从 Spring 3.0 开始, 在 Spring MVC 中提供了对 Java 校验 API 的支持 (Java Validation API, 又称 JSR-303), 在 Spring MVC 中要使用 Java 校验 API 的话, 并不需要什么额外的配置, 只要保证在类路径下包含这个 Java API 的实现即可, 比如 Hibernate Validator</p>
<p>表 Java 校验 API 所提供的校验注解</p>
<table>
<thead>
<tr class="header">
<th>注解</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>@AssertFalse</code></td>
<td>所注解的元素必须是 <code>Boolean</code> 类型, 并且值为 <code>false</code></td>
</tr>
<tr class="even">
<td><code>@AssertTrue</code></td>
<td>所注解的元素必须是 <code>Boolean</code> 类型, 并且值为 <code>true</code></td>
</tr>
<tr class="odd">
<td><code>@DecimalMax</code></td>
<td>所注解的元素必须是数字, 并且它的值要小于或等于给定的 <code>BigDecimalString</code> 值</td>
</tr>
<tr class="even">
<td><code>@DecimalMin</code></td>
<td>所注解的元素必须是数字, 并且它的值要大于或等于给定的 <code>BigDecimalString</code> 值</td>
</tr>
<tr class="odd">
<td><code>@Digits</code></td>
<td>所注解的元素必须是数字, 并且它的值必须有指定的位数</td>
</tr>
<tr class="even">
<td><code>@Future</code></td>
<td>所注解的元素的值必须是一个将来的日期</td>
</tr>
<tr class="odd">
<td><code>@Max</code></td>
<td>所注解的元素必须是数字, 并且它的值要小于或等于给定的值</td>
</tr>
<tr class="even">
<td><code>@Min</code></td>
<td>所注解的元素必须是数字, 并且它的值要大于或等于给定的值</td>
</tr>
<tr class="odd">
<td><code>@NotNull</code></td>
<td>所注解的元素的值必须不能为 <code>null</code></td>
</tr>
<tr class="even">
<td><code>@Null</code></td>
<td>所注解的元素的值必须为 <code>null</code></td>
</tr>
<tr class="odd">
<td><code>@Past</code></td>
<td>所注解的元素的值必须是一个已过去的日期</td>
</tr>
<tr class="even">
<td><code>@Pattern</code></td>
<td>所注解的元素的值必须匹配给定的正则表达式</td>
</tr>
<tr class="odd">
<td><code>@Size</code></td>
<td>所注解的元素的值必须是 <code>String</code>, 集合或数组, 并且它的长度要符合给定的范围</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 配置 */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ValidatorFactory <span class="title">validation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LocalValidatorFactoryBean validation = <span class="keyword">new</span> LocalValidatorFactoryBean();</span><br><span class="line">    validation.setProviderClass(HibernateValidator.class);</span><br><span class="line">    <span class="keyword">return</span> validation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="view">View</h2>
<p>将控制器中请求处理的逻辑和视图中的渲染实现解耦是 Spring MVC 的一个重要特性, Spring 提供了多个内置的视图解析器实现, 它们能够适应大多数的场景</p>
<p>Spring 自带了 13 个视图解析器, 能够将逻辑视图名转换为物理实现</p>
<table>
<colgroup>
<col style="width: 34%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr class="header">
<th>视图解析器</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>BeanNameViewResolver</code></td>
<td>将视图解析为 Spring 应用上下文中的 <code>bean</code>, 其中 <code>bean ID</code> 与视图的名字相同</td>
</tr>
<tr class="even">
<td><code>ContentNegotiatingViewResolver</code></td>
<td>通过考虑客户端需要的内容类型来解析视图, 委托给另外一个能够产生对应内容类型的视图解析器</td>
</tr>
<tr class="odd">
<td><code>FreeMarkerViewResolver</code></td>
<td>将视图解析为 FreeMarker 模板</td>
</tr>
<tr class="even">
<td><code>InternalResourceViewResolver</code></td>
<td>将视图解析为 Web 应用的内部资源 (一般为 JSP)</td>
</tr>
<tr class="odd">
<td><code>JasperReportsViewResolver</code></td>
<td>将视图解析为 JasperReports 定义</td>
</tr>
<tr class="even">
<td><code>ResourceBundleViewResolver</code></td>
<td>将视图解析为资源 bundle (一般为属性文件)</td>
</tr>
<tr class="odd">
<td><code>TileViewResolver</code></td>
<td>将视图解析为 Apache Tile 定义, 其中 <code>tile ID</code> 与视图名称相同, 注意有两个不同的 <code>TileViewResolver</code> 实现, 分别对应于 Tiles 2.0 和 Tiles 3.0</td>
</tr>
<tr class="even">
<td><code>UrlBasedViewResolver</code></td>
<td>直接根据视图的名称解析视图, 视图的名称会匹配一个物理视图的定义</td>
</tr>
<tr class="odd">
<td><code>VelocityLayoutViewResolver</code></td>
<td>将视图解析为 Velocity 布局, 从不同的 Velocity 模板中组合页面</td>
</tr>
<tr class="even">
<td><code>VelocityViewResolver</code></td>
<td>将视图解析为 Velocity 模板</td>
</tr>
<tr class="odd">
<td><code>XmlViewResolver</code></td>
<td>将视图解析为特定 XML 文件中的 bean 定义, 类似于 <code>BeanNameViewResolver</code></td>
</tr>
<tr class="even">
<td><code>XsltViewResolver</code></td>
<td>将视图解析为 XSLT 转换后的结果</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Spring 4 和 Spring 3.2 支持表中的所有视图解析器, Spring 3.1 支持除 <code>Tiles3TilesViewResolver</code> 之外的所有视图解析器</p>
</blockquote>
<h3 id="jsp">JSP</h3>
<p>Spring 提供了两种支持 JSP 视图的方式:</p>
<ul>
<li><code>InternalResourceViewResolver</code> 会将视图名解析为 JSP 文件, 另外, 如果在 JSP 页面中使用了 JSP 标准标签库 (JavaServer Pages Standard Tag Library, JSTL) 的话, <code>InternalResourceViewResolver</code> 能够将视图名解析为 JstlView 形式的 JSP 文件, 从而将 JSTL 本地化和资源 bundle 变量暴露给 JSTL 的格式化(formatting) 和信息(message) 标签;</li>
<li>Spring 提供了两个 JSP 标签库, 一个用于表单到模型的绑定, 另一个提供了通用的工具类特性</li>
</ul>
<h4 id="视图解析器">视图解析器</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* JavaConfig配置 */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ViewResolver <span class="title">viewResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    InternalResourceViewResolver resolver = <span class="keyword">new</span> InternalResourceViewResolver();</span><br><span class="line">    resolver.setPrefix(<span class="string">&quot;/views/&quot;</span>);</span><br><span class="line">    resolver.setSuffix(<span class="string">&quot;.jsp&quot;</span>);</span><br><span class="line">    resolver.setExposeContextBeansAsAttributes(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 将视图解析为JstlView</span></span><br><span class="line">    resolver.setViewClass(JstlView.class);</span><br><span class="line">    <span class="keyword">return</span> resolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- XML配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:prefix</span>=<span class="string">&quot;/views/&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:suffix</span>=<span class="string">&quot;.jsp&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:viewClass</span>=<span class="string">&quot;org.springframework.web.servlet.view.JstlView&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="标签库">标签库</h4>
<p>当为 JSP 添加功能时, 标签库是一种很强大的方式, 能够避免在脚本块中直接编写 Java 代码, Spring 提供了两个 JSP 标签库, 用来帮助定义 Spring MVC Web 的视图, 其中一个标签库会用来渲染 HTML 表单标签, 这些标签可以绑定 model 中的某个属性, 另外一个标签库包含了一些工具类标签</p>
<p>Spring 表单绑定标签库中所包含的标签</p>
<table>
<thead>
<tr class="header">
<th>JSP 标签</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>&lt;sf:checkbox&gt;</code></td>
<td>渲染成一个 <code>&lt;input&gt;</code> 标签, 其中 <code>type</code> 属性设置为 <code>checkbox</code></td>
</tr>
<tr class="even">
<td><code>&lt;sf:checkboxes&gt;</code></td>
<td>渲染成多个 <code>&lt;input&gt;</code> 标签, 其中 <code>type</code> 属性设置为 <code>checkbox</code></td>
</tr>
<tr class="odd">
<td><code>&lt;sf:errors&gt;</code></td>
<td>在一个 <code>&lt;span&gt;</code> 中渲染输入域的错误</td>
</tr>
<tr class="even">
<td><code>&lt;sf:form&gt;</code></td>
<td>渲染成一个 <code>&lt;form&gt;</code> 标签, 并为其内部标签暴露绑定路径, 用于数据绑定</td>
</tr>
<tr class="odd">
<td><code>&lt;sf:hidden&gt;</code></td>
<td>渲染成一个 <code>&lt;input&gt;</code> 标签, 其中 <code>type</code> 属性设置为 <code>hidden</code></td>
</tr>
<tr class="even">
<td><code>&lt;sf:input&gt;</code></td>
<td>渲染成一个 <code>&lt;input&gt;</code> 标签, 其中 <code>type</code> 属性设置为 <code>text</code></td>
</tr>
<tr class="odd">
<td><code>&lt;sf:label&gt;</code></td>
<td>渲染成一个 <code>&lt;label&gt;</code> 标签</td>
</tr>
<tr class="even">
<td><code>&lt;sf:option&gt;</code></td>
<td>渲染成一个 <code>&lt;option&gt;</code> 标签, 其 <code>selected</code> 属性根据所绑定的值进行设置</td>
</tr>
<tr class="odd">
<td><code>&lt;sf:options&gt;</code></td>
<td>按照绑定的集合, 数组或 <code>Map</code>, 渲染成一个 <code>&lt;option&gt;</code> 标签的列表</td>
</tr>
<tr class="even">
<td><code>&lt;sf:password&gt;</code></td>
<td>渲染成一个 <code>&lt;input&gt;</code> 标签, 其中 <code>type</code> 属性设置为 <code>password</code></td>
</tr>
<tr class="odd">
<td><code>&lt;sf:radiobutton&gt;</code></td>
<td>渲染成一个 <code>&lt;input&gt;</code> 标签, 其中 <code>type</code> 属性设置为 <code>radio</code></td>
</tr>
<tr class="even">
<td><code>&lt;sf:radiobuttons&gt;</code></td>
<td>渲染成多个 <code>&lt;input&gt;</code> 标签, 其中 <code>type</code> 属性设置为 <code>radio</code></td>
</tr>
<tr class="odd">
<td><code>&lt;sf:select&gt;</code></td>
<td>渲染成一个 <code>&lt;select&gt;</code> 标签</td>
</tr>
<tr class="even">
<td><code>&lt;sf:textarea&gt;</code></td>
<td>渲染成一个 <code>&lt;textarea&gt;</code> 标签</td>
</tr>
</tbody>
</table>
<blockquote>
<p>从 Spring 3.1 开始, <code>&lt;sf:input&gt;</code> 标签能够允许指定 <code>type</code> 属性, 除了其他可选的类型外, 还能指定 HTML 5 特定类型的文本域, 如 <code>date</code>, <code>range</code>, <code>email</code></p>
</blockquote>
<p>Spring 的 JSP 标签库中提供的通用标签</p>
<table>
<colgroup>
<col style="width: 24%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="header">
<th>JSP 标签</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>&lt;s:bind&gt;</code></td>
<td>将绑定属性的状态导出到一个名为 <code>status</code> 的页面作用域属性中, 与 <code>&lt;s:path&gt;</code> 组合使用获取绑定属性的值</td>
</tr>
<tr class="even">
<td><code>&lt;s:escapeBody&gt;</code></td>
<td>将标签体中的内容进行 HTML 和/或 JavaScript 转义</td>
</tr>
<tr class="odd">
<td><code>&lt;s:hasBindErrors&gt;</code></td>
<td>根据指定模型对象 (在请求属性中) 是否有绑定错误, 有条件的渲染内容</td>
</tr>
<tr class="even">
<td><code>&lt;s:htmlEscape&gt;</code></td>
<td>为当前页面设置默认的 HTML 转义值</td>
</tr>
<tr class="odd">
<td><code>&lt;s:message&gt;</code></td>
<td>根据给定的编码获取信息, 然后要么进行渲染(默认行为), 要么将其设置为页面作用域, 请求作用域, 会话作用域或应用作用域的变量(通过使用 <code>var</code> 和 <code>scope</code> 属性实现)</td>
</tr>
<tr class="even">
<td><code>&lt;s:nestedPath&gt;</code></td>
<td>设置嵌入式的 <code>path</code>, 用于 <code>&lt;s:bind&gt;</code> 之中</td>
</tr>
<tr class="odd">
<td><code>&lt;s:theme&gt;</code></td>
<td>根据给定的编码获取主题信息, 然后要么进行渲染(默认行为), 要么将其设置为页面作用域, 请求作用域, 会话作用域或应用作用域的变量(通过使用 <code>var</code> 和 <code>scope</code> 属性实现)</td>
</tr>
<tr class="even">
<td><code>&lt;s:transform&gt;</code></td>
<td>使用命令对象的属性编辑器转换命令对象中不包含的属性</td>
</tr>
<tr class="odd">
<td><code>&lt;s:url&gt;</code></td>
<td>创建相对于上下文的 URL, 支持 URI 模板变量以及 HTML/XML/JavaScript 转义, 可以渲染 URL(默认行为), 也可以将其设置为页面为页面作用域, 请求作用域, 会话作用域或应用作用域的变量(通过使用 <code>var</code> 和 <code>scope</code> 属性实现)</td>
</tr>
<tr class="even">
<td><code>&lt;s:eval&gt;</code></td>
<td>计算符合 Spring 表达式语言(SpEL) 语法的某个表达式的值, 然后要么进行渲染(默认行为), 要么将其设置为页面作用域, 请求作用域, 会话作用域或应用作用域的变量(通过使用 <code>var</code> 和 <code>scope</code> 属性实现)</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* controller实现 */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/home&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">home</span><span class="params">(<span class="meta">@ModelAttribute</span> User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;home&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/home&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">home2</span><span class="params">(<span class="meta">@ModelAttribute</span> <span class="meta">@Valid</span> User user, Errors errors)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检验错误时返回当前页</span></span><br><span class="line">        <span class="keyword">if</span> (errors.hasErrors())</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;/home&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;account: &quot;</span> + user.getAccount() + <span class="string">&quot;, password: &quot;</span> + user.getPassword());</span><br><span class="line">        <span class="comment">// 成功时跳转首页或重定向当前页(重定向可以避免用户刷新页面导致重新提交)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/home&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;!-- JSP页面 --&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> session=<span class="string">&quot;false&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%@ taglib uri=<span class="string">&quot;http://www.springframework.org/tags/form&quot;</span> prefix=<span class="string">&quot;sf&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;HOME&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;LOGIN&lt;/h1&gt;</span><br><span class="line">&lt;sf:form method=<span class="string">&quot;post&quot;</span> modelAttribute=<span class="string">&quot;user&quot;</span>&gt;</span><br><span class="line">    account:&lt;sf:input path=<span class="string">&quot;account&quot;</span>/&gt; &lt;sf:errors path=<span class="string">&quot;account&quot;</span>/&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    password:&lt;sf:password path=<span class="string">&quot;password&quot;</span>/&gt; &lt;sf:errors path=<span class="string">&quot;password&quot;</span>/&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;submit&quot;</span>&gt;</span><br><span class="line">&lt;/sf:form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="apache-tiles">Apache Tiles</h3>
<p>假如想为应用中所有页面定义一个通用的头部和底部, 更好的方式是使用布局引擎, 如 Apache Tiles, 定义适用于所有页面的通用页面布局, Spring MVC 以视图解析器的形式为 Apache Tiles 提供了支持, 这个视图解析器能够将逻辑视图名解析为 Tile 定义</p>
<h4 id="视图解析器-1">视图解析器</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* JavaConfig配置 */</span></span><br><span class="line"><span class="comment">// TilesConfigurer负责定位和加载Tile定义并协调生成Tiles</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TilesConfigurer <span class="title">tilesConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TilesConfigurer tiles = <span class="keyword">new</span> TilesConfigurer();</span><br><span class="line">    <span class="comment">// 指定Tile定义的位置</span></span><br><span class="line">    tiles.setDefinitions(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;/views/tiles.xml&quot;</span>&#125;);</span><br><span class="line">    <span class="comment">// 启用刷新</span></span><br><span class="line">    tiles.setCheckRefresh(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> tiles;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TilesViewResolver将逻辑视图名称解析为Tile定义</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ViewResolver <span class="title">viewResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TilesViewResolver();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- XML配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;tilesConfigurer&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.tiles3.TilesConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;definitions&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>/views/tiles.xml<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.tiles3.TilesViewResolver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>针对 Apache Tiles 2 和 Apache Tiles 3 分别都有这两个组件, 分别位于 <code>org.springframework.web.servlet.view.tiles2</code> 和 <code>org.springframework.web.servlet.view.tiles3</code> 包中</p>
</blockquote>
<h4 id="定义-tile">定义 Tile</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- tiles.xml定义Tile --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">tiles-definitions</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;-//Apache Software Foundation//DTD Tiles Configuration 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://tiles.apache.org/dtds/tiles-config_3_0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tiles-definitions</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义base Tile --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">definition</span> <span class="attr">name</span>=<span class="string">&quot;base&quot;</span> <span class="attr">template</span>=<span class="string">&quot;/views/page.jsp&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">put-attribute</span> <span class="attr">name</span>=<span class="string">&quot;header&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/views/header.jsp&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">put-attribute</span> <span class="attr">name</span>=<span class="string">&quot;footer&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/views/footer.jsp&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">definition</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 扩展base Tile --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">definition</span> <span class="attr">name</span>=<span class="string">&quot;index&quot;</span> <span class="attr">extends</span>=<span class="string">&quot;base&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">put-attribute</span> <span class="attr">name</span>=<span class="string">&quot;body&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/views/index.jsp&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">definition</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">definition</span> <span class="attr">name</span>=<span class="string">&quot;home&quot;</span> <span class="attr">extends</span>=<span class="string">&quot;base&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">put-attribute</span> <span class="attr">name</span>=<span class="string">&quot;body&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/views/home.jsp&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">definition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tiles-definitions</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;!-- page.jsp创建主布局视图 --&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%@ taglib uri=<span class="string">&quot;http://tiles.apache.org/tags-tiles&quot;</span> prefix=<span class="string">&quot;t&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;TILES&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=<span class="string">&quot;header&quot;</span>&gt;</span><br><span class="line">    &lt;!-- 使用Tile标签库的&lt;t:insertAttribute&gt;来插入其他模板 --&gt;</span><br><span class="line">    &lt;t:insertAttribute name=<span class="string">&quot;header&quot;</span>/&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div id=<span class="string">&quot;content&quot;</span>&gt;</span><br><span class="line">    &lt;t:insertAttribute name=<span class="string">&quot;body&quot;</span>/&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div id=<span class="string">&quot;footer&quot;</span>&gt;</span><br><span class="line">    &lt;t:insertAttribute name=<span class="string">&quot;footer&quot;</span>/&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="thymeleaf">Thymeleaf</h3>
<p>尽管 JSP 已经存在了很长的时间, 但是它却存在一些缺陷:</p>
<ul>
<li>JSP 缺乏良好的格式, 很多 Web 浏览器或 HTML 编辑器中展现未经渲染的 JSP 模板的结果很难在审美上接近模板最终所渲染出来的结果;</li>
<li>JSP 规范是与 Servlet 规范紧密耦合的, 这意味着它只能用在基于 Servlet 的 Web 应用中</li>
</ul>
<h4 id="视图解析器-2">视图解析器</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* JavaConfig配置 */</span></span><br><span class="line"><span class="comment">// 视图解析器: 将逻辑视图名称解析为Thymeleaf模板视图</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ViewResolver <span class="title">viewResolver</span><span class="params">(ISpringTemplateEngine engine)</span> </span>&#123;</span><br><span class="line">    ThymeleafViewResolver resolver = <span class="keyword">new</span> ThymeleafViewResolver();</span><br><span class="line">    resolver.setTemplateEngine(engine);</span><br><span class="line">    <span class="keyword">return</span> resolver;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 模板引擎: 处理模板并渲染结果</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ISpringTemplateEngine <span class="title">templateEngine</span><span class="params">(ITemplateResolver resolver)</span> </span>&#123;</span><br><span class="line">    SpringTemplateEngine engine = <span class="keyword">new</span> SpringTemplateEngine();</span><br><span class="line">    engine.setTemplateResolver(resolver);</span><br><span class="line">    <span class="keyword">return</span> engine;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 模板解析器: 加载Thymeleaf模板</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ITemplateResolver <span class="title">templateResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SpringResourceTemplateResolver resolver = <span class="keyword">new</span> SpringResourceTemplateResolver();</span><br><span class="line">    resolver.setPrefix(<span class="string">&quot;/templates/&quot;</span>);</span><br><span class="line">    resolver.setSuffix(<span class="string">&quot;.html&quot;</span>);</span><br><span class="line">    resolver.setTemplateMode(<span class="string">&quot;HTML5&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> resolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- XML配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;resolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:templateEngine-ref</span>=<span class="string">&quot;engine&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;engine&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:templateResolver-ref</span>=<span class="string">&quot;templateResolver&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;templateResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:prefix</span>=<span class="string">&quot;/templates/&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:suffix</span>=<span class="string">&quot;.html&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:templateMode</span>=<span class="string">&quot;HTML5&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="模板">模板</h4>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- user.html页面 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>User<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--/*@thymesVar id=&quot;user&quot; type=&quot;com.janz.spring.model.User&quot;*/--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">th:object</span>=<span class="string">&quot;$&#123;user&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;#fields.hasErrors(&#x27;*&#x27;)&#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">th:each</span>=<span class="string">&quot;err : $&#123;#fields.errors(&#x27;*&#x27;)&#125;&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;err&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>account: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;*&#123;account&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>password: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;*&#123;password&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;register&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>$&#123;&#125;</code> 是变量表达式, 一般是对象导航语言(Object-Graph Navigation Language, OGNL)表达式, 在使用 Spring 的时候是 SpEL 表达式, 是基于整个 SpEL 上下文计算的, 示例中 <code>$&#123;user&#125;</code> 会解析 <code>model</code> 中 <code>key=user</code> 的值</p>
<p><code>*&#123;&#125;</code> 是选择表达式, 是基于某一个选中对象计算的, 示例中 <code>th:object="$&#123;user&#125;"</code> 设置对象为模型中的 <code>User</code> 对象, 因此 <code>*&#123;account&#125;</code> 会解析 <code>user.account</code> 属性</p>
</blockquote>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 007 Web 扩展</title>
    <url>/2019/07/29/spring/007/</url>
    <content><![CDATA[<h1 id="spring-web-扩展">Spring Web 扩展</h1>
<h2 id="multipart-数据">multipart 数据</h2>
<p>multipart 格式的数据会将一个表单拆分为多个部分, 每个部分对应一个输入域, 在一般的表单输入域中, 它所对应的部分中会放置文本型数据, 但是如果上传文件的话, 它所对应的部分可以是二进制</p>
<h3 id="解析器">解析器</h3>
<p><code>DispatcherServlet</code> 并没有实现任何解析 <code>multipart</code> 请求数据的功能, 它将该任务委托给了 Spring 中 <code>MultipartResolver</code> 策略接口的实现, 通过这个实现类来解析 <code>multipart</code> 请求中的内容, 从 Spring 3.1 开始, Spring 内置了两个 <code>MultipartResolver</code> 的实现供选择:</p>
<ul>
<li><code>CommonsMultipartResolver</code> 使用 Jakarta Commons FileUpload 解析请求;</li>
<li><code>StandardServletMultipartResolver</code> 依赖于 Servlet 3.0 对 multipart 请求的支持 (始于 Spring 3.1)</li>
</ul>
<blockquote>
<p>一般来讲, 在这两者之间, <code>StandardServletMultipartResolver</code> 可能会是优选的方案, 它使用 Servlet 所提供的功能支持, 并不需要依赖任何其他的项目, 如果需要将应用部署到 Servlet 3.0 之前的容器中, 或者还没有使用 Spring 3.1 或更高版本, 那么可能就需要 <code>CommonMultipartResolver</code> 了</p>
</blockquote>
<h3 id="配置">配置</h3>
<p>需要在 Servlet 中指定 multipart 的配置, 如果不设定最基本配置的话, <code>StandardServletMultipartResolver</code> 就无法正常工作</p>
<h4 id="javaconfig">JavaConfig</h4>
<p>如果配置 <code>DispatcherServlet</code> 的初始化类继承了 <code>AbstactAnnotationConfigDispatcherServletInitia-lizer</code> 的话, 可以通过重载 <code>customizeRegistration</code> 方法来配置 multipart 的具体细节</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 重载配置 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebAppInitializer</span> <span class="keyword">extends</span> <span class="title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizeRegistration</span><span class="params">(ServletRegistration.Dynamic registration)</span> </span>&#123;</span><br><span class="line">        registration.setMultipartConfig(<span class="keyword">new</span> MultipartConfigElement(</span><br><span class="line">            <span class="string">&quot;/tmp&quot;</span>, <span class="comment">// 上传文件的临时目录(必须配置)</span></span><br><span class="line">            <span class="number">2097152</span>, <span class="comment">// 上传文件的最大容量(以字节为单位), 默认没有限制</span></span><br><span class="line">            <span class="number">4194304</span>, <span class="comment">// 整个multipart请求的最大容量(以字节为单位), 默认没有限制</span></span><br><span class="line">            <span class="number">0</span> <span class="comment">// 上传过程中触发写入磁盘的最大容量(以字节为单位), 默认值为0</span></span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="xml">XML</h4>
<p>使用传统 <code>web.xml</code> 配置 <code>MultipartConfigElement</code> 的话, 可以使用 <code>&lt;servlet&gt;&lt;multipart-config&gt;</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- XML配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">multipart-config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">location</span>&gt;</span>/tmp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">max-file-size</span>&gt;</span>2097152<span class="tag">&lt;/<span class="name">max-file-size</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">max-request-size</span>&gt;</span>4194304<span class="tag">&lt;/<span class="name">max-request-size</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">multipart-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="处理请求">处理请求</h3>
<p>控制器方法接收上传的文件, 最常见的方式是在某个控制器方法参数上添加 <code>@RequestPart</code> 注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 接收multipart数据 */</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/form&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">form</span><span class="params">(<span class="meta">@RequestPart</span> <span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;home&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring 提供了 <code>MultipartFile</code> 接口, 它为处理 multipart 数据提供了内容更为丰富的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Multipart接口 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MultipartFile</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getOriginalFilename</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getContentType</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">byte</span>[] getBytes() <span class="keyword">throws</span> IOException;</span><br><span class="line">    <span class="function">InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transferTo</span><span class="params">(Path dest)</span> <span class="keyword">throws</span> IOException, IllegalStateException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 接收MultipartFile参数 */</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/form2&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">form</span><span class="params">(<span class="meta">@RequestPart</span> MultipartFile data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;home&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果将应用部署到 Servlet 3.0 的容器中, 那么 Spring MVC 也能接受 <code>Part</code> 作为控制器方法的参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Part接口 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Part</span> </span>&#123;</span><br><span class="line">    <span class="function">InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="function">String <span class="title">getContentType</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getSubmittedFileName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 接收Part参数 */</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/form3&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">form</span><span class="params">(<span class="meta">@RequestPart</span> Part data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;home&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过 <code>Part</code> 参数的形式接收文件上传, 没有必要配置 <code>MultipartResolver</code></p>
</blockquote>
<h3 id="测试">测试</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 测试 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">form</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] data = <span class="string">&quot;图片数据&quot;</span>.getBytes();</span><br><span class="line">    MockMultipartFile file = <span class="keyword">new</span> MockMultipartFile(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;image.png&quot;</span>, <span class="string">&quot;application/x-png&quot;</span>, data);</span><br><span class="line"></span><br><span class="line">    mockMvc.perform(MockMvcRequestBuilders.multipart(<span class="string">&quot;/form&quot;</span>).file(file))</span><br><span class="line">        .andExpect(MockMvcResultMatchers.view().name(<span class="string">&quot;home&quot;</span>));</span><br><span class="line"></span><br><span class="line">    mockMvc.perform(MockMvcRequestBuilders.multipart(<span class="string">&quot;/form2&quot;</span>).file(file))</span><br><span class="line">        .andExpect(MockMvcResultMatchers.view().name(<span class="string">&quot;home&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">form3</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] data = <span class="string">&quot;图片数据&quot;</span>.getBytes();</span><br><span class="line">    MockPart part = <span class="keyword">new</span> MockPart(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;image.png&quot;</span>, data);</span><br><span class="line"></span><br><span class="line">    mockMvc.perform(MockMvcRequestBuilders.multipart(<span class="string">&quot;/form3&quot;</span>).part(part))</span><br><span class="line">        .andExpect(MockMvcResultMatchers.view().name(<span class="string">&quot;home&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="处理异常">处理异常</h2>
<p>Spring 提供了多种方式将异常转换为响应:</p>
<ul>
<li>特定的 Spring 异常将会自动映射为指定的 HTTP 状态码;</li>
<li>异常上可以添加 <code>@ResponseStatus</code> 注解, 从而将其映射为某一个 HTTP 状态码;</li>
<li>在方法上可以添加 <code>@ExceptionHandler</code> 注解, 使其用来处理异常</li>
</ul>
<h3 id="异常映射">异常映射</h3>
<p>在默认情况下, Spring 会将自身的一些异常自动转换为合适的状态码</p>
<p><strong>表 Spring 的一些异常会默认映射为 HTTP 状态码</strong></p>
<table>
<thead>
<tr class="header">
<th>Spring 异常</th>
<th>HTTP 状态码</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>BindException</code></td>
<td>400</td>
</tr>
<tr class="even">
<td><code>ConversionNotSupportedException</code></td>
<td>500</td>
</tr>
<tr class="odd">
<td><code>HttpMediaTypeNotAcceptableException</code></td>
<td>406</td>
</tr>
<tr class="even">
<td><code>HttpMediaTypeNotSupportedException</code></td>
<td>415</td>
</tr>
<tr class="odd">
<td><code>HttpMessageNotReadableException</code></td>
<td>400</td>
</tr>
<tr class="even">
<td><code>HttpMessageNotWritableException</code></td>
<td>500</td>
</tr>
<tr class="odd">
<td><code>HttpRequestMethodNotSupportedException</code></td>
<td>405</td>
</tr>
<tr class="even">
<td><code>MethodArgumentNotValidException</code></td>
<td>400</td>
</tr>
<tr class="odd">
<td><code>MissingServletRequestParameterException</code></td>
<td>400</td>
</tr>
<tr class="even">
<td><code>MissingServletRequesrPartException</code></td>
<td>400</td>
</tr>
<tr class="odd">
<td><code>NoSuchRequestHandlingMethodException</code></td>
<td>404</td>
</tr>
<tr class="even">
<td><code>TypeMismatchException</code></td>
<td>400</td>
</tr>
</tbody>
</table>
<p>对于应用所抛出的异常, Spring 提供了一种机制, 能够通过 <code>@ResponseStatus</code> 注解将异常映射为 HTTP 状态码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 自定义异常映射为HTTP状态码 */</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/error2&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ModelNotFoundException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@ResponseStatus(code = HttpStatus.NOT_FOUND, reason = &quot;model not found&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelNotFoundException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不使用@ResponseStatus时, 异常默认会产生500状态码(Internal Server Error)的响应</span></span><br></pre></td></tr></table></figure>
<h3 id="异常处理">异常处理</h3>
<p>Spring 提供 <code>@ExceptionHandler</code> 注解委托处理异常</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 异常处理 */</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;error3&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ModelDuplicateException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@ExceptionHandler(ModelDuplicateException.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handler</span><span class="params">(ModelDuplicateException exception)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;do something ...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>对于 <code>@ExceptionHandler</code> 注解标注的方法来说, 它能够处理同一个控制器中所有处理器方法所抛出的异常</p>
</blockquote>
<h3 id="测试-1">测试</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 测试 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">&quot;/error&quot;</span>))</span><br><span class="line">        .andExpect(MockMvcResultMatchers.status().is5xxServerError());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">&quot;/error2&quot;</span>))</span><br><span class="line">        .andExpect(MockMvcResultMatchers.status().is4xxClientError());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error3</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">&quot;/error3&quot;</span>))</span><br><span class="line">        .andExpect(MockMvcResultMatchers.view().name(<span class="string">&quot;error&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="控制器通知">控制器通知</h2>
<p>如果控制器类的特定切面能够运用到整个应用程序的所有控制器中, 那么这将会便利很多, Spring 3.2 为这类问题引入了控制器通知 (Controller Advice)</p>
<p>控制器通知是任意带有 <code>@ControllerAdvice</code> 注解的类, 这个类会包含一个或多个如下类型的方法:</p>
<ul>
<li><code>@ExceptionHandler</code></li>
<li><code>@InitBinder</code></li>
<li><code>@ModelAttribute</code></li>
</ul>
<h2 id="跨重定向请求传递数据">跨重定向请求传递数据</h2>
<p>对于重定向来说, 模型并不能用来传递数据, 但是有一些其他方案:</p>
<ul>
<li>使用 URL 模板以路径变量和 / 或查询参数的形式传递数据;</li>
<li>通过 <code>flash</code> 属性发送数据</li>
</ul>
<h3 id="url-模板">URL 模板</h3>
<p>通过路径变量和查询参数传递数据非常简单, 当构建 URL 或 SQL 查询语句的时候, 使用 <code>String</code> 连接是很危险的, Spring 提供了使用模板的方式来定义重定向 URL</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* URL模板 */</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/login&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;do something ...&quot;</span>);</span><br><span class="line">    <span class="comment">// username作为占位符填充到URL模板中</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">    <span class="comment">// userId没有匹配到占位符, 会自动以查询参数的形式附加到重定向URL上</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;userId&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/login/&#123;username&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/login/&#123;username&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(<span class="meta">@PathVariable</span> String username,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="meta">@RequestParam</span> String userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;home&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="flash-属性">flash 属性</h3>
<p>Spring 提供了将数据发送为 <code>flash</code> 属性的功能, 在重定向之前, 所有的 <code>flash</code> 属性都会复制到会话中, 在重定向后, 存在会话中的 <code>flash</code> 属性会被取出, 并从会话转移到模型中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/login2&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login2</span><span class="params">(RedirectAttributes model)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;do something ...&quot;</span>);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">    model.addFlashAttribute(<span class="string">&quot;userId&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/login/&#123;username&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/login2/&#123;username&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login2</span><span class="params">(<span class="meta">@PathVariable</span> String username, Model model)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!model.containsAttribute(<span class="string">&quot;userId&quot;</span>))</span><br><span class="line">        model.addAttribute(<span class="string">&quot;userId&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;home&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 010 Data</title>
    <url>/2019/09/08/spring/010/</url>
    <content><![CDATA[<h1 id="spring-data">Spring Data</h1>
<h2 id="数据访问体系">数据访问体系</h2>
<p>当开发应用的持久层的时候, 会面临多种选择, 可以使用 JDBC, Hibernate, JPA 或者其他任意的持久化框架, 可能还会考虑使用 NoSQL 数据库, 不管选择哪种持久化方式, Spring 都能够提供支持</p>
<h3 id="模板">模板</h3>
<p>Spring 将数据访问过程中固定的和可变的部分明确划分为两个不同的类:</p>
<ul>
<li>模板(template) 管理过程中固定的部分</li>
<li>回调(callback) 处理自定义的数据访问代码</li>
</ul>
<p>针对不同的持久化平台, Spring 提供了多个可选的模板</p>
<p><strong>表 Spring 提供的数据模板</strong></p>
<table>
<colgroup>
<col style="width: 46%" />
<col style="width: 53%" />
</colgroup>
<thead>
<tr class="header">
<th>模板类(<code>org.springframework.*</code>)</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>jca.cci.core.CciTemplate</code></td>
<td>JCA CCI 连接</td>
</tr>
<tr class="even">
<td><code>jdbc.core.JdbcTemplate</code></td>
<td>JDBC 连接</td>
</tr>
<tr class="odd">
<td><code>jdbc.core.namedparam.NamedParameterJdbcTemplate</code></td>
<td>支持命名参数的 JDBC 连接</td>
</tr>
<tr class="even">
<td><code>jdbc.core.simple.SimpleJdbcTemplate</code></td>
<td>通过 Java 5 简化后的 JDBC 连接<br>(Spring 3.1 中已经废弃)</td>
</tr>
<tr class="odd">
<td><code>orm.hibernate3.HibernateTemplate</code></td>
<td>Hibernate 3.x 以上的 Session</td>
</tr>
<tr class="even">
<td><code>orm.ibatis.SqlMapClientTemplate</code></td>
<td>iBATIS SqlMap 客户端</td>
</tr>
<tr class="odd">
<td><code>orm.jdo.JdpTemplate</code></td>
<td>Java 数据对象实现</td>
</tr>
<tr class="even">
<td><code>orm.jpa.JpaTemplate</code></td>
<td>Java 持久化 API 的实体管理器</td>
</tr>
</tbody>
</table>
<h3 id="异常">异常</h3>
<p>Spring 的异常体系比 JDBC 简单的 <code>SQLException</code> 丰富得多, 但它并没有与特定的持久化方式相关联, 这意味着可以使用 Spring 抛出一致的异常, 而不用关系所选择的持久化方案, 这有助于将选择持久化机制与数据访问层隔离开来</p>
<p><strong>表 JDBC 与 Spring 的数据访问异常</strong></p>
<table>
<thead>
<tr class="header">
<th>JDBC 的异常</th>
<th>Spring 的数据访问异常(部分)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>BatchUpdateException</code></td>
<td><code>BadSqlGrammarException</code></td>
</tr>
<tr class="even">
<td><code>DataTruncation</code></td>
<td><code>CannotAcquireLockException</code></td>
</tr>
<tr class="odd">
<td><code>SQLException</code></td>
<td><code>CannotSerializeTranssactionException</code></td>
</tr>
<tr class="even">
<td><code>SQLWarning</code></td>
<td><code>CannotGetJdbcConnectionException</code></td>
</tr>
<tr class="odd">
<td></td>
<td><code>CleanupFailureDataAccessException</code></td>
</tr>
<tr class="even">
<td></td>
<td><code>ConcurrencyFailureException</code></td>
</tr>
<tr class="odd">
<td></td>
<td><code>DataAccessException</code></td>
</tr>
<tr class="even">
<td></td>
<td><code>EmptyResultDataAccessException</code></td>
</tr>
<tr class="odd">
<td></td>
<td><code>IncorrectResultSizeDataAccessException</code></td>
</tr>
<tr class="even">
<td></td>
<td><code>IncorrectUpdateSemanticsDataAccessException</code></td>
</tr>
<tr class="odd">
<td></td>
<td><code>InvalidDataAccessApiUsageException</code></td>
</tr>
<tr class="even">
<td></td>
<td><code>QueryTimeoutException</code></td>
</tr>
<tr class="odd">
<td></td>
<td><code>TransientDataAccessException</code></td>
</tr>
<tr class="even">
<td></td>
<td><code>UncategorizedSQLException</code></td>
</tr>
<tr class="odd">
<td></td>
<td><code>...</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p>Spring 的数据访问异常都继承自 <code>DataAccessException</code>, <code>DataAccessException</code> 的特殊之处在于它是一个非检查型异常</p>
</blockquote>
<h2 id="数据源">数据源</h2>
<p>Spring 提供了在上下文中配置数据源 <code>bean</code> 的多种方式, 包括:</p>
<ul>
<li>通过 JDBC 驱动程序定义的数据源;</li>
<li>通过 JNDI 查找的数据源;</li>
<li>连接池的数据源</li>
</ul>
<h3 id="jndi">JNDI</h3>
<p>Spring 应用程序经常部署在 Java EE 应用服务器中, 这些服务器允许配置通过 JNDI 获取数据源, 这种配置的好处在于数据源完全可以在应用程序之外进行管理, 另外, 在应用服务器中管理的数据源通常以池的方式组织, 从而具备更好的性能, 并且还支持系统管理员对其进行热切换</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- XML配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jee:jndi-lookup</span> <span class="attr">id</span>=<span class="string">&quot;database&quot;</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">jndi-name</span>=<span class="string">&quot;/jdbc/SpitterDS&quot;</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">resource-ref</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Java配置 */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JndiObjectFactory <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    JndiObjectFactoryBean jndi = <span class="keyword">new</span> JndiObjectFactoryBean();</span><br><span class="line">    jndi.setJndiName(<span class="string">&quot;/jdbc/SpitterDS&quot;</span>);</span><br><span class="line">    jndi.setResourceRef(<span class="keyword">true</span>);</span><br><span class="line">    jndi.setProxyInterface(javax.sql.DataSource.class)</span><br><span class="line">    <span class="keyword">return</span> jndi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="连接池">连接池</h3>
<p>Spring 并没有提供数据源连接池实现, 但是有多项可用的开源方案, 包括:</p>
<ul>
<li><a href="http://commons.apache.org/proper/commons-dbcp/">Apache Commons DBCP</a></li>
<li><a href="https://sourceforge.net/projects/c3p0/">c3p0</a></li>
<li><a href="https://jolbox.com/">BoneCP</a></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- XML配置: 示例DBCP --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;database&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:driverClassName</span>=<span class="string">&quot;org.h2.Driver&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:username</span>=<span class="string">&quot;sa&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:password</span>=<span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:initialSize</span>=<span class="string">&quot;5&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:maxActive</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Java配置 */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BaseicDataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BasicDataSource ds = <span class="keyword">new</span> BasicDataSource();</span><br><span class="line">    ds.setDriverClassName(<span class="string">&quot;org.h2.Driver&quot;</span>);</span><br><span class="line">    ds.setUrl(<span class="string">&quot;jdbc:h2:tcp://localhost/~/spitter&quot;</span>);</span><br><span class="line">    ds.setUsername(<span class="string">&quot;sa&quot;</span>);</span><br><span class="line">    ds.setPassword(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    ds.setInitialSize(<span class="number">5</span>);</span><br><span class="line">    ds.setMaxActive(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> ds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jdbc-驱动">JDBC 驱动</h3>
<p>Spring 提供了三个 JDBC 驱动定义的数据源类供选择:</p>
<ul>
<li><code>DriverManagerDataSource</code> 在每个连接请求时都会返回一个新建的连接;</li>
<li><code>SimpleDriverDataSource</code> 直接使用 JDBC 驱动来解决特定环境下的类加载问题;</li>
<li><code>SingleConnectionDataSource</code> 在每个连接请求时都会返回同一个连接</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- XML配置: 示例DriverManagerDataSource --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:drivcerClassName</span>=<span class="string">&quot;org.h2.Driver&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:url</span>=<span class="string">&quot;jdbc:h2:tcp://localhost/~spitter&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:username</span>=<span class="string">&quot;sa&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:password</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Java配置 */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DriverManagerDataSource ds = <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">    ds.setDriverClassName(<span class="string">&quot;org.h2.Driver&quot;</span>);</span><br><span class="line">    ds.setUrl(<span class="string">&quot;jdbc:h2:tcp://localhost/~/spitter&quot;</span>);</span><br><span class="line">    ds.setUsername(<span class="string">&quot;sa&quot;</span>);</span><br><span class="line">    ds.setPassword(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="嵌入式">嵌入式</h3>
<p>嵌入式数据库作为应用的一部分运行, 而不是应用连接的独立数据库服务器, 尽管在生产环境的设置中, 它并没有太大的用处, 但是对于开发和测试来讲, 嵌入式数据库都是很好的可选方案</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- XML配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jdbc:embedded-database</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">type</span>=<span class="string">&quot;H2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">&quot;com/habuma/spitter/db/jdbc/schema.sql&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">&quot;com/habuma/spitter/db/jdbc/test-data.sql&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">jdbc:embedded-database</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Java配置 */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder()</span><br><span class="line">        .setType(EmbeddedDatabaseType.H2)</span><br><span class="line">        .addScript(<span class="string">&quot;classpath:schema.sql&quot;</span>)</span><br><span class="line">        .addScript(<span class="string">&quot;classpath:test-data.sql&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="profile">Profile</h2>
<p>通过使用 <code>profile</code> 功能在运行时选择数据源, 这取决于哪一个 <code>profile</code> 处于激活状态</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- XML配置 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- QA数据源 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">&quot;qa&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jdbc:embedded-database</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 生产环境的数据源 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">&quot;production&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jee:jndi-lookup</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Java配置 */</span></span><br><span class="line"><span class="meta">@Profile(&quot;qa&quot;)</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BasicDataSource();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Profile(&quot;production&quot;)</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JndiObjectFactoryBean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
</search>
